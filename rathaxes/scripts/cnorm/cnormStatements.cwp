/*
** cnormStatements.cwp for
** "C normalise"
** 
** Authors:
**	Lionel Auroux
** Contributors:
**	Cedric Lemaire
**	David Giron
**	David Amsallem	
**
** see cnorm.cwp for details
*/

//----------------------------------------------------------------------------
//                              S T A T E M E N T S
//----------------------------------------------------------------------------

/*
  Cette partie est la plus simple de la grammaire est decrit comment on
  ecrit des phrases en C.
*/
single_statement(theStatement : node) ::=
	["__extension__"]? /* GnuC : pour enlever les warnings des extensions */
	[
		compound_statement(theStatement)
		| labeled_statement(theStatement)
		| expression_statement(theStatement)
	]
;

/*
  block entre accolade
*/
compound_statement(theStatement : node) ::=
'{'  #continue
	=> localref rStatement = theStatement;
	=> {
	  // cas du block seul
	  if (!existVariable(rStatement.otype))
	  {
	    pushItem rStatement;
	    ref rStatement = rStatement#back;
	    insert rStatement.etype = "statement";
	    insert rStatement.otype = "block";
	  }
	  insert rStatement.block;
	  insert rStatement.block.pctx;
	  ref rStatement.block.pctx = this.gl_pctx;
	}
	block_item_list(rStatement.block) 
'}'
;

/*
  suite de phrase en C
*/
block_item_list(theStatement : node) ::=
	[ line_of_code(theStatement) ]*
;

/*
  element d´un bloc (ligne de code)
  facilement surchargeable :)
*/
line_of_code(theStatement : node) ::=
[// variable globale pour stocker le contexte de l'expression (ecraser a chaque expr)
 => local rSavePctx;
 => {
   if (!existVariable(this.gl_pctx))
   { insert this.gl_pctx;}
   else
   { ref rSavePctx = this.gl_pctx;}
   ref this.gl_pctx = theStatement;
 }
	[
	// declaration variable
	declaration(theStatement)
	| // ou code 
	single_statement(theStatement)
	]
 // restaure le contexte
 => ref this.gl_pctx = rSavePctx;
]
;

/*
  structure du langage (if,for,while) et label
*/
labeled_statement(theStatement : node) ::=
	#readIdentifier:sKeyword statement<sKeyword>(theStatement)
;

/*
  label
 */
statement<sKeyword>(theStatement : node) ::= ':' #continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "label";
	=> insert theStatement#back.otype = "label";
	=> insert theStatement#back.etype = "statement";
	=> insert theStatement#back.label = sKeyword;
;

/*
  if else
*/
statement<"if">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "if";
	=> insert theStatement#back.otype = "if";
	=> insert theStatement#back.etype = "statement";
	'(' expression(theStatement#back.condition) ')' 
	// on cree une reference sur le contexte parent
	=> insert theStatement#back.then;
	=> insert theStatement#back.then.pctx;
	=> insert theStatement#back.then.otype = "then";
	=> ref theStatement#back.then.pctx = this.gl_pctx;
	single_statement(theStatement#back.then)
     [ "else" #continue 
       // on cree une reference sur le contexte parent
       => insert theStatement#back.else;
       => insert theStatement#back.else.pctx;
       => insert theStatement#back.else.otype = "else";
       => ref theStatement#back.else.pctx = this.gl_pctx;
       single_statement(theStatement#back.else) 	  
     ]?
;

/*
  switch
*/
statement<"switch">(theStatement : node) ::=
	#continue
	=> pushItem theStatement;
	=> insert theStatement#back.type = "switch";
	=> insert theStatement#back.otype = "switch";
	=> insert theStatement#back.etype = "statement";
	'(' expression(theStatement#back.condition) ')' 
	// on cree une reference sur le contexte parent
	=> insert theStatement#back.block;
	=> insert theStatement#back.block.pctx;
	=> insert theStatement#back.block.type = "{}";
	=> ref theStatement#back.block.pctx = this.gl_pctx;
	'{'
[ 
	"case" statement<"case">(theStatement#back.block)
|	"default" statement<"default">(theStatement#back.block)
]*
	'}'
;

/*
  regle valide uniquement dans un case sans {}
*/
notlabeled_statement(theStatement : node) ::=
[
"if" statement<"if">(theStatement) 
| "switch" statement<"switch">(theStatement) 
| "while" statement<"while">(theStatement) 
| "do" statement<"do">(theStatement) 
| "for" statement<"for">(theStatement) 
| "goto" statement<"goto">(theStatement) 
| "continue" statement<"continue">(theStatement) 
| "break" statement<"break">(theStatement) 
| "return" statement<"return">(theStatement) 
]
;

/*
  case d'un switch
  TODO: revoir script generation pour case
*/
statement<"case">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "case";
	=> insert theStatement#back.label = "case";
	=> insert theStatement#back.otype = "label";
	=> insert theStatement#back.etype = "statement";
	[
	 range_expression(theStatement#back.case)	/* GnuC */
	 | constant_expression(theStatement#back.case) 
	]
	':'
	=> local rSavePctx;
	=> ref rSavePctx = this.gl_pctx;
	[
	 // on cree une reference sur le contexte parent
	 #insert(theStatement#back.block)
	 => insert theStatement#back.block.pctx;////
	 => ref theStatement#back.block.pctx = this.gl_pctx;////
	  [  
	   compound_statement(theStatement#back)////
	  | notlabeled_statement(theStatement#back.block)
	  | expression_statement(theStatement#back.block)
	  ]
         => ref this.gl_pctx = rSavePctx;
	]*
;

/*
  default d'un switch
  TODO: revoir script generation pour default
*/
statement<"default">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "default";
	=> insert theStatement#back.label = "default";
	=> insert theStatement#back.otype = "label";
	=> insert theStatement#back.etype = "statement";
	':'
	[
	 // on cree une reference sur le contexte parent
	 #insert(theStatement#back.block)
	 => insert theStatement#back.block.pctx;
	 => ref theStatement#back.block.pctx = this.gl_pctx;
	  [  
	   compound_statement(theStatement#back/*.block*/)/////
	  | notlabeled_statement(theStatement#back.block)
	  | expression_statement(theStatement#back.block)
	  ]
	]*
;

/*
  while
*/
statement<"while">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "while";
	=> insert theStatement#back.otype = "while";
	=> insert theStatement#back.etype = "statement";
	'(' expression(theStatement#back.condition) ')'
	// on cree une reference sur le contexte parent
	=> insert theStatement#back.stmt;
	=> insert theStatement#back.stmt.otype = "stmt";
	=> insert theStatement#back.stmt.pctx;
	=> ref theStatement#back.stmt.pctx = this.gl_pctx;
	single_statement(theStatement#back.stmt)
;

/*
  do while
*/
statement<"do">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "do";
	=> insert theStatement#back.otype = "do";
	=> insert theStatement#back.etype = "statement";
	// on cree une reference sur le contexte parent
	=> insert theStatement#back.stmt;
	=> insert theStatement#back.stmt.otype = "stmt";
	=> insert theStatement#back.stmt.pctx;
	=> ref theStatement#back.stmt.pctx = this.gl_pctx;
	single_statement(theStatement#back.stmt) "while" 
	'(' expression(theStatement#back.condition) ')' ';'
;

/*
  for
*/
statement<"for">(theStatement : node) ::= #continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "for";
	=> insert theStatement#back.otype = "for";
	=> insert theStatement#back.etype = "statement";
	'(' 
	[ #insert(theStatement#back.init) line_of_code(theStatement#back.init)]?
	[ #insert(theStatement#back.condition) expression(theStatement#back.condition) ]? ';' 
	[ #insert(theStatement#back.increment) expression(theStatement#back.increment) ]? 
	 ')'
	// on cree une reference sur le contexte parent
	=> insert theStatement#back.stmt;
	=> insert theStatement#back.stmt.otype = "stmt";
	=> insert theStatement#back.stmt.pctx;
	=> ref theStatement#back.stmt.pctx = this.gl_pctx;
	single_statement(theStatement#back.stmt)
;

/* goto */
statement<"goto">(theStatement : node) ::=
	#continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "goto";
	=> insert theStatement#back.otype = "pseudoexpression";
	=> insert theStatement#back.etype = "expression";
	constant_expression(theStatement#back.block):theStatement#back.label /* maybe I should send a fake node */
	';'
;

/* continue */
statement<"continue">(theStatement : node) ::=
	#continue 
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "continue";
	=> insert theStatement#back.otype = "pseudoexpression";
	=> insert theStatement#back.etype = "expression";
	';'
;

/* break */
statement<"break">(theStatement : node) ::=
	#continue 
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "break";
	=> insert theStatement#back.otype = "pseudoexpression";
	=> insert theStatement#back.etype = "expression";
	';'
;

/* return */
statement<"return">(theStatement : node) ::=
	#continue
	=> pushItem theStatement;
	=> insert theStatement#back.__LINE__ = countInputLines();
	=> insert theStatement#back.type = "return";
	=> insert theStatement#back.otype = "pseudoexpression";
	=> insert theStatement#back.etype = "expression";
	[
	 // on cree une reference sur le contexte parent
	#insert(theStatement#back.block)
	 => insert theStatement#back.block.pctx;
	 => ref theStatement#back.block.pctx = this.gl_pctx;
	 expression(theStatement#back.block)
	 ]?:sK
	#continue ';'	
;

/* expression en C finit par un ; */
expression_statement(theStatement : node) ::=
	[ #pushItem(theStatement)
	  => local nLine = countInputLines();
	  expression(theStatement#back)
	  => insert theStatement#back.etype = "expression";
	  /* On stocke le numero de la ligne courante dans l'arbre*/
	  => insert theStatement#back.__LINE__ = nLine;
	]? ';'
	|
	[//TODO: mettre dans l´arbre
		masm_expr [';']?
	]
;


/* Ici la liste des identifiants */
identifier ::=
	myIdentifier:sId
	#check(!(sId in 
	    {"auto", "register", "static", "extern", "inline", "typedef", 
	     "void", "char", "short", "int", "long", "float", "double", 
	     "signed", "unsigned", "struct", "union", "const",
	     "volatile", "__volatile", "__volatile__", "sizeof", "enum", "case", "default", 
	     "if", "else", "while", "do", "for", "goto", "continue", 
	     "break", "return", "asm",
	     /* c99 & GnuC */
	     "typeof", "__typeof", "__typeof__",
	     "__complex", "__complex__", "_Complex",
	     "__alignof", "__alignof__", "_Bool",
	     "__label__", /*"attribute",*/ "__attribute", "__attribute__",
	     "__real", "__imag", "__real__", "__imag__",
	     "_Imaginary", "__asm", "__asm__", 
	     "__builtin_offsetof", "__builtin_va_list",
	     "__extension__", "__const", "__restrict", "__inline", "__inline__",
		 /* Windows */
		 "__w64", "__int8", "__int16", "__int32", "__int64", "__ptr32", "__ptr64",
		 "__cdecl", "__stdcall", "__fastcall", "_fastcall", "__declspec",
         "__forceinline"
	    }))     
;

myIdentifier ::=
	#!ignore ['a'..'z'|'A'..'Z'|'_']
	['a'..'z'|'A'..'Z'|'0'..'9'|'_'|'$']*
;

