rtx_stmt<"template">(theBlock : node) ::=
    =>traceLine("TEMPLATE!");
    // TODO: on ne parse pas correctement le proto on prend tout
        [#!ignore ->(:head)[['\n'|' '|'\t']* '{']] // on est des boeufs
    ////////
        // on cree un block pour heberger le node template
        #pushItem(theBlock.block)
        => local lastNode;
        #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
        // on cree un rtxTPL et c_block va reference le block de C
        => local c_block;
        #check(rtxNodeTpl(lastNode, head, c_block))
        => traceLine("tplproto :" + head + " next:" + peekChar());
        =>traceLine("Chunks!");
        [
            // Theoretically, the template should only contain chunks...
            rtx_declaration(c_block)
        ]*
    '}'
;

/////// WITH
rtx_stmt_with_map(theMap : node) ::=
    #readIdentifier:sKey '=' [#readIdentifier|#readInteger]:sVal
    => insert theMap[sKey] = sVal;
;
rtx_stmt_with(theMap: node) ::=
    rtx_stmt_with_map(theMap) [',' rtx_stmt_with_map(theMap)]*
;
rtx_stmt<"with">(theBlock : node) ::=
    => traceLine("WITH");
    // on cree un block pour heberger le node template
    #pushItem(theBlock.block)
    => local lastNode;
    #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
    // lien vers le mapping des variables
    => local var_map;
    => local body;
    #check(rtxNodeWith(lastNode, var_map, body))
    // les var du with
    rtx_stmt_with(var_map)
    // le block du with
    '{'
        [
            //#check(cnormNodeCtx(body))
            rtx_declaration(body)
        ]*
    '}'
;

//////// CHUNK
// The pointuct's identifier may be scoped with some interfaces' names.
rtx_stmt_chunk_scoped_identifier(sPointCut : reference) ::=
    => local string = "";
    [
        #readIdentifier:sSubSystem
        "::"
        => string += sSubSystem + "::";
    ]*
    #readIdentifier:sUnscopedPointcut
    => string += sUnscopedPointcut;
    => ref sPointCut = string;
;
// If there is any parameters to the chunk, we push it into a param list
rtx_stmt_chunk_params(theParams : node) ::=
    '('
    => local parameters;
    #readIdentifier:sSymbol
    #pushItem(parameters)
    => parameters#back = sSymbol;
    [
        ','
        #readIdentifier:sSymbol
        #pushItem(parameters)
        => parameters#back = sSymbol;
    ]*
    ')'
;
rtx_stmt<"chunk">(theBlock : node) ::=
    =>traceLine("CHUNK");
    // Create an item in the Block list to host the chunk
    #pushItem(theBlock.block)
    => local lastNode;
    #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
    => local sPointCut;
    rtx_stmt_chunk_scoped_identifier(sPointCut)
    // Optional Joinpoint (argument of the pointcut)
    => local parameters;
    => local body;
    // Build the chunk node, and retrieve the references to it's internals
    // (body and parameters)
    #check(rtxNodeChunk(lastNode, sPointCut, parameters, body))
    [
        rtx_stmt_chunk_params(parameters)
    ]?
    '{'
        block_item_list(body)
    '}'
;


// on s'emmerde pas...pour l'instant :P
rtx_template_code ::= #!ignore "${" -> '}' 
;

/*
 * This rule overload allows the template identifier concatenation
 * for Rathaxes.
 */
#overload
rootidentifier ::= #!ignore
    [ 'a'..'z' | 'A'..'Z' | '_' | rtx_template_code:code ]
    [ 'a'..'z' | 'A'..'Z' | '0'..'9' | '_' | rtx_template_code ]*
;

