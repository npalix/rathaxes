rtx_stmt<"template">(theBlock : node) ::=
    =>traceLine("TEMPLATE!");
    // TODO: The proto is not parsed properly yet (we take everything)
        [#!ignore ->(:head)[['\n'|' '|'\t']* '{']] // horrible barbarian way
    ////////
        // Create a block to host the template node.
        #pushItem(theBlock.block)
        => local lastNode;
        #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
        // Create a rtxTPL node.
        // The c_block var will reference the block of chunks/C code
        => local c_block;
        #check(rtxNodeTpl(lastNode, head, c_block))
        => traceLine("tplproto :" + head + " next:" + peekChar());
        =>traceLine("Chunks!");
        [
            // Theoretically, the template should only contain chunks...
            rtx_declaration(c_block)
        ]*
    '}'
;

/////// WITH
rtx_stmt_with_map(theMap : node) ::=
    #readIdentifier:sKey '=' [#readIdentifier|#readInteger]:sVal
    => insert theMap[sKey] = sVal;
;
rtx_stmt_with(theMap: node) ::=
    rtx_stmt_with_map(theMap) [',' rtx_stmt_with_map(theMap)]*
;
rtx_stmt<"with">(theBlock : node) ::=
    => traceLine("WITH");
    // create a block to host the with node
    #pushItem(theBlock.block)
    => local lastNode;
    #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
    // link to the variable mapping
    => local var_map;
    => local body;
    #check(rtxNodeWith(lastNode, var_map, body))
    // variables of the with node
    rtx_stmt_with(var_map)
    // block of the with node
    '{'
        [
            //#check(cnormNodeCtx(body))
            rtx_declaration(body)
        ]*
    '}'
;

//////// CHUNK
// The pointcut's identifier may be scoped with some interfaces' names.
rtx_stmt_chunk_scoped_identifier(sPointCut : reference) ::=
    => local string = "";
    [
        #readIdentifier:sSubSystem
        "::" parsing de
        => string += sSubSystem + "::";
    ]*
    #readIdentifier:sUnscopedPointcut
    => string += sUnscopedPointcut;
    => ref sPointCut = string;
;
// If there is any parameters to the chunk, we push it into a param list
rtx_stmt_chunk_params(theParams : node) ::=
    '('
    => local parameters;
    #readIdentifier:sSymbol
    #pushItem(parameters)
    => parameters#back = sSymbol;
    [
        ','
        #readIdentifier:sSymbol
        #pushItem(parameters)
        => parameters#back = sSymbol;
    ]*
    ')'
;
rtx_stmt<"chunk">(theBlock : node) ::=
    =>traceLine("CHUNK");
    // Create an item in the Block list to host the chunk
    #pushItem(theBlock.block)
    => local lastNode;
    #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
    => local sPointCut;
    rtx_stmt_chunk_scoped_identifier(sPointCut)
    // Optional Joinpoint (argument of the pointcut)
    => local parameters;
    => local body;
    // Build the chunk node, and retrieve the references to it's internals
    // (body and parameters)
    #check(rtxNodeChunk(lastNode, sPointCut, parameters, body))
    [
        rtx_stmt_chunk_params(parameters)
    ]?
    '{'
        block_item_list(body)
    '}'
;


// Don't care... for now...
rtx_template_code ::= #!ignore "${" -> '}' 
;

/*
 * This rule overload allows the template identifier concatenation
 * for Rathaxes.
 */
#overload
rootidentifier ::= #!ignore
    [ 'a'..'z' | 'A'..'Z' | '_' | rtx_template_code:code ]
    [ 'a'..'z' | 'A'..'Z' | '0'..'9' | '_' | rtx_template_code ]*
;

