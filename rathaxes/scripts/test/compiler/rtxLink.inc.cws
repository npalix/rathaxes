#if !existFunction(rtxLink_version)

function rtxLink_version()
{return "1.0";}




/******************************************************************************/
/*                                                                            */
/*                      TOOL FUNCTIONS TO MANIPULATE THE CACHE                */
/*                                                                            */
/******************************************************************************/

// wrapper/faker for the template prototype hashing function (future)
function hashTemplatePrototype(prototype_node : node, out_ref_hash : reference)
{
    out_ref_hash = prototype_node;
}

/*
 * This function checks the conditions of the with block against a configuration
 * block. It returns true if the with block is in the definition domain of the
 * configuration
 */
function rtxLink_IsWithNodeCompatible(with : node, config : node)
{
    // For now, let's assume the with nodes are compatible
    return true;
}


/*
 * This function checks if at least one template exists within the cache
 * for a given template prototype and with/config block.
 */
function rtxLink_HasCompatibleTpl(proto_hash : value, with_values : node)
{
    if (findElement(proto_hash, this.session.templates))
    {
        foreach tpl in this.session.templates[proto_hash]
        {
            if (rtxLink_IsWithNodeCompatible(tpl, with_values))
                return true;
        }
        return false;
    }
    return false;
}


/*
 * This function checks if the template already exists within the cache
 * by EXACTLY matching the two with block
 */
function rtxLink_CheckSingleTpl(proto_hash : value, with_values : node)
{
    if (findElement(proto_hash, this.session.templates))
    {
        foreach tpl in this.session.templates[proto_hash]
        {
            if (equalTrees(tpl.with, with_values))
                return true;
        }
        return false;
    }
    return false;
}


/*
 * This function loads the tree and the script for a given cache node.
 * and next loads the tree file into a tree ref.
 */
function rtxLink_LoadScript(cache_node : node, out_ref_tree : reference)
{
    if (!existVariable(cache_node.script_file)
        || !existVariable(cache_node.tree_file))
        error("rtxLink:<ERROR> The node does not contain any script to load!");

    traceLine("rtxLink:<LOG> LOADING Script '" + cache_node.script_file + "'");
    try {
        extendExecutedScript(loadFile(cache_node.script_file));
    }
    catch (sError) {
        traceLine("rtxLink:<ERROR> Could not load resolution script : "+sError);
        return false;
    }

    cwLoadProject(cache_node.tree_file, out_ref_tree);

    traceLine("rtxLink:<LOG> Resolution script and tree loaded.");
    return true;
}


/*
 * This function returns the first global_code cache node found matching the
 * configuration block.
 */
function rtxLink_findGlobalCode(with_values : node, out_code : node)
{
    if (!existVariable(this.session))
        error("rtxLink:<ERROR> The cache was not loaded before use !");

    foreach item in this.session.global_code
    {
        if (rtxLink_IsWithNodeCompatible(item, with_values))
        {
            setall out_code = item;
            return true;
        }
    }
    return false;
}


/*
 * This function takes an array of template cache nodes and a configuration
 * block and tries to select only one template for the future resolution.
 */
function rtxLink_selectUniqueTemplate(templates : node, config : node)
{
    local keys_to_remove;
    // First find every non-compatible template.
    foreach tpl in templates
    {
        if (rtxLink_IsWithNodeCompatible(tpl, config) == false)
        {
            pushItem keys_to_remove;
            keys_to_remove#back = key(tpl);
        }
    }
    // Keep only the matching template(s) in the user's array
    foreach tpl in keys_to_remove
        removeElement(templates, tpl);

    // Check the number of results. 1 mean that only one template matches
    // the search : We're good, and change the array into a template node.
    // Otherwise, it's an error.
    if (getArraySize(templates) != 1)
        error("rtxLink:<ERROR> No unique template matching the configuration.");

    // Here, we find the associated chunk in order to set the script_file
    // And the tree_file, and set them into the tpl node in order to allow
    // A generic script function loading.
    local temp;
    setall temp = templates[0];
    foreach chunk in temp.chunks
    {
        if (key(chunk) == "CALL")
        {
            if (!findElement("CALL", this.session.chunks)
                || !findElement(chunk, this.session.chunks["CALL"]))
                error("rtxLink:<ERROR> The CALL chunk associated to the"
                      +" template could not be found within the cache.");

            insert temp.script_file =
                this.session.chunks["CALL"][chunk].script_file;
            insert temp.tree_file =
                this.session.chunks["CALL"][chunk].tree_file;
            setall templates = temp;
            return true;
        }
    }
    return false;
}

/*
 * This functino returns a collection of template cache nodes for a given
 * template prototype (hashed).
 */
function rtxLink_findTemplates(prototype : value, out_tpls : node)
{
    if (!existVariable(this.session))
        error("rtxLink:<ERROR> The cache was not loaded before use !");

    local hash;
    hashTemplatePrototype(prototype, hash);
    if (!findElement(hash, this.session.templates))
        return false;

    setall out_tpls = this.session.templates[hash];
    return true;
}


/*
 * This function reduces an array of chunk cache nodes by filtering them
 * with a given configuration block.
 */
function rtxLink_selectCompatibleChunks(chunks : node, config : node)
{
    local keys_to_remove;
    // First find every non-compatible template.
    foreach chunk in chunks
    {
        if (rtxLink_IsWithNodeCompatible(chunk, config) == false)
        {
            pushItem keys_to_remove;
            keys_to_remove#back = key(chunk);
        }
    }
    // Keep only the matching chunks in the user's array
    foreach chunk in keys_to_remove
        removeElement(chunks, chunk);

    // Check if there's any compatible chunk in the end...
    if (isEmpty(chunks) == false)
        return true;
    // Otherwise, it's an error (no compatible chunk).
    return false;
}

/*
 * This function returns an array of chunk cache nodes that are associated to
 * a given pointcut.
 */
function rtxLink_findChunks(pointcut_name : value, out_chunks : node)
{
    if (!existVariable(this.session))
        error("rtxLink:<ERROR> The cache was not loaded before use !");

    if (findElement(pointcut_name, this.session.chunks))
    {
        setall out_chunks = this.session.chunks[pointcut_name];
        return true;
    }
    return false;
}






/******************************************************************************/
/*                                                                            */
/*   FUNCTIONS FOR THE REGISTRATION OF WITH/TEMPLATES/CHUNKS INTO THE CACHE   */
/*                                                                            */
/******************************************************************************/

declare function rtxLink_SessionRegister<T>(local_node : node,
                                            with_values : node,
                                            script_file : value,
                                            out_ref_id : reference);
function rtxLink_SessionRegister<T>(local_node : node, with_values : node,
                                    script_file : value, out_ref_id : reference)
{
    error("rtxLink:<ERROR> Registration not implemented for node type "+T);
}

function rtxLink_SessionRegister<"__rtx_with__">(local_node : node,
                                                 with_values : node,
                                                 script_file : value,
                                                 out_ref_id : reference)
{
    // Register the c_block as global_code if it contains anything
    if (!isEmpty(local_node.c_block.block))
    {
        traceLine("rtxLink_SessionRegister<\"__rtx_with__\">:<LOG>"
                  +"Registering global code !");
        // First, check that the with global block is not already registered
        // But... is it even necessary ?
        

        // TODO FIXME XXX
        // For the time being, we insert as-is the var_map of the with
        // and its c_block.
        // We'll have to find the right way to associate some generated
        // code with it
        pushItem this.session.global_code;
        localref theNode = this.session.global_code#back;
        insert theNode.with;
        setall theNode.with = local_node.var_map;
        insert theNode.script_file = local_node.script_file;
        insert theNode.tree_file = local_node.tree_file;
    }

    // Then recurse to register every template.
    foreach item in local_node.body.block
    {
        rtxLink_SessionRegister<item.type>(item, local_node.var_map,
                                           script_file, out_ref_id);
    }
}

/*
 *
 * This function caches the template as follows :
 * session = [
 *      "template_hashed_prototype" = [
 *          "0" : {
 *              .with = with_node
 *              .chunks = [
 // Associate the pointcut with the id of the chunk in its cache part
 *                  "associated_pointcut" : chunk_id
 *              ]
 *          }
 *      ]
 * ]
 *
 */
function rtxLink_SessionRegister<"__rtx_tpl__">(local_node : node,
                                                with_values : node,
                                                script_file : value,
                                                out_ref_id : reference)
{
    local   hash;
    hashTemplatePrototype(local_node.prototype, hash);

    // First, check that the exact template/with_values does not already exist
    // within the cache
    if (rtxLink_CheckSingleTpl(hash, with_values))
        error("Template already present in session:" + local_node.prototype);

    traceLine("rtxLink_SessionRegister<\"__rtx_tpl__\">:<LOG>"
              +" registering template '"+local_node.prototype+"'");
    if (!findElement(hash, this.session.templates))
        insert this.session.templates[hash];
    
    localref cachedTpl = this.session.templates[hash];
    pushItem cachedTpl;
    ref cachedTpl = cachedTpl#back;

    insert cachedTpl.with;
    setall cachedTpl.with = with_values;

    insert cachedTpl.chunks;
    // Second, register each of its chunks into the cache, and keep
    // information on it inside the template's cached data.
    foreach chunk in local_node.body.block
    {
        local chunk_id = hash;
        rtxLink_SessionRegister<chunk.type>(chunk, with_values,
                                            key(chunk), chunk_id);
        insert cachedTpl.chunks[chunk.name] = chunk_id;
    }
}

/*
 *
 * This function caches the chunks as follows :
 * session = [
 *      "chunk_name1" : [       // pointcut to which the chunks are associated
 *          "0" : {             // This is a table of chunk entries
 *              .name = "string"
 *              .tpl_id = "hashed_template_prototype"
 *              .with = with_node
 *              .script_path = "path_to_script"
 *          }
 *      ]
 * ]
 *
 */
function rtxLink_SessionRegister<"__rtx_chunk__">(local_node : node,
                                                  with_values : node,
                                                  script_file : value,
                                                  out_ref_id : reference)
{
    local   prevSize;

    if (!findElement(local_node.name, this.session.chunks))
        insert this.session.chunks[local_node.name];

    traceLine("rtxLink_SessionRegister<\"__rtx_chunk__\">:<LOG>"
              +" Registering chunk for pointcut '"+local_node.name+"'");
    prevSize = getArraySize(this.session.chunks[local_node.name]);

    pushItem this.session.chunks[local_node.name];
    localref theChunk = this.session.chunks[local_node.name]#back;
    insert theChunk.name = local_node.name;
    insert theChunk.with = with_values;
    insert theChunk.tpl_id = out_ref_id;
    insert theChunk.script_file = local_node.script_file;
    insert theChunk.tree_file = local_node.tree_file;

    out_ref_id = prevSize;
}

// This function should be called with a root_block as local_node.
function rtxLink_SessionRegister<"__root_block__">(local_node : node,
                                                   with_values : node,
                                                   script_file : value,
                                                   out_ref_id : reference)
{
    if (!existVariable(this.session))
    {
        insert this.session;
        
        // The global_code field contains the code directly
        // associated with each with node.
        insert this.session.global_code;
        // the templates contains every template
        insert this.session.templates;
        // the chunks field contains information about chunks themselves :
        // template's ID, index in the template, associated with node.
        insert this.session.chunks;
    }

    try
    {
        foreach item in local_node.block
        {
            rtxLink_SessionRegister<item.type>(item, with_values,
                                               script_file, out_ref_id);
        }
    }
    catch(sError)
    {
        traceLine("Could not register the blocks into the session : "+sError);
        return false;
    }

    return true;
}


function rtxLink_RegisterToCache(local_node : node)
{
    local dummy;
    // The three last arguments are only used when registering
    // specific elements.
    if (rtxLink_SessionRegister<local_node.type>(local_node, dummy,
                                                 dummy, dummy) == false)
        return false;
    return true;
}


function rtxLink_InstallScripts(local_node : node)
{
    if (!rtxLink_RegisterToCache(local_node))
        return false;

    return true;
}

#end
