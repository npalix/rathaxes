/*
	TEST GENERAL DE TEMPLATE
*/

local working_directory = "__01_test";
if (existDirectory(working_directory))
{
    traceLine("Directory " + working_directory + " already exists");
    traceLine("Removing directory: " + working_directory);
}
traceLine("Creating directory: " + working_directory);
createDirectory(working_directory);
changeDirectory(working_directory);

local dummy;
local input;
generateString({

        with OS=pigeonMouette,maj=0,min=1
        {
            ${pointcut theTestPointcut(config.plop)
             default:
                 NULL;
            };
            template open(Context ctx)
            {
                chunk typedefs_declaration
                {
                    typedef int ${KK};
                    typedef int ${TYPE};
                    enum pop${ctx.name} {A, B, C};
                }

                chunk global_data_declaration
                {
                    ${TYPE} bla;
                }
    
                chunk function_declaration
                {
                    int    module_open(int a)
                    {
                        int    bal${KKK} = 13;
                        printf("COUCOU\n");
                        // Be careful, this is seen as a declaration :(
                        // It is a side effect of the default type int of C
                        ${ctx.name} = 42;
                        ${TOTO} += 3;
                        ${link ctx to test(Context ctx)};
                        return 0;
                    }
                }

                chunk LKM::init_fptrs(symbol)
                {
                    ${symbol.name}.open = &module_open;
                }
            }

            template test(Context ctx)
            {
                chunk function_declaration
                {
                    int test_${ctx.name}(void)
                    {
                        int ret = strcmp("open", param);
                        return ret;
                    }
                }

                chunk CALLS
                {
                    test_${ctx.name}();
                }
            }
        }

@}, dummy, input);

#include "cwTool.inc.cws"
#include "cnorm.inc.cws"
#include "cnorm2c/cnorm2c.inc.cws"
#include "patchLib/cnormPatchLib.inc.cws"


traceLine("input:\n" + input);

#include "rtxNode/rtxNode.inc.cws"

local source;
cnormDialect<"__std__">(source);
parseStringAsBNF("rtxParse/rtx.cwp", source, input);
// remove the dialect
removeVariable(source.dialect);

saveProject("__01_rtx_parse__.tree", source);
traceLine("====>Result of parsing: __01_rtx_parse__.tree :");
if (!isEmpty(source.error))
{
    local out = "\nAn error Occured while parsing :\nTrace:\n";
    foreach stack_line in source.error[0].trace
        out += stack_line;
    out += "\nError: " + source.error[0].msg;
    traceLine(out);
    exit(1);
}



#include "rtxTpl/rtxCompile.inc.cws"
foreach item in source.block
{
    traceLine("compiling item : "+key(item));
	rtxTpl_walk<item.type>(item);
}

traceLine("====>Result of placeHolder compilation : __02_rtx_compil__.tree");
saveProject("__02_rtx_compil__.tree", source);



// Walk through the AST in order to parse each placeholder
// and to save their AST into the .compile node.
#include "rtxTpl/rtxMeta.inc.cws"
foreach item in source.block
{
    rtxMeta_walk<item.type>(item);
}
traceLine("====>Result of placeHolder Analyse : __03_rtx_compil_tplnode__.tree");
saveProject("__03_rtx_compil_tplnode__.tree", source);


#include "rtxLink.inc.cws"
#include "rtxTpl/rtxGen.inc.cws"
#include "rtxTpl/rtxResolve.inc.cws"
// The generated code will need this :
// brutal foreach, we should work the tree properly in the end in order to
// manage properly the __rtx_with__ and __rtx_tpl__ nodes.
foreach item in source.block
{
	local uid = 0;
	rtxGen<item.type>(item, uid);
	uid = $uid + 1$;

}


// Load the two templates :
// First, hash the prototype, then find every template matching it,
// And finally reduce the selection to only one template before loading.
local theProto = "open(Context ctx)";
local theWith;
local theHash;
hashTemplatePrototype(theProto, theHash);
local theTemplates;
if (rtxLink_findTemplates(theHash, theTemplates) == false)
    error("01_test_back.cws: The template could not be found by rtxLink.");
if (rtxLink_selectUniqueTemplate(theTemplates, theWith) == false)
    error("01_test_back.cws: rtxLink could not select an unique template.");
traceLine("Loading template : open(Context ctx)...");
local theFile;
rtxLink_LoadScript(theTemplates, theFile);

// Now, try the C code generation out : simulate an input (the resVal node)
// And start the resolution of the placeHolders.
local resVals;
rtxNodeResVal(resVals);
insert resVals["KK"];
rtxNodeResValLeaf(resVals["KK"], "caca");
insert resVals["KKK"];
rtxNodeResValLeaf(resVals["KKK"], "_tri_k");
insert resVals["TOTO"];
rtxNodeResValLeaf(resVals["TOTO"], "(*grumf)->nia");
insert resVals["TYPE"];
rtxNodeResValLeaf(resVals["TYPE"], "t_theType");
insert resVals["ctx"];
rtxNodeResVal(resVals["ctx"]);
insert resVals["ctx"]["name"];
rtxNodeResValLeaf(resVals["ctx"]["name"], "theContextValue");
insert resVals["symbol"];
insert resVals["symbol"]["name"];
rtxNodeResValLeaf(resVals["symbol"]["name"], "global_init.open");

local c_tree1;
cwLoadProject(theFile, c_tree1);
instanceTpl<"open(Context ctx)">(resVals, c_tree1);
traceLine("INSTANCIATION DU TEMPLATE : open(Context ctx)");
//traceLine(cnorm2c(c_tree1));
traceLine("Template resolved.");

