/*
	TEST for template codeworker generation
*/

#include  "01_G_test_back_registerToCache.cws"

#include "rtxTpl/rtxResolve.inc.cws"

// Load the template :
// First, hash the prototype, then find every template matching it,
// And finally reduce the selection to only one template before loading.

// Build the rtype node for the template
local theRtype;
local name;
local params;
rtxNodeIdentifier(name, "open", "Userland");
rtxNodeRType(theRtype, name, params);
pushItem params;
rtxNodeIdentifier(params#back, "Context");

local theWith;
local theTemplates;

if (rtxLink_findTemplates(theRtype, theTemplates) == false)
    error("01_I_test_back_resolveCall.cws:"
          +" The template could not be found by rtxLink.");
traceLine("A list of " + getArraySize(theTemplates)
          + " templates was found matching the prototype '"
          + theProto + "'");

if (rtxLink_selectUniqueTemplate(theTemplates, theWith) == false)
    error("01_I_test_back_resolveCall.cws:"
          +" rtxLink could not select an unique template :"+toString(theTemplates, true));
traceLine("An Unique template could be identified for resolution.");

local theChunk;
if (rtxLink_selectChunkFromTemplate(theTemplates, "::CALL", theChunk) == false)
    error("01_I_test_back_resolveCall.cws:"
          +" rtxLink could not find a '::CALL' chunk in template "
          +rtxRTypeName<theRtype.type>(theRtype));
traceLine("The chunk '::CALL' was found for the template.");

traceLine("Loading template : Userland::open(Context ctx)...");
local c_tree;
if (rtxLink_LoadScript(theChunk, c_tree) == false)
    error("01_I_test_back_resolveCall.cws: Could not load script for chunk"
          + " 'CALL' for template "+rtxRTypeName<theRtype.type>(theRtype));

traceLine("====>Codeworker Script and tree Loaded with success.");

// Now, try the C code generation out : simulate an input (the resVal node)
// And start the resolution of the placeHolders.
local resVals;
rtxNodeResVal(resVals);
insert resVals["config"];
rtxNodeResVal(resVals["config"]);
insert resVals["config"]["OS"];
rtxNodeResValLeaf(resVals["config"]["OS"], "Linux");
insert resVals["KK"];
rtxNodeResValLeaf(resVals["KK"], "caca");
insert resVals["KKK"];
rtxNodeResValLeaf(resVals["KKK"], "_tri_k");
insert resVals["TOTO"];
rtxNodeResValLeaf(resVals["TOTO"], "(*grumf)->nia");
insert resVals["TYPE"];
rtxNodeResValLeaf(resVals["TYPE"], "t_theType");
insert resVals["ctx"];
rtxNodeResVal(resVals["ctx"]);
insert resVals["ctx"]["name"];
rtxNodeResValLeaf(resVals["ctx"]["name"], "theContextValue");
insert resVals["symbol"];
insert resVals["symbol"]["name"];
rtxNodeResValLeaf(resVals["symbol"]["name"], "global_init.open");

instanceTpl<c_tree.instanceKey>(resVals, c_tree.body);
traceLine("INSTANCIATING TEMPLATE[CALL]: open(Context ctx)");
traceLine("Template resolved : The call will be replaced by :"
          + cnorm2c(c_tree.body));
