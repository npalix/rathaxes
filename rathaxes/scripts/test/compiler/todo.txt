Tests Backend :
 * Derouler la boucle de foreach du codeworker généré.                  <= DONE

 * Fouiller du côté du link afin de :                                   <= DONE
   * Designer une API pour rtxLink (registering, retrieving, etc)       <= DONE
   * Faker un cache pour rtxLink                                        <= DONE

 * Tester l'evaluation de templates qui s'appellent pour :              <= DONE
   * Resoudre les templates imbriqués avec les fonctions inject etc...  <= DONE
   * Commencer à tisser les bouts d'ast entre eux                       <= DONE

 * Ameliorer le tissage des AST                                         <= DONE
   * En plus de stocker les ref_placeholders dans le tplwalk, stocker : <= DONE
     * index du block                                                   <= DONE

   * Permet de mieux weave par la suite :                               <= DONE
     * Creer un set de fonctions d'injection de templates.              <= DONE
     * identifier le contenu du template et categoriser par type :      <= DONE
       * integrer les calls in-place                                    <= DONE
        -> insert chaque stmt in-place du placeholder original          <= DONE
       * integrer les definitions de fonctions dans le scope global     <= DONE

 * Fix Iteration pour le rtxMeta (build_compile_tree a rename)          <= DONE

 * Ajouter les éléments de programmation aspectuelle dans le backend.   <= DONE
   * Ajouter le pointcut                                                <= DONE
     * Ajouter le parsing du pointcut dans le with (rtxBack)            <= DONE
     * Ajouter le parsing du pointcut (rtxMeta)                         <= DONE
     * Ajouter le parsing du pointcut default (rtxMeta)                 <= DONE
     * Ajouter la génération du code pour les pointcut                  <= DONE
     * Ajouter la génération du code pour les pointcut default          <= DONE
     * Ajouter la gestion des paramètres du pointcut                    <= DONE
     * Creer une fonction de résolution depuis un pointcut              <= DONE
     * Créer un test pour la résolution d'un pointcut par defaut        <= DONE
     * Créer un test pour la résolution d'un pointcut avec chunks       <= DONE
   * Creer la syntaxe pour le chunk                                     <= DONE
     * Ajouter le parsing des chunks                                    <= DONE
     * Update le cache pour pouvoir chercher des chunks                 <= DONE
     * Creer des fonctions de résolution des chunks                     <= DONE
     * Créer une fonction de résolution depuis un CALL                  <= DONE
     * Créer un test pour la resolution d'un CALL                       <= DONE
     * Deplacer le .compile des templates vers les chunks               <= DONE

 * Mettre a jour la syntaxe du with                                     <= DONE

 * Build une structure commune pour tous les prototypes de templates    <= DONE

 * Ajouter la gestion des pointcuts avec noms pleinement qualifiés      <= DONE
   * Preparer rtxGen, rtxLink et rtxResolve pour cette gestion          <= DONE
   * Inserer les full qualified names lors du type-checking             <= DONE
   * Gerer le cache uniquement avec du fully qualified                  <= DONE

 * Coder la fonction de match de configuration/with dans rtxLink        <= DONE
   * Coder les fonctions de normalisation de la config                  <= DONE
   * Le with doit être formaté lors du type-checking avec middle-end    <= DONE
   * Coder la fonction de comparaison config/with                       <= DONE
   * Ajouter un test de validation                                      <= DONE

 * Ajouter le Type-checking vs interfaces une fois le middle-end ok     <= TODO
 
 * Gestion multi-placeholder (X en 1)                                   <= TODO 

 * Introspection du c_tree  : resolverValues "local".                   <= DONE

 * Empecher le cache de charger plusieurs fois le meme script           <= DONE

 * Ajouter la vérification des items utilisés dans les placeHolders     <= TODO

 * Mettre en place la génération de code pour les templates de type     <= TODO
   * Definir les prototypes des fonctions à générer pour le mapping     <= DONE
   * Mettre  en place un nouvel element dans le cache dedie au mapping  <= DONE
   * Coder les fonctions de mapping pour les builtins (local, config)   <= TODO
     * local: symbole du bloc C                                         <= DONE
     * local: error_label() -> generation d'un label unique pour erreur <= TODO
     * local: tmp() -> generation d'un identifiant unique dans le bloc  <= TODO
     * local: lookup(symbol) -> analyse prototype func pour recup types
                                a partir d'un index de parametre        <= TODO
   * Implémenter l'appel à des fonctions appliquées à un type (chunks)  <= DONE

 * Gestion d'erreur :                                                   <= TODO
   * implem le bloc on_error des chunks                                 <= TODO
     * Parsing                                                          <= TODO
     * Resolution                                                       <= TODO
     * Tissage                                                          <= TODO
       * Résoudre/Générer le label d'erreur                             <= TODO
       * inserer a la suite des instructions                            <= TODO
       * Inserer le on_error avant les on_error precedents              <= TODO
       * Inserer le label généré avant le on_error                      <= TODO

 * Mettre à jour les fonctions d'inject pour filer la  VRAIE config     <= DONE

 * Faire une passe de validation apres rtxMeta pour valider  le mapping
   ou non (placeHolders == "${self}" ?)                                 <= TODO

 * Mettre à jour les fonctions de tissage pour empecher l'insertion
   multiple d'un meme code (fonction, type definition, etc...)
   + remonter correctement ces éléments au tissage (ordre, etc...)      <= TODO

 * Ameliorer la comparaison "=" Des elements de config                  <= TODO

 * Coder les extend interface                                           <= TODO
 * Enregistrement des extensions d'itf: mieux gerer les conflits        <= TODO

 * Type Checking
    * Checker les tpl vs itf (tout existe bien ?)                       <= DONE
    * Checker les itf vs tpl (valide ?)                                 <= DONE
    * Ajouter l'appel au check BACK dans la compilation du backend      <= TODO
    * Checker l'existence des variables de config dans le with          <= TODO
    * Ajouter l'appel au check WITH dans la compilation                 <= TODO
    * Checker le front-end vs itf (tout existe ?)                       <= TODO
    * Checker l'itf vs le frontend (req/opt valides ?)                  <= TODO
    * Ajouter l'appel au check FRONT dans la compilation                <= TODO



 MANAGEMENT OF THE AST WEAVING :

 Currently three main cases of placeHolders :

 assimilated to __decl__::ctype::identifier -> Type declaration
    -> Must correctly replace the identifier and fill the type reference table.
 assimilated to __stmt__(__expr__)::left/right::id -> assignation of a value
    -> Must simply replace the identifier by the right value.
 assimilated to __stmt__(__expr__)::id -> simple expression
    -> Must update the type reference table of the calling tpl with the
       called's one.
    -> Must weave ASTs correctly and structurally correct.







 USE CASES AND COMPILATION STEPS :

1) Rathaxes maintainer (.rti <=> Interfaces)
  * Parsing
  * Type and dependencies checking
  * Registration

2) System developer (.blt <=> Templates)
  * Parsing
  * Prototype Typechecking (prototypes vs interfaces)
  * Placeholders Extraction (every "${ ... }")
  * Placeholders Parsing
  * C code introspection (building the "local" template variable)
  * Body Typechecking (validity of the template variables use)
  * Registration

3) Driver developer (.rtx <=> Drivers)
  * Parsing
  * Dynamic Parsing (with interfaces)
  * Template selection (with Configuration)
  * Template instanciation and resolution (recursive)
     * Building "ResolverValues" (mapping for the template variables)
     * Resolve Placeholders
     * Weave ASTs for recursive cases ("link" and "each" keywords)
  * Generation :
    * Generation du code global aux with (voir pointcuts du with LKM)
      * Mécanisme de generation auto pour les sequences telles que LKM::load
      * Descente récursive dans les chunks liés pour résoudre les pointcuts
        (ils ont acces aux types donnés en parametres au template associé)
    * Generation des séquences provided appellées depuis le front-end


    ====================================================

 * Coder des passes dans le middle end:
   1) Valider les prerequis front-end (required/optional/etc...)
   2) Routines pour valider les typages des appels de sequence
   3) Valider les pre-requis back-end (chunks, pointcut)
   4) Validation de l'implem backend # aux besoins du front.


 * Main routine:
   1) Parse front
   2) Chargement des interfaces utilisées par le front.
   3) Validation du front

   4) Instanciation de la configuration -> Start resolve

