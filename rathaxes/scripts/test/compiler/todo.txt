Tests Backend :
 * Derouler la boucle de foreach du codeworker généré.                  <= DONE

 * Fouiller du côté du link afin de :                                   <= DONE
   * Designer une API pour rtxLink (registering, retrieving, etc)       <= DONE
   * Faker un cache pour rtxLink                                        <= DONE

 * Tester l'evaluation de templates qui s'appellent pour :              <= DONE
   * Resoudre les templates imbriqués avec les fonctions inject etc...  <= DONE
   * Commencer à tisser les bouts d'ast entre eux                       <= DONE

 * Ameliorer le tissage des AST                                         <= DONE
   * En plus de stocker les ref_placeholders dans le tplwalk, stocker : <= DONE
     * index du block                                                   <= DONE

   * Permet de mieux weave par la suite :                               <= DONE
     * Creer un set de fonctions d'injection de templates.              <= DONE
     * identifier le contenu du template et categoriser par type :      <= DONE
       * integrer les calls in-place                                    <= DONE
        -> insert chaque stmt in-place du placeholder original          <= DONE
       * integrer les definitions de fonctions dans le scope global     <= DONE

 * Fix Iteration pour le rtxMeta (build_compile_tree a rename)          <= DONE

 * Ajouter les éléments de programmation aspectuelle dans le backend.   <= TODO
   * Creer la syntaxe pour le chunk                                     <= DONE
   * Changer la syntaxe de link en pointcut                             <= TODO
   * Creer des fonctions de résolution des chunks                       <= TODO
   * Update le cache pour pouvoir chercher des chunks                   <= TODO

 * Build une structure commune pour tous les prototypes de templates    <= TODO

 * Ajouter le Type-checking vs interfaces une fois le middle-end ok     <= TODO
 
 * Gestion multi-placeholder (X en 1)                                   <= TODO 

 * Introspection du c_tree  : resolverValues "local".                   <= TODO

 * Ajouter la vérification des items utilisés dans les placeHolders     <= TODO





 MANAGEMENT OF THE AST WEAVING :

 Currently three main cases of placeHolders :

 assimilated to __decl__::ctype::identifier -> Type declaration
    -> Must correctly replace the identifier and fill the type reference table.
 assimilated to __stmt__(__expr__)::left/right::id -> assignation of a value
    -> Must simply replace the identifier by the right value.
 assimilated to __stmt__(__expr__)::id -> simple expression
    -> Must update the type reference table of the calling tpl with the called's one.
    -> Must weave ASTs correctly and structurally correct.







 USE CASES AND COMPILATION STEPS :

1) Rathaxes maintainer (.rti <=> Interfaces)
  * Parsing
  * Type and dependencies checking
  * Registration

2) System developer (.blt <=> Templates)
  * Parsing
  * Prototype Typechecking (prototypes vs interfaces)
  * Placeholders Extraction (every "${ ... }")
  * Placeholders Parsing
  * C code introspection (building the "local" template variable)
  * Body Typechecking (validity of the template variables use)
  * Registration

3) Driver developer (.rtx <=> Drivers)
  * Parsing
  * Dynamic Parsing (with interfaces)
  * Template selection (with Configuration)
  * Template instanciation and resolution (recursive)
     * Building "ResolverValues" (mapping for the template variables)
     * Resolve Placeholders
     * Weave ASTs for recursive cases ("link" and "each" keywords)
  * Generation
