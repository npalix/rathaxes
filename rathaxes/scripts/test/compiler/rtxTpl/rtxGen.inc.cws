#if !existFunction(rtxGen_version)

function rtxGen_version()
{return "1.0";}


function	instanceTpl<T>(ast_context : node, c_tree : node)
{
	// grosso modo si ca c appel ya un pb de link
	error("BAD LINK - Unkown registry value:" + T);
}

declare function getField<T>(theNode : node, theField : reference);
function getField<T>(theNode : node, theField : reference)
{
    if (!existVariable(#evaluateVariable("theNode."+T)))
    {return false;}
    ref theField = #evaluateVariable("theNode."+T);
    return true;
}

function inject<"">(ctxNode:node, treeNode : node, tplNode:node)
{
    // we should NEVER fallback here.
    error("BAD NODE - Empty Template Node Type !");
    return false;
}

function    inject<sNodeType>(ctxNode : node, treeNode : node, tplNode : node)
{
    // we should NEVER fallback here.
    error("BAD NODE - Unknown Template Node Type : "+sNodeType);
}

function    inject<"__rtx_tpl_placeHolder__">(ctxNode : node, treeNode : node,
                                              tplNode : node)
{
    //traceLine("Injecting into placeHolder : "+toString(tplNode));
    inject<treeNode.body.type>(ctxNode, treeNode, tplNode.body);
}

function    inject<"__rtx_tpl_var__">(ctxNode : node, treeNode : node,
                                      tplNode : node)
{
    //traceLine("Injecting into var : "+toString(tplNode));
    localref curCtxNode = ctxNode;
    localref field = ctxNode;
    local fieldPath = "";
    local finalString = "";
    finalString = finalString + treeNode.prefix;
    foreach item in treeNode.body.body.block
    {
        if (fieldPath != "")
        {
            fieldPath += ".";
            if (!getField<item.name>(ctxNode, field))
                error("Inject Error : Wrong mapping between context and Template Nodes : No such node "+fieldPath+item.name);
            ref ctxNode = field;
        }
        fieldPath = fieldPath + item.name;
    }
    finalString = finalString + ctxNode;
    finalString = finalString + treeNode.sufix;
    treeNode#parent.ref_placeholder = finalString;
}

function    inject<"__rtx_tpl_link__">(ctxNode : node, treeNode : node,
                                       tplNode : node)
{
}


////////////////// la on genere du codeworker et on y croit :)
function	gencodeworker(tpl_node : node, uid : value)
{
	// on met la chaine de code PIC dans notre tpl_node pour etre accessible pendant la generation du code codeworker
	local sAstFile = "__05_rtx_codeworker_" + uid + ".tree";//pour l'instant en dur
	local sCwsFile = "__06_rtx_codeworker_" + uid + ".cws";//pour l'instant en dur
	//saveToFile(sAstFile, workaround.code_pic);
	saveProject(sAstFile, tpl_node.body);
	insert tpl_node.save_ast = sAstFile;
	insert tpl_node.save_cws = sCwsFile;
	local	source_codeworker;
	generateString({


		// auto generated codeworker DO NOT EDIT
		// ici une version specialiser de l'instanceTPL .... on met this.prototype mets a terme generer des UID c'est mieux
		function	instanceTpl<"@this.prototype@">(ast_context : node, c_tree : node)
		{
			local tree;
			cwLoadProject("@this.save_ast@", tree);

			// on resauve pour une comparaison a froid
			saveProject("@this.save_ast@2", tree);
	
			// ici ca doit etre generer
			// execution de ${} et mapping dans les _1,_2,_3,_4
			foreach injectpoint in tree.compile
			{
				traceLine("inject for " + injectpoint.template_expr);
                // cas d'injection de base sur la value de la variable de la BLT
				if (injectpoint.template_expr == "${TYPE}")
				{	injectpoint.ref_placeholder = "JE_SUIS_MOCHE";}
				// cas d'injection par la valeur du placeholder
                else if (injectpoint.key() == "_1")
				{	injectpoint.ref_placeholder = "GROSSE_TATA";}
				// injection d'une expression
                else if (injectpoint.key() == "_7")
				{	
					local new_code;	
					cnormPatchExpression(new_code, "(*grumf)->nia");
					setall injectpoint.ref_placeholder#parent = new_code;
				}
                else
                {
                    // injecting a variable from the front-end
                    inject<injectpoint.node.type>(ast_context, injectpoint.node,
                                             injectpoint.node);
                }
			}

			// on resauve pour une comparaison a froid
			saveProject("@this.save_ast@3", tree);

			// on crache juste le code template
			traceLine("INSTANCIATION DU TEMPLATE");
			traceLine(cnorm2c(tree));
            //traceLine("^^^^^^^^^^^^^^\n==============\nvvvvvvvvvvvvvv");
            // Here, weave the ASTs, but take care of using the right things
            // (stmt for an expression, etc)
            
			//traceLine(cnorm2c(ast_context));
		}

	@}, tpl_node, source_codeworker);

	// on considere qu'il n'y a qu'un template donc
	saveToFile(tpl_node.save_cws, source_codeworker);
}

/////////////////////////// FONCTIONS DE PARCOURS POUR LA GENERATION DE CODE CODEWORKER
function	rtxGen<T>(local_node : node, uid : node)
{
	error("unknown type for generation:" + T);
}

function	rtxGen<"__rtx_with__">(local_node : node, uid : node)
{
	traceLine("GEN WITH");
	rtxGen<local_node.body.type>(local_node.body, uid);
}

function	rtxGen<"__block__">(local_node : node, uid : node)
{
	traceLine("GEN BLOCK");
	foreach item in local_node.block
	{	
		rtxGen<item.type>(item, uid);
		uid = $uid + 1$;
	}

}

function	rtxGen<"__rtx_tpl__">(local_node : node, uid : node)
{
	traceLine("GEN TPL");
	// on sauve pour analyse a froit le node a generer
	saveProject("__04_rtx_gen_" + uid + ".tree", local_node);
	// racine de la generation des templates
	gencodeworker(local_node, uid);
	// on a tout generer on charge :P.... a terme delegue a RTX_LINK
	extendExecutedScript(loadFile(local_node.save_cws));
	
	// on l'appel ... ici en dur tout moche pour faire un test
    // Let's consider we already associated the ast_ctx with
    // the template for this test. Buid a fake front-end (call) node
    // and weave it with the template's node.
	local ast_ctx;
    local ctxbody;
    rtxNode(ast_ctx);
    cnormNodeStmt_Expr(ast_ctx, ctxbody);
    cnormNode_ToCall(ast_ctx, ctxbody);
    insert ast_ctx.name;
    ast_ctx.name = "open";
    localref openParam = ast_ctx;
    cnormNode_CallParam(ctxbody, openParam);
    cnormNodeDecl(openParam);
    cnormNodeDecl_SetName(openParam, "context");
    localref ctypeRef = ast_ctx;
    cnormNodeDecl_GetCtype(ast_ctx, ctypeRef);
    cnormNodeDecl_SetIdentifier(ctypeRef, "Context");
    
	local c_tree;
	instanceTpl<local_node.prototype>(ast_ctx, c_tree);
	uid = $uid + 1$;
}

#end
