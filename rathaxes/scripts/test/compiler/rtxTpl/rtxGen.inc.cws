#if !existFunction(rtxGen_version)

function rtxGen_version()
{return "1.0";}


function	instanceTpl<T>(ast_context : node, c_tree : node)
{
	// grosso modo si ca c appel ya un pb de link
	error("BAD LINK - Unkown registry value:" + T);
}

declare function getField<T>(theNode : node, theField : reference);
function getField<T>(theNode : node, theField : reference)
{
    if (!existVariable(#evaluateVariable("theNode."+T)))
    {return false;}
    ref theField = #evaluateVariable("theNode."+T);
    return true;
}

/*
 *
 * resolverValues -> the hash mapping of values used in the template
 * treeNode -> the root of the __rtx_tpl__ node
 * tplNode -> current node
 *
 */
function inject<"">(resolverValues : node, treeNode : node, tplNode : node)
{
    // we should NEVER fallback here.
    error("BAD NODE - Empty Template Node Type !");
    return false;
}

function    inject<sNodeType>(resolverValues : node, treeNode : node,
                                                     tplNode : node)
{
    // we should NEVER fallback here.
    error("BAD NODE - Unknown Template Node Type : "+sNodeType);
}

function    inject<"__rtx_tpl_placeHolder__">(resolverValues : node,
                                              treeNode : node,
                                              tplNode : node)
{
    //traceLine("Injecting into placeHolder : realType = "+treeNode.body.type);
    inject<treeNode.body.type>(resolverValues, treeNode, tplNode.body);
}

function    inject<"__rtx_tpl_var__">(resolverValues : node, treeNode : node,
                                      tplNode : node)
{
    //traceLine("Injecting into var : "+toString(tplNode));
    local curCtxNode;
    local fieldValue;
    local finalString = "";

    // First concat prefix
    finalString = finalString + treeNode.prefix;

    // Next resolve the value and concat it
    rtxNodeResVal_GetField(resolverValues, tplNode.identifiers, fieldValue);
    finalString = finalString + fieldValue;

    // Finally, concat suffix
    finalString = finalString + treeNode.sufix;

    treeNode#parent.ref_placeholder = finalString;
}

function    inject<"__rtx_tpl_link__">(resolverValues : node, treeNode : node,
                                       tplNode : node)
{
    traceLine("rtx_tpl_link not implemented yet...");
    return false;
}


////////////////// la on genere du codeworker et on y croit :)
///////////////// FUNCTIONS FOR GENERATING PLACE HOLDER SPECIFIC CODEWORKER
function    rtxGenPlaceHolder<T>(item : node, theKey : value)
{
    error("Unknown place holder type:"+T);
}

function    rtxGenPlaceHolder<"__rtx_tpl_var__">(item : node, theKey : value)
{
    insert item.cws_expr;
    insert item.key = theKey;
    generateString({
            // Resolving VALUE (place Holder @this.key@)
		    traceLine("inject for key @this.key@ : @this.template_expr@ (@this.node.type@)");
            inject<tree.compile["@this.key@"].node.type>(ast_context, tree.compile["@this.key@"].node,
                                                tree.compile["@this.key@"].node);
        @}, item, item.cws_expr);
    removeVariable(item.key);
    traceLine("Generated code : "+item.cws_expr);
}

function    rtxGenPlaceHolder<"__rtx_tpl_link__">(item : node, theKey : value)
{
    insert item.cws_expr;
    insert item.key = theKey;
    generateString({
            // Resolving LINK (place Holder @this.key@)
		    traceLine("inject for key @this.key@ : @this.template_expr@ (@this.node.type@)");
            inject<tree.compile["@this.key@"].node.type>(ast_context, tree.compile["@this.key@"].node,
                                                tree.compile["@this.key@"].node);
        @}, item, item.cws_expr);
    removeVariable(item.key);
    traceLine("Generated code : "+item.cws_expr);
}


function	gencodeworker(tpl_node : node, uid : value)
{
	// on met la chaine de code PIC dans notre tpl_node pour etre
    // accessible pendant la generation du code codeworker
	local sAstFile = "__05_rtx_codeworker_" + uid + ".tree";
	local sCwsFile = "__06_rtx_codeworker_" + uid + ".cws";
	//saveToFile(sAstFile, workaround.code_pic);
	saveProject(sAstFile, tpl_node.body);
	insert tpl_node.save_ast = sAstFile;
	insert tpl_node.save_cws = sCwsFile;


    // Here, we must iterate on each tpl_node's .compile to generate the bits
    // of codeworker matching each of these placeHolders.
    foreach item in tpl_node.body.compile
    {
        traceLine("GENERATING CWS For placeHolder "+key(item));
        rtxGenPlaceHolder<item.node.body.type>(item, key(item));
    }


	local	source_codeworker;
	generateString({


		// auto generated codeworker DO NOT EDIT
		// ici une version specialiser de l'instanceTPL ....
        // on met this.prototype mets a terme generer des UID c'est mieux
		function	instanceTpl<"@this.prototype@">(ast_context : node,
                                                    c_tree : node)
		{
			local tree;
			cwLoadProject("@this.save_ast@", tree);

			// on resauve pour une comparaison a froid
			saveProject("@this.save_ast@2", tree);
	
			// mapping data into placeholders :
            <%
            foreach item in this.body.compile
            { %>@item.cws_expr@<% }
            %>

			// on resauve pour une comparaison a froid
			saveProject("@this.save_ast@3", tree);

			// on crache juste le code template
			traceLine("INSTANCIATION DU TEMPLATE");
			traceLine(cnorm2c(tree));
			//traceLine("^^^^^^^^^^^^^^\n==============\nvvvvvvvvvvvvvv");
			// Here, weave the ASTs, but take care of using the right things
			// (stmt for an expression, etc)
			
			//traceLine(cnorm2c(ast_context));
		}

	@}, tpl_node, source_codeworker);

	// on considere qu'il n'y a qu'un template donc
	saveToFile(tpl_node.save_cws, source_codeworker);
}


/////////////////  FONCTIONS DE PARCOURS POUR LA GENERATION DE CODE CODEWORKER
function	rtxGen<T>(local_node : node, uid : node)
{
	error("unknown type for generation:" + T);
}

function	rtxGen<"__rtx_with__">(local_node : node, uid : node)
{
	traceLine("GEN WITH");
	rtxGen<local_node.body.type>(local_node.body, uid);
}

function	rtxGen<"__block__">(local_node : node, uid : node)
{
	traceLine("GEN BLOCK");
	foreach item in local_node.block
	{	
		rtxGen<item.type>(item, uid);
		uid = $uid + 1$;
	}

}

function	rtxGen<"__rtx_tpl__">(local_node : node, uid : node)
{
	traceLine("GEN TPL");
	// on sauve pour analyse a froit le node a generer
	saveProject("__04_rtx_gen_" + uid + ".tree", local_node);
	// racine de la generation des templates
	gencodeworker(local_node, uid);




    // NOW, Test the generation (simulate the C code generation from somewhere else) :)
    // So : load the generated script :)

	// on a tout generer on charge :P.... a terme delegue a RTX_LINK
	extendExecutedScript(loadFile(local_node.save_cws));
	




    // Now, try the C code generation out : simulate an input (the resVal node)
    // And start the resolution of the placeHolders.

    local resVals;
    rtxNodeResVal(resVals);
    insert resVals["KK"];
    rtxNodeResValLeaf(resVals["KK"], "caca");
    insert resVals["KKK"];
    rtxNodeResValLeaf(resVals["KKK"], "_tri_k");
    insert resVals["TOTO"];
    rtxNodeResValLeaf(resVals["TOTO"], "(*grumf)->nia");
    insert resVals["TYPE"];
    rtxNodeResValLeaf(resVals["TYPE"], "t_theType");
    insert resVals["ctx"];
    rtxNodeResVal(resVals["ctx"]);
    insert resVals["ctx"]["name"];
    rtxNodeResValLeaf(resVals["ctx"]["name"], "theContextValue");

    local c_tree;
    instanceTpl<local_node.prototype>(resVals, c_tree);
}

#end
