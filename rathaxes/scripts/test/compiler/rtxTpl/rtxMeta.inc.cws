#include "cnorm.inc.cws"

#include "rtxNode/rtxNode.inc.cws"

#if !existFunction(rtxMeta_version)

function rtxMeta_version()
{return "1.0";}

function    rtxMeta_parsePlaceHolder(compile : node)
{
    local treepart;
    cnormDialect<"__std__">(treepart);
    parseStringAsBNF({
        #include "cnorm.cwp"
        #include "rtxParse/rtxCommon.cwp"

        /*
         *
         * BNF rules for the placeHolders
         *
         */

        /*
         * Root of the placeHolder grammar :
         * We have to overload translation_unit since it is defined before
         * by cnorm.cwp which is included in order to
         * retrieve the rule single_statement
         */
        #overload
        translation_unit ::=
			#try
				#ignore
				#check(rtxNodePlaceHolder(this))
				[
                    rtx_tpl_pointcut(this)
                    |
					rtx_place_holder(this)
				]
				#continue(sError, "bad token at end of file, unexpected "
                          + peekChar())
				#empty
			#catch (sError)
				| #check(cnormLogError(this, sError))
		;

        rtx_place_holder(theNode : node) ::=
            [
                identifier:prefix
/**/            => theNode.prefix = prefix;
            ]?
            "${"
            [
                tpl_chunk_call(theNode.body)
            |
                rtx_composed_identifier(theNode.body)
            ]
            '}'
            [
                identifier:sufix
/**/            => theNode.sufix = sufix;
            ]?
            [ ";" ]?
        ;

        /*
         * Parse a chunk call (i.e. "${buf.init()}" )
         */

        tpl_chunk_call(theCall : node) ::=
/**/        => local parameters;
/**/        => local theVar;
/**/        => local theChunk;
            identifier:var_name
            #check(rtxNodeIdentifier(theVar, var_name))
            '.'
            rtx_scoped_identifier(theChunk)
            // For later resolution, we need to force it as an explicit global name
/**/        => theChunk.global = true;
            // Create the node from
            #check(rtxNodeCall(theCall, theVar, theChunk, parameters))
            '('
                #continue(sError, "Expected closing parenthesis in chunk call")
                [
                    rtx_var_list(parameters)
                ]?
            ')'
        ;


        /*
         * Functions used for the parsing of the pointcut
         */
        // TODO FIXME XXX : check that the partial C code is valid.
        tpl_pointcut_default(theNode : node) ::=
            "default" #continue(sError, "Expected ':' after poinctut's default statement.") ':' // originally '{'
/**/        => local body;
            #check(rtxNodePointcut_Default(theNode, body))
            #continue(sError, "Expected body for pointcut's default statement.")
            [
                single_statement(body)
                |
                #check(cnormNodeDecl_Init(body))
                initializer_list(body)
            ]
            // originally '}' identified the end of the block
        ;

        tpl_pointcut_parameters(theParams : node) ::=
            '(' rtx_var_list(theParams) ')'
        ;

        tpl_pointcut(thePointcut : node) ::=
            "pointcut"
/**/        =>local pointcutId;
/**/        => local theParams;
/**/        => local theDefault;
            #check(rtxNodePointcut(thePointcut, pointcutId,
                                   theParams, theDefault))
            #check(rtxNodeVarList(theParams))
            rtx_scoped_identifier(pointcutId)
            [ tpl_pointcut_parameters(theParams) ]?
            [ tpl_pointcut_default(theDefault) ]?
        ;

        rtx_tpl_pointcut(theNode : node) ::=
            "${" tpl_pointcut(theNode.body) '}' [ ';' ]?
        ;

    }, treepart, compile.template_expr);
    removeVariable(treepart.dialect);
    if (!isEmpty(treepart.error))
    {
        traceLine("_________\nCould not build node for template_expr : "
                  + compile.template_expr);
        local out = "Trace:\n";
        foreach stack_line in treepart.error[0].trace
            out += stack_line;
        out += "=>Error: " + treepart.error[0].msg;
        traceLine(out);
        return false;
    }
    traceLine("Just built node for template_expr : "+compile.template_expr);
    insert compile.node;
    setall compile.node = treepart;
}


/*
 *
 * The goal of this template function is to walk through the AST in order
 * to find and identify each template's ".compile" node. For each one,
 * each of their placeHolders is parsed and a placeHolder node is built.
 *
 */
declare function rtxMeta_walk<T>(local_node : node);

function rtxMeta_walk<T>(local_node : node)
{
    // Then we are on a type of node that doesnt matter to us
    // but that does not need any error...
}

function rtxMeta_walk<"__rtx_with__">(local_node : node)
{
    traceLine("rtxMeta_walk<\"__rtx_with__\">: walking through...");
    // First, walk the templates...
    foreach item in local_node.body.block
    {
        rtxMeta_walk<item.type>(item);
    }
    traceLine("rtxMeta_walk<\"__rtx_with__\">: parsing placeHolders...");
    // Second, compile each with placeHolder.
    foreach placeHolder in local_node.c_block.compile
    {
        rtxMeta_parsePlaceHolder(placeHolder);
    }
}

function rtxMeta_walk<"__rtx_chunk__">(local_node : node)
{
    traceLine("rtxMeta_walk<\"__rtx_chunk__\">: compiling placeHolders...");
    foreach placeHolder in local_node.body.compile
    {
        rtxMeta_parsePlaceHolder(placeHolder);
    }
}

function rtxMeta_walk<"__rtx_tpl__">(local_node : node)
{
    traceLine("rtxMeta_walk<\"__rtx_tpl__\">: walking through...");
    foreach chunk in local_node.body.block
    {
        rtxMeta_walk<chunk.type>(chunk);
    }
    if (rtxNodeTpl_HasMapping(local_node))
    {
        foreach mapping in local_node.mapping.body.block
        {
            foreach placeHolder in mapping.compile
            {
                rtxMeta_parsePlaceHolder(placeHolder);
            }
        }
    }
}

#end
