#include "cnorm.inc.cws"

#include "rtxNode.inc.cws"

#if !existFunction(rtxMeta_version)

function rtxMeta_version()
{return "1.0";}

function    rtxMeta_parsePlaceHolder(compile : node)
{
    local treepart;
    cnormDialect<"__std__">(treepart);
    parseStringAsBNF({
        #include "cnorm.cwp"

        /*
         *
         * BNF rules for the placeHolders
         *
         */

        /*
         * Root of the placeHolder grammar :
         * We have to overload translation_unit since it is defined before
         * by cnorm.cwp which is included in order to
         * retrieve the rule single_statement
         */
        #overload
        translation_unit ::=
/**/		=> traceLine("TEMPLATE EXPRESSION PARSE!");
			#try
				#ignore
				#check(rtxNodePlaceHolder(this))
				[
                    rtx_tpl_pointcut(this)
                    |
					rtx_place_holder(this)
				]
				#continue(sError, "bad token at end of file, unexpected "
                          + peekChar())
				#empty
			#catch (sError)
				| #check(cnormLogError(this, sError))
		;

        rtx_place_holder(theNode : node) ::=
            [
                identifier:prefix
/**/            => theNode.prefix = prefix;
            ]?
            "${"
            [
                tpl_link_expr(theNode.body)
            |
                tpl_identifier(theNode.body)
//          |
//              tpl_each_expr(theNode.body)
            ]
            '}'
            [
                identifier:sufix
/**/            => theNode.sufix = sufix;
            ]?
            [ ";" ]?
        ;

        rtx_tpl_pointcut(theNode : node) ::=
            "${" tpl_pointcut(theNode.body) '}' [ ';' ]?
        ;

        // This rule dissects an identifier in parts separated by dots.
        tpl_identifier(theNode : node) ::=
            identifier:varId
            // Create the node from 
            #check(rtxNodeVar(theNode, varId))
            [
                '.' identifier:tplField
                // add the field into the block
                #check(rtxNodeVar_AddIdentifier(theNode, tplField))
            ]*
        ;

        // Here we can identify a list of template variables
        tpl_var_list(theBlock : node) ::=
/**/        => local lastNode;
            tpl_identifier(lastNode)
            #check(rtxNodeList_AddNode(theBlock, lastNode))
            [
                ','
/**/            => local lastVar;
                tpl_identifier(lastVar)
                #check(rtxNodeList_AddNode(theBlock, lastVar))
            ]*
        ;

        // Here, a hard-coded test for a one-param function template
        tpl_type(theType : node) ::=
            "test(Context ctx)"
            #check(rtxNodeLinkType(theType, "test(Context ctx)"))
        ;

        tpl_link_expr(theLink : node) ::=
            "link"
/**/        => local theVars;
            #check(rtxNodeVarList(theVars))
            tpl_var_list(theVars)
            "to"
/**/        => local theType;
            tpl_type(theType)
            #check(rtxNodeLink(theLink, theVars, theType))
        ;

        tpl_pointcut_parameters(theParams : node) ::=
            '('
/**/        => local param;
            tpl_identifier(param)
            #check(rtxNodeList_AddNode(theParams, param))
            [
                ','
/**/            => local lastParam;
                tpl_identifier(lastParam)
                #check(rtxNodeList_AddNode(theParams, lastParam))
            ]*
            ')'
        ;

        // TODO FIXME XXX : check that the partial C code is valid.
        tpl_pointcut_default(theNode : node) ::=
            "default" ':' // originally '{'
/**/        => local body;
            #check(rtxNodePointcut_Default(theNode, body))
            single_statement(body)
            // originally '}' identified the end of the block
        ;

        tpl_pointcut(thePointcut : node) ::=
            "pointcut"
            #readIdentifier:sPointcut
/**/        => local theParams;
            #check(rtxNodeVarList(theParams))
            [ tpl_pointcut_parameters(theParams) ]?
/**/        => local theDefault;
            [ tpl_pointcut_default(theDefault) ]?
            #check(rtxNodePointcut(thePointcut, sPointcut,
                                   theParams, theDefault))
        ;

//      tpl_each_expr ::=
//      ;

    }, treepart, compile.template_expr);
    removeVariable(treepart.dialect);
    if (!isEmpty(treepart.error))
    {
        traceLine("_________\nCould not build node for template_expr : "
                  + compile.template_expr);
        local out = "Trace:\n";
        foreach stack_line in treepart.error[0].trace
            out += stack_line;
        out += "=>Error: " + treepart.error[0].msg;
        traceLine(out);
        return false;
    }
    traceLine("Just built node for template_expr : "+compile.template_expr);
    insert compile.node;
    setall compile.node = treepart;
}


/*
 *
 * The goal of this template function is to walk through the AST in order
 * to find and identify each template's ".compile" node. For each one,
 * each of their placeHolders is parsed and a placeHolder node is built.
 *
 */
declare function rtxMeta_walk<T>(local_node : node);

function rtxMeta_walk<T>(local_node : node)
{
    // Then we are on a type of node that doesnt matter to us
    // but that does not need any error...
}

function rtxMeta_walk<"__rtx_with__">(local_node : node)
{
    // First, walk the templates...
    foreach item in local_node.body.block
    {
        rtxMeta_walk<item.type>(item);
    }
    // Second, compile each with placeHolder.
    foreach placeHolder in local_node.c_block.compile
    {
        rtxMeta_parsePlaceHolder(placeHolder);
    }
}

function rtxMeta_walk<"__rtx_tpl__">(local_node : node)
{
    foreach placeHolder in local_node.body.compile
    {
        rtxMeta_parsePlaceHolder(placeHolder);
    }
}

#end
