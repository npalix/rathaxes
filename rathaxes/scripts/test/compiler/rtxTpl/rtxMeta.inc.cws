#include "rtxNode.inc.cws"

#if !existFunction(rtxMeta_version)

function rtxMeta_version()
{return "1.0";}

function    rtxMeta_parsePlaceHolder(compile : node)
{
    local treepart;
    parseStringAsBNF({

        #ignore ::=
        [
            ['#' ->[['\r']? '\n']]
            | ["//" ->[['\r']? '\n']]
            | ["/*" ->"*/"]
            | ' '
            | '\t'
            | '\n'
            | '\r'
            | '\f' // form feed, sometimes Windows kernel headers have this character.
        ]+:skip
        ;


        /*
         *
         * BNF rules for the placeHolders
         *
         */

        /* Root of the placeHolder grammar */
		template_expr ::=
			=> traceLine("TEMPLATE EXPRESSION PARSE!");
			#try
				#ignore
				#check(rtxNodePlaceHolder(this))
				[
					rtx_place_holder(this)
				]
				#continue(sError, "bad token at end of file, unexpected "
                          + peekChar())
				#empty
			#catch (sError)
				| #check(cnormLogError(this, sError))
		;

        rtx_place_holder(theNode : node) ::=
            [
                identifier:prefix
/**/            => theNode.prefix = prefix;
            ]?
            "${"
            [
                tpl_link_expr(theNode.body)
            |
                tpl_identifier(theNode.body)
//          |
//              tpl_each_expr(theNode.body)
            ]
            '}'
            [
                identifier:sufix
/**/            => theNode.sufix = sufix;
            ]?
            [ ";" ]?
        ;

        // This rule dissects an identifier in parts separated by dots.
        tpl_identifier(theNode : node) ::=
            identifier:varId
            // Create the node from 
            #check(rtxNodeVar(theNode, varId))
            [
                '.' identifier:tplField
                // add the field into the block
                #check(rtxNodeVar_AddIdentifier(theNode, tplField))
            ]*
        ;

        // Here we can identify a list of template variables
        tpl_var_list(theBlock : node) ::=
/**/        => local lastNode;
            tpl_identifier(lastNode)
            #check(rtxNodeList_AddNode(theBlock, lastNode))
            [
                ','
/**/            => local lastVar;
                tpl_identifier(lastVar)
                #check(rtxNodeList_AddNode(theBlock, lastVar))
            ]*
        ;

        // Here, a hard-coded test for a one-param function template
        tpl_type(theType : node) ::=
            "test(Context ctx) decl"
            #check(rtxNodeLinkType(theType, "test(Context ctx) decl"))
        ;

        tpl_link_expr(theLink : node) ::=
            "link"
/**/        => local theVars;
            #check(rtxNodeVarList(theVars))
            tpl_var_list(theVars)
            "to"
/**/        => local theType;
            tpl_type(theType)
            #check(rtxNodeLink(theLink, theVars, theType))
        ;

//      tpl_each_expr ::=
//      ;

        identifier ::=
                #readIdentifier
        ;

    }, treepart, compile.template_expr);
    traceLine("Just built node for template_expr : "+compile.template_expr);
    insert compile.node;
    setall compile.node = treepart;
}


/*
 *
 * The goal of this template function is to walk through the AST in order
 * to find and identify each template's ".compile" node. For each one,
 * each of their placeHolders is parsed and a placeHolder node is built.
 *
 */
declare function rtxMeta_walk<T>(local_node : node);

function rtxMeta_walk<T>(local_node : node)
{
    // Then we are on a type of node that doesnt matter to us
    // but that does not need any error...
}

function rtxMeta_walk<"__rtx_with__">(local_node : node)
{
    foreach item in local_node.body.block
    {
        rtxMeta_walk<item.type>(item);
    }
}

function rtxMeta_walk<"__rtx_tpl__">(local_node : node)
{
    foreach placeHolder in local_node.body.compile
    {
        rtxMeta_parsePlaceHolder(placeHolder);
    }
}

#end
