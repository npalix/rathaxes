#if !existFunction(rtxResolve_version)

function rtxResolve_version()
{ return "1.0"; }


/*
 *
 * Function that allow weaving ASTs by injecting the function definitions into
 * the global scopem and every other node in the block starting at the current
 * index.
 *
 * It is only used by a link resolution.
 *
 */
function    rtxResolve_InsertCode(destBlock : node, startIdx : value, phName : value, sourceNode : node)
{
    local sKey;
    local phIdx = 0;

    // First, remove the current placeHolder, in case there was no statement
    removeElement(destBlock, startIdx);
    // Here, we are at the root of the resolved template AST.
    foreach item in sourceNode.block
    {
        sKey = phName + "_" + phIdx;
        // If the node is a function definition, put it in global scope.
        if (cnormNode_checkIsFuncDefinition(item))
        {
            insertElementAt(destBlock#root.block, sKey, 0);
            setall destBlock#root.block#[0] = item;
        }
        // else, insert it where we are currently in the block.
        else
        {
            insertElementAt(destBlock, sKey, startIdx);
            setall destBlock#[startIdx] = item;
            startIdx = $startIdx + 1$;
        }
        phIdx = $phIdx + 1$;
    }
}



/*
 *
 * Functions to manipulate the "ResolverValues", a hashtree of
 * values to be used in the resolution of a template.
 *
 */


/*
 *
 * resolverValues -> the hash mapping of values used in the template
 * treeNode -> the root of the __rtx_tpl__ node
 * tplNode -> current node
 *
 */

function    inject<"">(resolverValues : node, treeNode : node, tplNode : node)
{
    // we should NEVER fallback here.
    error("BAD NODE - Empty Template Node Type !");
    return false;
}

function    inject<sNodeType>(resolverValues : node, treeNode : node,
                                                     tplNode : node)
{
    // we should NEVER fallback here.
    error("BAD NODE - Unknown Template Node Type : "+sNodeType);
}

function    inject<"__rtx_tpl_placeHolder__">(resolverValues : node,
                                              treeNode : node,
                                              tplNode : node)
{
    //traceLine("Injecting into placeHolder : realType = "+treeNode.body.type);
    inject<treeNode.body.type>(resolverValues, treeNode, tplNode.body);
}

function    inject<"__rtx_tpl_var__">(resolverValues : node, treeNode : node,
                                      tplNode : node)
{
    //traceLine("Injecting into var : "+toString(tplNode));
    local curCtxNode;
    local fieldValue;
    local finalString = "";

    // First concat prefix
    finalString = finalString + treeNode.prefix;

    // Next resolve the value and concat it
    rtxNodeResVal_GetField(resolverValues, tplNode.identifiers, fieldValue);
    finalString = finalString + fieldValue;

    // Finally, concat suffix
    finalString = finalString + treeNode.sufix;

    treeNode#parent.ref_placeholder = finalString;
}

function    inject<"__rtx_tpl_link__">(resolverValues : node, treeNode : node,
                                       tplNode : node)
{
    local config;
    local template;
    local tree_file;
    local tpl_c_tree;

    // Each of these functions can throw an error to notify failure.
    rtxLink_findTemplates(tplNode.linkedType.body, template);
    rtxLink_selectUniqueTemplate(template, config);
    rtxLink_LoadScript(template, tree_file);

    local resVals;
    // To actually resolve this, we need : 
    //  * Current resolverValues (OK)
    //  * The parameters in the linking template (OK)
    //  * sub-template parameters (XXX TODO FIXME)
    //
    // Thus is needed :
    //  * a more precise parsing of the template's type and parameters,
    //    both in the template type and in the link.
    //
    //rtxResolve_extractResVal(resolverValues, tplNode.vars, linkedTpl.params);
    insert resVals["ctx"];
    setall resVals["ctx"] = resolverValues["ctx"];

    cwLoadProject(tree_file, tpl_c_tree);
    instanceTpl<tplNode.linkedType.body>(resVals, tpl_c_tree);

    // Replace the node by the whole resolved c_tree
    //traceLine("Current placeholder :"
    //          +toString(treeNode#parent.ref_placeholder));
    //traceLine("Current resolved tree : "+toString(c_tree, true));
    //traceLine(cnorm2c(c_tree));
    traceLine("Resolved one link...");

    // placeHolder actually is : block.[idx].expr.id, so #parent * 3
    localref theBlock = treeNode#parent.ref_placeholder#parent#parent#parent;
    localref theLink = treeNode#parent;
    rtxResolve_InsertCode(theBlock, theLink.block_idx,
                          theLink.ref_placeholder, tpl_c_tree);

    return true;
}


#end
