#if !existFunction(rtxResolve_version)

function rtxResolve_version()
{ return "1.0"; }


/*
 *
 * Functions to manipulate the "ResolverValues", a hashtree of
 * values to be used in the resolution of a template.
 *
 */


/*
 *
 * resolverValues -> the hash mapping of values used in the template
 * treeNode -> the root of the __rtx_tpl__ node
 * tplNode -> current node
 *
 */

function    inject<"">(resolverValues : node, treeNode : node, tplNode : node)
{
    // we should NEVER fallback here.
    error("BAD NODE - Empty Template Node Type !");
    return false;
}

function    inject<sNodeType>(resolverValues : node, treeNode : node,
                                                     tplNode : node)
{
    // we should NEVER fallback here.
    error("BAD NODE - Unknown Template Node Type : "+sNodeType);
}

function    inject<"__rtx_tpl_placeHolder__">(resolverValues : node,
                                              treeNode : node,
                                              tplNode : node)
{
    //traceLine("Injecting into placeHolder : realType = "+treeNode.body.type);
    inject<treeNode.body.type>(resolverValues, treeNode, tplNode.body);
}

function    inject<"__rtx_tpl_var__">(resolverValues : node, treeNode : node,
                                      tplNode : node)
{
    //traceLine("Injecting into var : "+toString(tplNode));
    local curCtxNode;
    local fieldValue;
    local finalString = "";

    // First concat prefix
    finalString = finalString + treeNode.prefix;

    // Next resolve the value and concat it
    rtxNodeResVal_GetField(resolverValues, tplNode.identifiers, fieldValue);
    finalString = finalString + fieldValue;

    // Finally, concat suffix
    finalString = finalString + treeNode.sufix;

    treeNode#parent.ref_placeholder = finalString;
}

function    inject<"__rtx_tpl_link__">(resolverValues : node, treeNode : node,
                                       tplNode : node)
{
    local fakeWithNode;
    local tplID;

    if (rtxLink_GetIDFromTpl(tplNode.linkedType.body, fakeWithNode, tplID,
                             true) == false)   // True for fromSession
    {
        return false;
    }
    
    rtxLink_LoadTemplate(tplID, true);// true for fromSession

    local resVals;
    // To actually resolve this, we need : 
    //  * Current resolverValues (OK)
    //  * The parameters in the linking template (OK)
    //  * sub-template parameters (XXX TODO FIXME)
    //
    // Thus is needed :
    //  * a more precise parsing of the template's type and parameters,
    //    both in the template type and in the link.
    //
    //rtxResolve_extractResVal(resolverValues, tplNode.vars, linkedTpl.params);
    insert resVals["ctx"];
    setall resVals["ctx"] = resolverValues["ctx"];

    local c_tree;
    //declare function instanceTpl<T>(ast_context : node, c_tree : node);
    instanceTpl<tplNode.linkedType.body>(resVals, c_tree);

    // Replace the node by the whole resolved c_tree
    traceLine("Current placeholder :"+toString(treeNode#parent.ref_placeholder, true));
    traceLine("Current resolved tree : "+toString(c_tree, true));
    traceLine(cnorm2c(c_tree));
    setall treeNode#parent.ref_placeholder#parent = c_tree;

    return true;
}


#end
