with Ethernet, PCI, LKM, Log
{
    template type   Ethernet::ProtocolId()
    {
        chunk LKM::prototypes()
        {
            static const char   *rtx_ethernet_protocol_id_to_str(unsigned short);
        }

        chunk LKM::data()
        {
            static const struct
            {
                unsigned short  id;
                const char      *name;
            } rtx_ethernet_proto_table[] =
            {
                { ETH_P_IP,     "IPv4"  },
                { ETH_P_IPV6,   "IPv6"  },
                { ETH_P_ARP,    "ARP"   },
            };
        }

        chunk LKM::code()
        {
            static const char   *rtx_ethernet_protocol_id_to_str(unsigned short proto_id)
            {
                for (int i = 0;
                     i != sizeof(rtx_ethernet_proto_table) / sizeof(rtx_ethernet_proto_table[0]);
                     i++)
                    if (proto_id == rtx_ethernet_proto_table[i].id)
                        return rtx_ethernet_proto_table[i].name;

                return "Unknown";
            }
        }

        chunk decl()
        {
            typedef unsigned short  rtx_ether_protocol_id;
        }

        chunk to_str()
        {
            rtx_ethernet_protocol_id_to_str(${self});
        }

        map
        {
        }
    }

    template type   Ethernet::AbstractDevice()
    {
        chunk LKM::includes()
        {
            #include <linux/netdevice.h>
        }

        chunk ::decl()
        {
            typedef struct net_device *net_devp;
        }

        map
        {
        }
    }

    template type   Ethernet::Device()
    {
        chunk LKM::includes()
        {
            #include <linux/etherdevice.h>
        }

        chunk ::decl()
        {
            /*
             * So, at first sight, it sucks to typedef it as pointer but (for
             * now) it makes sense for two reasons:
             * - This structure will always be used through a pointer;
             * - This remove the ambiguity of pointer/not-pointer in the
             * ::init() chunk.
             */
            typedef struct rtx_ethernet_dev
            {
                /*
                 * I think it's useless to use the ${PCI::Device} "abstraction"
                 * here, since we already are in a Linux specific context.
                 */
                struct pci_dev          *pci_dev;
                struct net_device       *net_dev;

                /*
                 * In the long-term, this may disappear for a new concept allowing
                 * to embbed a descriptor defined and manipulated by the front-end
                 */
                ${pointcut Ethernet::SubContext()};
            } *rtx_ethernet_dev_p;
        }

        chunk ::init(Ethernet::AbstractDevice net_dev, PCI::Device pci_dev)
        {
            ${self} = netdev_priv(${net_dev});
            /*
             * We can use -> because we know that ${self} will be always a
             * pointer ("thanks" to the typedef)
             */
            ${self}->pci_dev = ${pci_dev};
            ${self}->net_dev = ${net_dev};
        }

        map
        {
        }
    }

    template sequence   Ethernet::open(Ethernet::Device dev)
    {
        chunk LKM::prototypes()
        {
            static int  rtx_ethernet_open(struct net_device *);
        }

        chunk LKM::code()
        {
            static int  rtx_ethernet_open(struct net_device *dev)
            {
                ${Ethernet::Device} rtx_ether_dev = netdev_priv(dev);

                ${pointcut ::IMPLEMENTATION(local.rtx_ether_dev)};

                return 0;
            }
        }
    }

    template sequence   Ethernet::send(Ethernet::Device dev, Socket::AbstractSKBuff skb)
    {
        chunk LKM::prototypes()
        {
            static int  rtx_ethernet_xmit(struct sk_buff* skb, struct net_device *dev);
        }

        chunk LKM::code()
        {
            static int  rtx_ethernet_xmit(struct sk_buff* kernel_skb, struct net_device *net_dev)
            {
                ${Ethernet::Device} rtx_ethernet_dev = netdev_priv(net_dev);
                ${cast local.kernel_skb as Socket::AbstractSKBuff};
                ${pointcut ::IMPLEMENTATION(local.rtx_ethernet_dev, local.kernel_skb)};
            }
        }
    }

    template sequence   Ethernet::close(Ethernet::Device dev)
    {
        chunk LKM::prototypes()
        {
            static int  rtx_ethernet_close(struct net_device *);
        }

        chunk LKM::code()
        {
            static int  rtx_ethernet_close(struct net_device *dev)
            {
                ${Ethernet::Device} rtx_ether_dev = netdev_priv(dev);

                ${pointcut ::IMPLEMENTATION(local.rtx_ether_dev)};

                return 0;
            }
        }
    }

    template sequence   Ethernet::interrupt_handler(Ethernet::Device dev)
    {
        /*
         * We can't use the irqreturn_t type here because CNornm doesn't know
         * it.
         */
        chunk LKM::prototypes()
        {
            static enum irqreturn   rtx_ethernet_interrupt_handler(int, void *);
        }

        chunk LKM::code()
        {
            static enum irqreturn   rtx_ethernet_interrupt_handler(int irq, void *dev_id)
            {
                ${Ethernet::Device} rtx_ether_dev = dev_id;

                ${pointcut ::IMPLEMENTATION(local.rtx_ether_dev)};

                return IRQ_NONE;
            }
        }
    }

    template sequence   Ethernet::init()
    {
        chunk LKM::data()
        {
            static const struct net_device_ops  rtx_ether_ops =
            {
                .ndo_open = rtx_ethernet_open,
                .ndo_stop = rtx_ethernet_close,
                .ndo_start_xmit = rtx_ethernet_xmit,
            };
        }

        /* For now the type is not handled, so we just omit it (see #17) */
        chunk PCI::pci_probe_hook(PCI::Device pdev)
        {
            /*
             * This typedef is needed to workaround a bug in CNorm __std__
             * dialect.
             */
            ${Ethernet::Device} rtx_ether_ctx;
            struct net_device *net_dev;
            int error;

            /* Initialize the net_device structure */
            net_dev = alloc_etherdev(sizeof(*rtx_ether_ctx));
            if (net_dev == 0)
            {
                ${Log::info("cannot allocate memory")};
                /*
                 * Again, the error should be "raised" in the parent context.
                 *
                 * Here we know that we can return ENOMEM because *we* wrote
                 * the parent context.
                 */
                return -ENOMEM;
            }
            SET_NETDEV_DEV(net_dev, &${pdev}->dev);
            strlcpy(net_dev->name, ${config.ifname}, sizeof(net_dev->name));
            net_dev->irq = ${pdev}->irq;
            net_dev->netdev_ops = &rtx_ether_ops;

            error = register_netdev(net_dev);
            if (error)
            {
                ${Log::info("cannot register the driver in the net subsystem")};
                return error;
            }

            /* Initialize our context held by the net_device structure */
            ${rtx_ether_ctx.init(local.net_dev, pdev)};

            pci_set_drvdata(${pdev}, net_dev);

            ${pointcut Ethernet::create_device(pdev, local.rtx_ether_ctx)};
        }

        /* This chunk should be removed (see #26) */
        chunk   ::CALL()
        {
        }
    }

    template sequence   Ethernet::exit()
    {
        chunk   PCI::pci_remove_hook(PCI::Device pdev)
        {
            /* workaround for cnorm unstrict */
            struct net_device *net_dev = pci_get_drvdata(${pdev});
            ${Ethernet::Device} rtx_ether_ctx = netdev_priv(net_dev);

            ${pointcut Ethernet::destroy_device(pdev, local.rtx_ether_ctx)};

            unregister_netdev(net_dev);
            free_netdev(net_dev);
        }

        /* This chunk should be removed (see #26) */
        chunk ::CALL()
        {
        }
    }
}

