with Ethernet, PCI, LKM, Log
{
    template type   Ethernet::Device()
    {
        chunk LKM::includes()
        {
            #include <linux/netdevice.h>
            #include <linux/etherdevice.h>
        }

        chunk ::decl()
        {
            struct rtx_ethernet_dev
            {
                /*
                 * I think it's useless to use the ${PCI::Device} "abstraction"
                 * here, since we are already in a Linux specific context here.
                 */
                struct pci_dev          *pci_dev;
                struct net_device       *net_dev;

                /* while waiting on issue #8 */
                struct rtx_e1000_ctx    hw_ctx;
            };
        }

        chunk ::init(net_dev)
        {
            ${self} = ${net_dev};
        }

        map
        {
        }
    }

    template sequence   Ethernet::open(Ethernet::Device dev)
    {
        chunk LKM::prototypes()
        {
            static int  rtx_ethernet_open(struct net_device *);
        }

        chunk LKM::code()
        {
            static int  rtx_ethernet_open(struct net_device *dev)
            {
                struct rtx_ethernet_dev* rtx_ether_dev =  netdev_priv(dev);
                struct rtx_e1000_ctx* ctx = &rtx_ether_dev->hw_ctx;

                ${pointcut ::IMPLEMENTATION};

                return 0;
            }
        }
    }

    template sequence   Ethernet::send(Ethernet::Device dev, Socket::SKBuff skb)
    {
        chunk LKM::prototypes()
        {
            static int  rtx_ethernet_xmit(struct sk_buff* skb, struct net_device *dev);
        }

        chunk LKM::code()
        {
            static int  rtx_ethernet_xmit(struct sk_buff* skb, struct net_device *dev)
            {
                ${pointcut ::IMPLEMENTATION};

                return 0;
            }
        }
    }

    template sequence   Ethernet::close(Ethernet::Device dev)
    {
        chunk LKM::prototypes()
        {
            static int  rtx_ethernet_close(struct net_device *);
        }

        chunk LKM::code()
        {
            static int  rtx_ethernet_close(struct net_device *dev)
            {
                struct rtx_ethernet_dev* rtx_ether_dev =  netdev_priv(dev);
                struct rtx_e1000_ctx* ctx = &rtx_ether_dev->hw_ctx;

                ${pointcut ::IMPLEMENTATION};

                return 0;
            }
        }
    }

    template sequence   Ethernet::interrupt_handler(Ethernet::Device dev)
    {
        /*
         * We can't use the irqreturn_t type here because CNornm doesn't know
         * it.
         */
        chunk LKM::prototypes()
        {
            static enum irqreturn   rtx_ethernet_interrupt_handler(int, void *);
        }

        chunk LKM::code()
        {
            static enum irqreturn   rtx_ethernet_interrupt_handler(int irq, void *dev_id)
            {
                struct rtx_ethernet_dev* rtx_ether_dev;
                struct rtx_e1000_ctx* ctx;

                rtx_ether_dev = dev_id;
                ctx = &rtx_ether_dev->hw_ctx;
                ${pointcut ::IMPLEMENTATION};

                return IRQ_NONE;
            }
        }
    }

    template sequence   Ethernet::init(PCI::Device pdev)
    {
        chunk LKM::data()
        {
            static const struct net_device_ops  rtx_ether_ops =
            {
                .ndo_open = rtx_ethernet_open,
                .ndo_stop = rtx_ethernet_close,
                .ndo_start_xmit = rtx_ethernet_xmit,
            };
        }

        chunk PCI::pci_probe_hook()
        {
            /*
             * This typedef is needed to workaround a bug in CNorm __std__
             * dialect.
             */
            typedef int ${Ethernet::Device};
            ${Ethernet::Device} *rtx_ether_ctx;
            struct net_device   *net_dev;
            int error;

            error = 0;
            net_dev = alloc_etherdev(sizeof(*rtx_ether_ctx));
            if (net_dev == 0)
            {
                ${Log::info("Cannot allocate memory")};
                /*
                 * Again, the error should be "raised" in the parent context.
                 *
                 * Here we know that we should return ENOMEM because *we* wrote
                 * the parent context.
                 */
                return -ENOMEM;
            }
            strlcpy(net_dev->name, ${config.ifname}, sizeof(net_dev->name));
            net_dev->irq = pdev->irq;
            // Maybe we should try ${rtx_ether_ctx.init()} here:
            rtx_ether_ctx = netdev_priv(net_dev);
            //rtx_ether_ctx->pci_dev = ${pdev};
            rtx_ether_ctx->pci_dev = pdev; // In the meantime do it directly
            rtx_ether_ctx->net_dev = net_dev;

            /*
             * The substitution of ${pdev} fails here. I also tried to add a
             * "substitute method" to the PCI::Device that was just doing
             * "${self}" but it didn't work either (it was subsituted by a
             * placeholder, e.g: _1).
             *
             * That's why we cheated a bit and named all the arguments pdev.
             */
            //SET_NETDEV_DEV(net_dev, &${pdev}->dev);
            SET_NETDEV_DEV(net_dev, &pdev->dev);
            net_dev->netdev_ops = &rtx_ether_ops;
            if ((error = register_netdev(net_dev)))
            {
                ${Log::info("Cannot register the driver")};
                return error;
            }

            /* same problem as above with ${pdev} */
            //pci_set_drvdata(${pdev}, net_dev);
            pci_set_drvdata(pdev, net_dev);

            ${pointcut Ethernet::create_device};
        }

        chunk   ::CALL
        {
        }
    }

    template sequence   Ethernet::exit(PCI::Device pdev)
    {
        chunk   PCI::pci_remove_hook()
        {
            struct net_device *net_dev = pci_get_drvdata(pdev);

            ${pointcut Ethernet::destroy_device};

            unregister_netdev(net_dev);
            /*
             * If we had some cleanup todo with struct rtx_ether_ctx we would
             * do a netdev_priv(net_dev) here and do it.
             */
            free_netdev(net_dev);
        }

        chunk ::CALL
        {
        }
    }
}

