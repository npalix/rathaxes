with e1000, Ethernet, Socket, PCI, LKM, Log
{
    template type   e1000::Context()
    {
        chunk   LKM::includes()
        {
            /*
             * Force the generation of the structure in the "headers" part, we
             * have to do this since we do not use the structure in this blt
             * (we hacked a bit and used it in ethernet.blt directly).
             */
            typedef int ${e1000::Context}; /* CNorm __std__ workaround */
            static const ${e1000::Context} force_struct_rtx_10000_ctx_decl;
        }

        chunk   ::decl()
        {
            struct rtx_e1000_ctx
            {
                int                             bars;
                unsigned char /* __iomem */     *ioaddr;
                int                             irq;
            };
        }

        chunk   ::init(bars, ioaddr)
        {
            ${self}.bars = ${bars};
            ${self}.ioaddr = ${ioaddr};
        }

        map
        {
        }
    }

    template type   e1000::Register()
    {
        chunk   LKM::includes()
        {
            typedef int ${e1000::Register};
            static const ${e1000::Register}  force_enum_rtx_e1000_registers_decl;
        }

        chunk   ::decl()
        {
            enum rtx_e1000_registers
            {
                E1000_CTRL          = 0x00000, /* Device Control - RW */
                E1000_CTRL_DUP      = 0x00004, /* Device Control Duplicate (Shadow) - RW */
                E1000_STATUS        = 0x00008, /* Device Status - RO */
                E1000_EEPROM_FLASH  = 0x00010, /* EEPROM/Flash Control - RW */
                E1000_EEPROM_READ   = 0x00014, /* EEPROM Read - RW */
                E1000_CTRL_EXT      = 0x00018, /* Extended Device Control - RW */
                E1000_FLA           = 0x0001C, /* Flash Access - RW */
                E1000_MDIC          = 0x00020, /* MDI Control - RW */
                E1000_IMS           = 0x000D0, /* Interrupt Mask Set */
                E1000_IMC           = 0x000D8, /* Interrupt Mask Clear */
                E1000_ICR           = 0x000C0  /* Interrupt Cause Read - R/clr */
            };
        }

        chunk   ::init(value)
        {
            ${self} = ${value};
        }

        map
        {
        }
    }

    template type   e1000::Commands()
    {
        chunk   LKM::includes()
        {
            typedef int ${e1000::Commands};
            static const ${e1000::Commands} force_enum_rtx_e1000_commands_decls;
        }

        chunk   ::decl()
        {
            enum rtx_e1000_commands
            {
                E1000_CMD_FD                    = 0x00000001, /* Full duplex.0=half; 1=full */
                E1000_CMD_BEM                   = 0x00000002, /* Endian Mode.0=little,1=big */
                E1000_CMD_PRIOR                 = 0x00000004, /* Priority on PCI. 0=rx,1=fair */
                E1000_CMD_GIO_MASTER_DISABLE    = 0x00000004, /* Blocks new Master requests */
                E1000_CMD_LRST                  = 0x00000008, /* Link reset. 0=normal,1=reset */
                E1000_CMD_TME                   = 0x00000010, /* Test mode. 0=normal,1=test */
                E1000_CMD_SLE                   = 0x00000020, /* Serial Link on 0=dis,1=en */
                E1000_CMD_ASDE                  = 0x00000020, /* Auto-speed detect enable */
                E1000_CMD_SLU                   = 0x00000040, /* Set link up (Force Link) */
                E1000_CMD_ILOS                  = 0x00000080, /* Invert Loss-Of Signal */
                E1000_CMD_SPD_SEL               = 0x00000300, /* Speed Select Mask */
                E1000_CMD_SPD_10                = 0x00000000, /* Force 10Mb */
                E1000_CMD_SPD_100               = 0x00000100, /* Force 100Mb */
                E1000_CMD_SPD_1000              = 0x00000200, /* Force 1Gb */
                E1000_CMD_BEM32                 = 0x00000400, /* Big Endian 32 mode */
                E1000_CMD_FRCSPD                = 0x00000800, /* Force Speed */
                E1000_CMD_FRCDPX                = 0x00001000, /* Force Duplex */
                E1000_CMD_D_UD_EN               = 0x00002000, /* Dock/Undock enable */
                E1000_CMD_D_UD_POLARITY         = 0x00004000, /* Defined polarity of Dock/Undock indication in SDP[0] */
                E1000_CMD_FORCE_PHY_RESET       = 0x00008000, /* Reset both PHY ports, through PHYRST_N pin */
                E1000_CMD_EXT_LINK_EN           = 0x00010000, /* enable link status from external LINK_0 and LINK_1 pins */
                E1000_CMD_SWDPIN0               = 0x00040000, /* SWDPIN 0 value */
                E1000_CMD_SWDPIN1               = 0x00080000, /* SWDPIN 1 value */
                E1000_CMD_SWDPIN2               = 0x00100000, /* SWDPIN 2 value */
                E1000_CMD_SWDPIN3               = 0x00200000, /* SWDPIN 3 value */
                E1000_CMD_SWDPIO0               = 0x00400000, /* SWDPIN 0 Input or output */
                E1000_CMD_SWDPIO1               = 0x00800000, /* SWDPIN 1 input or output */
                E1000_CMD_SWDPIO2               = 0x01000000, /* SWDPIN 2 input or output */
                E1000_CMD_SWDPIO3               = 0x02000000, /* SWDPIN 3 input or output */
                E1000_CMD_RST                   = 0x04000000, /* Global reset */
                E1000_CMD_RFCE                  = 0x08000000, /* Receive Flow Control enable */
                E1000_CMD_TFCE                  = 0x10000000, /* Transmit flow control enable */
                E1000_CMD_RTE                   = 0x20000000, /* Routing tag enable */
                E1000_CMD_VME                   = 0x40000000, /* IEEE VLAN mode enable */
                E1000_CMD_PHY_RST               = 0x80000000, /* PHY Reset */
                E1000_CMD_SW2FW_INT             = 0x02000000, /* Initiate an interrupt to manageability engine */
                E1000_INTR_TXDW                 = 0x00000001, /* Transmit desc written back */
                E1000_INTR_TXQE                 = 0x00000002, /* Transmit Queue empty */
                E1000_INTR_LSC                  = 0x00000004, /* Link Status Change */
                E1000_INTR_RXSEQ                = 0x00000008, /* rx sequence error */
                E1000_INTR_RXDMT0               = 0x00000010, /* rx desc min. threshold (0) */
                E1000_INTR_RXO                  = 0x00000040, /* rx overrun */
                E1000_INTR_RXT0                 = 0x00000080, /* rx timer intr (ring 0) */
                E1000_INTR_MDAC                 = 0x00000200  /* MDIO access complete */
            };
        }

        map
        {
        }
    }

    template sequence   e1000::create_device()
    {
        chunk Ethernet::create_device()
        {
            rtx_ether_ctx->hw_ctx.irq = pdev->irq;
            rtx_ether_ctx->hw_ctx.bars = pci_select_bars(pdev, IORESOURCE_MEM);
            if (pci_enable_device_mem(pdev))
            {
                ${Log::info("e1000::create: pci_enable_device_mem failed")};
            }

            if (pci_request_selected_regions(pdev, rtx_ether_ctx->hw_ctx.bars, ${config.name}))
            {
                ${Log::info("e1000::create: pci_request_selected_regions failed")};
            }

            if (${config.set_master})
            {
                pci_set_master(pdev);
            }

            /* 0 here is for BAR_0: */
            rtx_ether_ctx->hw_ctx.ioaddr = pci_ioremap_bar(pdev, 0);
            if (!rtx_ether_ctx->hw_ctx.ioaddr)
            {
                ${Log::info("e1000::create: pci_ioremap_bar failed")};
            }

            /* Reset the card */
            rtx_e1000_register_write32(&rtx_ether_ctx->hw_ctx, E1000_CTRL, E1000_CMD_RST);
            udelay(10);

            /* Now we can load its mac address */
            int i = 0;
            for (i = 0 /* < this is not generated! */; i < 3; ++i)
            {
                rtx_e1000_register_write32(&rtx_ether_ctx->hw_ctx, E1000_EEPROM_READ, (i << 8) | 1);

                int value;
                /* Should be a do { } while(); but the compiler doesn't do { } while(); yet. */
                value = rtx_e1000_register_read32(&rtx_ether_ctx->hw_ctx, E1000_EEPROM_READ);
                while ((value & (1 << 4)) == 0)
                    value = rtx_e1000_register_read32(&rtx_ether_ctx->hw_ctx, E1000_EEPROM_READ);
                value >>= 16;

                rtx_ether_ctx->net_dev->dev_addr[i * 2] = value & 0xff;
                rtx_ether_ctx->net_dev->dev_addr[i * 2 + 1] = (value >> 8) & 0xff;
            }

            memcpy(rtx_ether_ctx->net_dev->perm_addr,
                   rtx_ether_ctx->net_dev->dev_addr,
                   rtx_ether_ctx->net_dev->addr_len);

            { /* < mais lol. */
                ${Log::info("e1000::create: mac address loaded from the EEPROM")};
            }
        }

        chunk ::CALL
        {
        }
    }

    template sequence   e1000::destroy_device()
    {
        chunk   Ethernet::destroy_device
        {
            /*
             * Here, we should have some checks to avoid to free resources that
             * haven't been allocated. (e.g: in case of previous errors).
             */
            struct rtx_ethernet_dev* rtx_ether_ctx = netdev_priv(net_dev);
            iounmap(rtx_ether_ctx->hw_ctx.ioaddr);
            pci_release_selected_regions(pdev, rtx_ether_ctx->hw_ctx.bars);
        }

        chunk   ::CALL
        {
        }
    }

    template sequence   e1000::print_status()
    {
        chunk   LKM::prototypes()
        {
            static void rtx_e1000_print_status(struct rtx_e1000_ctx *);
        }

        chunk   LKM::code()
        {
            static void rtx_e1000_print_status(struct rtx_e1000_ctx *ctx)
            {
                unsigned int status = rtx_e1000_register_read32(ctx, E1000_STATUS);
                pr_info("rtx_e1000 status: \n");
                pr_info("\tRegister value: 0x%x\n", status);
                pr_info("\tMode: %s\n", (status & 1) ? "Full": "Half");
                pr_info("\tLink: %s\n", (status & 2) ? "Up" : "Down");
                pr_info("\tTransmission: %s\n", (status & 4) ? "Paused" : "Ok");
                pr_info("\tInterface: %s\n", (status & 3) == 3 ? "Up" : "Down");
            }
        }

        chunk   ::CALL
        {
        }
    }

    /*
     * We should have been able to do something along those lines, but
     * it didn't work so we made the call manually.
     *
     * Ideally:
     * ${e1000::register_read32(rtx_ether_ctx->hw_ctx, E1000_STATUS)};
     *
     * Ideally2, not sure about the syntax on the register parameter:
     * ${e1000::register_read32(rtx_ether_ctx->hw_ctx, ${e1000::Register.E1000_STATUS})};
     *
     * "Acceptable":
     * typedef int ${e1000::Register}; // cnorm __std__ workaround
     * ${e1000::Register} reg_status;
     * ${e1000.init(E1000_STATUS); // didn't work, so we used the next line
     * reg_status = E1000_STATUS;
     * ${e1000::register_read32(rtx_ether_ctx->hw_ctx, reg_status)};
     */
    template sequence   e1000::register_read32(e1000::Context ctx, e1000::Register reg_offset)
    {
        chunk   LKM::prototypes()
        {
            static unsigned int    rtx_e1000_register_read32(struct rtx_e1000_ctx *, unsigned int);
        }

        chunk   LKM::code()
        {
            static unsigned int    rtx_e1000_register_read32(struct rtx_e1000_ctx *ctx, unsigned int reg_offset)
            {
                return ioread32(ctx->ioaddr + reg_offset);
            }
        }

        chunk   ::CALL()
        {
            rtx_e1000_register_read32(&${ctx}, ${reg_offset});
        }
    }

    template sequence   e1000::register_write32(e1000::Context ctx, e1000::Register reg_offset, ::number value)
    {
        chunk   LKM::prototypes()
        {
            static void rtx_e1000_register_write32(struct rtx_e1000_ctx *, unsigned int, unsigned int);
        }

        chunk   LKM::code()
        {
            static void rtx_e1000_register_write32(struct rtx_e1000_ctx *ctx, unsigned int reg_offset, unsigned int value)
            {
                iowrite32(value, ctx->ioaddr + reg_offset);
            }
        }

        chunk   ::CALL()
        {
            rtx_e1000_register_write32(&${ctx}, ${reg_offset});
        }
    }

    template sequence   e1000::register_set32(e1000::Context ctx, e1000::Register reg_offset, ::number value)
    {
        chunk   LKM::prototypes()
        {
            static void rtx_e1000_register_set32(struct rtx_e1000_ctx *, unsigned int, unsigned int);
        }

        chunk   LKM::code()
        {
            static void rtx_e1000_register_set32(struct rtx_e1000_ctx *ctx, unsigned int reg_offset, unsigned int value)
            {
                iowrite32(rtx_e1000_register_read32(ctx, reg_offset) | value, ctx->ioaddr + reg_offset);
            }
        }

        chunk   ::CALL()
        {
        }
    }

    template sequence   e1000::setup_interrupt_handler()
    {
        chunk   LKM::includes()
        {
            #include <linux/interrupt.h>
        }
        chunk   LKM::prototypes()
        {
            static int e1000_setup_interrupt_handler(struct rtx_ethernet_dev *);
        }

        chunk   LKM::code()
        {
            static int e1000_setup_interrupt_handler(struct rtx_ethernet_dev *ethernet_ctx)
            {
                int error;

                error = request_irq(ethernet_ctx->hw_ctx.irq,
                        rtx_ethernet_interrupt_handler,
                        IRQF_SHARED,
                        ${config.name},
                        ethernet_ctx);

                if (error)
                {
                    ${Log::info("Cannot register the interruption")};
                }

                return error;
            }
        }

        chunk   ::CALL()
        {
            // this is an hack for the scope
            (void)1;
            {
                int error;
                error = e1000_setup_interrupt_handler(rtx_ether_dev);
                if (error)
                {
                    return error;
                }
            }
        }
    }

    template sequence   e1000::free_interrupt_handler()
    {
        chunk   LKM::prototypes()
        {
            static void e1000_free_interrupt_handler(struct rtx_ethernet_dev *ethernet_ctx);
        }

        chunk LKM::code()
        {
            static void e1000_free_interrupt_handler(struct rtx_ethernet_dev *ethernet_ctx)
            {

                free_irq(ethernet_ctx->hw_ctx.irq, ethernet_ctx);
            }
        }

        chunk ::CALL()
        {
            e1000_free_interrupt_handler(rtx_ether_dev);
        }
    }

    template sequence   e1000::activate_device_interruption()
    {
        chunk  ::CALL()
        {
            rtx_e1000_register_write32(ctx, E1000_IMS,
                                       E1000_INTR_TXDW |
                                       E1000_INTR_TXQE |
                                       E1000_INTR_LSC  |
                                       E1000_INTR_RXO  |
                                       E1000_INTR_RXT0);
        }
    }

    template sequence   e1000::set_up_device()
    {
        chunk  ::CALL()
        {
            rtx_e1000_register_set32(ctx, E1000_CTRL,
                                     E1000_CMD_ASDE |
                                     E1000_CMD_SLU  |
                                     E1000_CMD_LRST |
                                     E1000_CMD_PHY_RST);
        }
    }

    template sequence   e1000::handle_intr()
    {
        chunk   ::CALL()
        {
            int intr;

            intr = rtx_e1000_register_read32(ctx, E1000_ICR);
            if (intr & E1000_INTR_LSC)
            {
                ${Log::info("Link status changed")};
            }

            if (intr)
            {
                return IRQ_HANDLED;
            }
        }
    }
}
