/*
	TEST GENERAL DE TEMPLATE
*/

#include "cwTool.inc.cws"
#include "cnorm.inc.cws"
#include "cnorm2c/cnorm2c.inc.cws"

///////////////////// PARTIE BLT
local dummy;
local input;
generateString({

		template open(Context ctx) decl
		{
			typedef int ${KK};

			typedef int ${TYPE};
			
			enum pop${niania} {A, B, C};

			${TYPE} bla;

			int	open(int a)
			{
				int	bal${KKK} = 13;
				printf("COUCOU\n");
				// alors ATTENTION ceci est vue comme une decl :(... effet de bord de l'aspect "int par defaut"
				${BUGGY} = 42;
				${TOTO} += 3;
				return 0;
			}
		}

@}, dummy, input);

traceLine("input:\n" + input);

////////////////////
local source;
cnormDialect<"__std__">(source);
parseStringAsBNF({
			#include "cnorm.cwp"
		
		// PARTIE RTX_TREE
			function	rtxNode(local_node : node)
			{
				cnormNode(local_node);
				local_node.type = "__rtx_node__";
				return true;
			}

			function	rtxNodeTpl(local_node : node, input : value, out_ref_block : reference)
			{
				rtxNode(local_node);
				local_node.type = "__rtx_tpl__";
				insert local_node.tpl_type = "__decl__";
				// pour l'instant on met le proto comme string, mais faudra le compil aussi
				insert local_node.prototype = input;
				insert local_node.body;
				cnormNodeBlock(local_node.body);
				insert local_node.body.compile;
				insert local_node.body.compile.nbplaceholder = 0;
				ref out_ref_block = local_node.body;
				return true;
			}
		/////////////////////////////

		// RTX_PARSE

			/* root of grammar */
			#overload
			translation_unit ::=
				=> traceLine("PARSE!");
				#try
					#ignore
					#check(cnormNodeRoot(this))
					[
						#check(cnormNodeCtx(this))
						rtx_declaration(this)
					]*
					#continue(sError, "bad token at end of file, unexpected " + peekChar())
					#empty
				#catch (sError)
					| #check(cnormLogError(this, sError))
			;

			rtx_declaration(theBlock : node) ::=
				#readIdentifier:sStmt rtx_stmt<sStmt>(theBlock)
			;

			rtx_stmt<sKeyword>(theBlock : node) ::= 
				=> error("Unknown statement :" + sKeyword);
			;

			rtx_stmt<"template">(theBlock : node) ::=
				=>traceLine("TEMPLATE!");
				// TODO: on ne parse pas correctement le proto on prend tout
					[#!ignore ->(:head)[['\n'|' '|'\t']* '{']] // on est des boeufs
				////////
					// on cree un block pour heberger le code C
					#pushItem(theBlock.block)
					=> local lastNode;
					#check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
					// on cree un rtxTPL et c_block va reference le block de C
					=> local c_block;
					#check(rtxNodeTpl(lastNode, head, c_block))
					=> traceLine("chunk:" + head + " next:" + peekChar());
					=>traceLine("CODE C!");
					[
						#check(cnormNodeCtx(c_block))
						declaration(c_block)
					]*
				'}'
			;

			// on s'emmerde pas...pour l'instant :P
			rtx_template_code ::= "${" -> '}' 
			;
			
			/*
			 * This rule overload allows the template identifier concatenation
			 * for Rathaxes.
			 */
			#overload
			rootidentifier ::= #!ignore
			    [ 'a'..'z' | 'A'..'Z' | '_' | rtx_template_code ]
			    [ 'a'..'z' | 'A'..'Z' | '0'..'9' | '_' | rtx_template_code ]*
			;
		/////////////////////////////
}, source, input);
// enleve dialect
removeVariable(source.dialect);

traceLine("result of parsing:" + toString(source));
saveProject("__rtx_parse__.tree", source);

////////////// PARTIE RTX_TPL

declare function	rtxTpl_walk<T>(local_node : node);
declare function	rtxTpl_compile(local_node : node, out : node);


function	rtxTpl_walk<T>(local_node : node)
{
	error("Unknown rtx_node :" + T);
}

function	rtxTpl_walk<"__rtx_tpl__">(local_node : node)
{
	traceLine("walk on " + local_node.prototype);
	rtxTpl_compile<local_node.body.type>(local_node.body, local_node.body.compile);
}

////////
// fonctions outils pour trouver les placeHolders

function	rtxTpl_havePlaceHolder(ref_node : reference)
{
	traceLine("havePH?:" + ref_node);
	return (findString(ref_node, "${") != -1);
}

function	rtxTpl_mapPlaceHolder(ref_node : reference, compile : node)
{
	compile.nbplaceholder = $compile.nbplaceholder + 1$;
	local sKey = "_" + compile.nbplaceholder;
	insert compile[sKey].ref_placeholder;
	ref compile[sKey].ref_placeholder = ref_node;
	insert compile[sKey].template_expr = compile[sKey].ref_placeholder;
	compile[sKey].ref_placeholder = sKey;
	// TODO: ici il faudrait parser le contenu de template_expr et le preparer pour la generation de codeworker
}

////////

declare function	rtxTpl_compile<T>(local_node : node, compile : node);

function	rtxTpl_compile<"__decl__">(local_node : node, compile : node)
{
	traceLine("COMPILE DECL");
	// walk le ctype
	localref ctype_ref = local_node.ctype;
	do
	{
		// nom d'un type
		if (existVariable(ctype_ref.identifier) && rtxTpl_havePlaceHolder(ctype_ref.identifier))
		{
			traceLine("MAP PLACE HOLDER:" + toString(ctype_ref.identifier));
			rtxTpl_mapPlaceHolder(ctype_ref.identifier, compile);
		}
		// recurs param list
		//...
		// recurs fields list
		//...
		if (!existVariable(ctype_ref.pointer))
		{break;}
		// deref
		ref ctype_ref = ctype_ref.pointer;
	} while(true);
	// nom de variable
	if (existVariable(local_node.name) && rtxTpl_havePlaceHolder(local_node.name))
	{
		traceLine("MAP PLACE HOLDER:" + toString(local_node.name));
		rtxTpl_mapPlaceHolder(local_node.name, compile);
	}
	// recurs sur code de fonction
	if (existVariable(local_node.body))
	{	rtxTpl_compile<local_node.body.type>(local_node.body, compile);}
}

function	rtxTpl_compile<"__expr__">(local_node : node, compile : node)
{
	if (existVariable(local_node.left))
	{	rtxTpl_compile<local_node.left.type>(local_node.left, compile);}
	if (existVariable(local_node.right))
	{	rtxTpl_compile<local_node.right.type>(local_node.right, compile);}
	if (existVariable(local_node.id) && rtxTpl_havePlaceHolder(local_node.id))
	{
		traceLine("MAP PLACE HOLDER:" + toString(local_node.id));
		rtxTpl_mapPlaceHolder(local_node.id, compile);
	}
}

function	rtxTpl_compile<"__stmt__">(local_node : node, compile : node)
{
	// pour l'instant seulement les expressions
	if (local_node.stmt_type == "__expr__")
	{	rtxTpl_compile<local_node.expr.type>(local_node.expr, compile);}
	else
		traceLine("SKIP");
}

function	rtxTpl_compile<"__block__">(local_node : node, compile : node)
{
	traceLine("COMPILE BLOCK");
	// cherche dans l'ast du Cnorm tous les placeHolders
	foreach item in local_node.block
	{	rtxTpl_compile<item.type>(item, compile);}
}

foreach item in source.block
{
	rtxTpl_walk<item.type>(item);
}

saveProject("__rtx_compil__.tree", source);

/// le code generer aura besoin de ca
function	instanceTpl<T>(ast_context : node, c_tree : node)
{
	// grosso modo si ca c appel ya un pb de link
	error("BAD LINK - Unkown registry value:" + T);
}

////////////////// la on genere du codeworker et on y croit :)
function	gencodeworker(tpl_node : node)
{
	////////// workaround super tricky de la mort du slip qui pue
	/// on va rendre Position Code Independant les references issues de la serialisation du sous AST :)
	local workaround;
	parseStringAsBNF({
			// cauchemard begins here
			trauma ::=
				=> traceLine("WORKAROUND");
				// la premiere CString contient le node serialise, on prends tout jusqu'au ".body" du node rtxTpl
				'"' ->(:this.tree_ref)".body" '"'
				// on prends le reste
				->(:this.code_pic)#empty
				=> insert this.tree_replace = "&ref \"" + this.tree_ref + ".";
			;
	}, workaround, toString(tpl_node.body));
	// on translate les ref pour etre relatif a "tree", la variable local de notre instanciateur de template
	workaround.code_pic = "\"tree\"" + replaceString(workaround.tree_replace, "&ref \"tree.", workaround.code_pic);
	traceLine("TREE REF:" + workaround.tree_ref);
	traceLine("TREE REPLACE:" + workaround.tree_replace);
	traceLine("NEW CODE PIC:" + workaround.code_pic);
	// on met la chaine de code PIC dans notre tpl_node pour etre accessible pendant la generation du code codeworker
	local sAstFile = "__rtx_codeworker_XXX.tree";//pour l'instant en dur
	saveToFile(sAstFile, workaround.code_pic);
	insert tpl_node.save_ast = sAstFile;
	local	source_codeworker;
	generateString({

		// auto generated codeworker DO NOT EDIT
		// ici une version specialiser de l'instanceTPL .... on met this.prototype mets a terme generer des UID c'est mieux
		function	instanceTpl<"@this.prototype@">(ast_context : node, c_tree : node)
		{
			local tree;
			loadProject("@this.save_ast@", tree);

			// on crache juste le code template
			traceLine("INSTANCIATION DU TEMPLATE");
			traceLine(cnorm2c(tree));
		}

	@}, tpl_node, source_codeworker);

	// on considere qu'il n'y a qu'un template donc
	saveToFile("__rtx_codeworker.cws", source_codeworker);
}

/// foreach brutale a terme on devrait walk le tree pour gerer correctement les __rtx_tpl__, __rtx_with__ etc...
foreach item in source.block
{
	// racine de la generation des templates
	gencodeworker(item);
	// on a tout generer on charge :P.... a terme delegue a RTX_LINK
	extendExecutedScript(loadFile("__rtx_codeworker.cws"));
	
	// on l'appel ... ici en dur tout moche pour faire un test
	local a;
	local b;
	instanceTpl<item.prototype>(a, b);
}

