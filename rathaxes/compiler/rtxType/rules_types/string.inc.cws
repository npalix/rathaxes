function        rtxType_Parse<"string.inc.cws">(src : value, out_type : node)
{
        parseStringAsBNF({
                string ::= ['"' ->[~'\\' '"']]:str
                        =>{
                                this.rtype = "";
                                local nameId;
                                rtxNodeIdentifier(nameId, "string", "Builtin");
                                local dummy;
                                rtxNodeRType(this.rtype, nameId, dummy);
                                insert this.val = str;
                        }
                ;
        }, out_type, src);
        if (out_type.rtype == "unknown")
        {       return false;}
        traceLine("FOUND:" + toString(out_type));
        return true;
}

function        rtxNode2cnormNode<"Builtin::string">(in_param : node, out_param : node)
{
    return cnormNode_TerminalLiteral(out_param, in_param.val);
}

function type_map<"Builtin::string">(resolverValues : node,
                                     theRtype : node, mappedId : value,
                                     placeHolder : node)
{
    if (mappedId == "")
    {
        // Here, the data should already be a cnorm Literal node.
        local tplVarName = resolverValues["self"].body;
        localref data = resolverValues[tplVarName].body;
        setall placeHolder#parent.ref_placeholder#parent = data;
        return true;
    }
    else
    {
        traceLine(RED + "[Error] Identifier '"+mappedId+"' not mapped for type '::string'." + DEFAULT_COLOR);
    }
    return false;
}

/*
 * The only comparison operator valid for a string is the equal.
 */
function rtxLink_CompareEqual<"Builtin::string">(ref : node, val : node)
{
    return (ref.val == val.val);
}
