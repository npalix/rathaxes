#if !existFunction(rtxTypingRoutines_Mid_version)

function rtxTypingRoutines_Mid_version()
{ return "1.0"; }

#include "typing/routines/rtxTypingRoutines_Common.inc.cws"

function        rtxItfIdNodeToRType(idNode: node, rtypeNode : node)
{
    local dummy_out_ref;

    rtxNodeRType(rtypeNode, idNode, dummy_out_ref);
}

/*
 * This function checks whether an interface contains a type described
 * by a RType node, by checking inside its tree.
 */
function        rtxInterfaceHasType_recursive(rtypeNode : node, interfaceNode : node,
                                              match_count : node, possibilities : node)
{
    if (rtypeNode.type != "__rtx_rtype__")
        error("Bad node type. Received: " + rtypeNode.type);

    local name = rtxRTypeName<rtypeNode.type>(rtypeNode);
    // Unkown scope and not explicit global ?
    // In this case, we'll check ALL possibilities. and decide afterwards.
    if (rtypeNode.name.scope == "" && rtypeNode.name.global == false)
    {
        // We are searching for qualified items, thus set the scope before checking.
        rtypeNode.name.scope = interfaceNode.name;
        name = rtxRTypeName<rtypeNode.type>(rtypeNode);
        // Check current interface.
        if (findElement(name + "{}", interfaceNode.types) == true)
        {
            increment(match_count);
            // Add the interface possibility to the list.
            pushItem possibilities;
            possibilities#back = interfaceNode.name;
        }
        rtypeNode.name.scope = "";

        // Recursive check in parents interfaces.
        foreach parentInterface in interfaceNode.inheritance
        {
            // Here, we don't care about success or failure in the parent interfaces
            // The wrapper function will sort out things depending
            // on the variables 'match_count' and 'possibilities'
            rtxInterfaceHasType_recursive(rtypeNode, parentInterface, match_count, possibilities);
        }
    }
    else if (rtypeNode.name.global == false) // known scope
    {
        if (rtypeNode.name.scope != interfaceNode.name)
        {
            // If it's not a direct inheritance, try out by going through the parent first to find the itf...
            if (!findElement(rtypeNode.name.scope, interfaceNode.inheritance))
            {
                foreach parentInterface in interfaceNode.inheritance
                {
                    if (rtxInterfaceHasType_recursive(rtypeNode, parentInterface,
                                                      match_count, possibilities) == true)
                    {
                        return true;
                    }
                }
                traceLine(RED + "[Error] Could not find interface '"+rtypeNode.name.scope+"' in inheritance tree." + DEFAULT_COLOR);
                return false;
            }
            // If it's a direct inheritance, snoop through the types list.
            else
            {
                if (findElement(name + "{}", interfaceNode.inheritance[rtypeNode.name.scope].types) != false)
                    return true;
            }
        }
        else if (findElement(name + "{}", interfaceNode.types) == true)
            return true;
    }
    else // explicit global == true
    {
        // XXX FIXME TODO
        // builtin item management.
        if (rtypeNode.name.name == "register")
            return true;
        if (rtypeNode.name.name == "register_field")
            return true;
        if (rtypeNode.name.name == "register_value")
            return true;
        if (rtypeNode.name.name == "string")
            return true;
        if (rtypeNode.name.name == "number")
            return true;
        if (rtypeNode.name.name == "numser")
            return true;
    }

    return false;
}

/*
 * This wrapper to rtxInterfaceHasType_recursive takes care of checking
 * and ambiguous type use. Read code for more information.
 */
function        rtxInterfaceHasType(rtypeNode : node, interfaceNode : node)
{
    local match_count = 0;
    local possibilities;
    local message;

    if (rtxInterfaceHasType_recursive(rtypeNode, interfaceNode,
                                      match_count, possibilities) == true)
        return true;

    if (match_count == 1)
    {
        traceLine(PURPLE + "[Debug] Found one possibility for type identification."
                  +" Validating interface " + toString(possibilities,true) + DEFAULT_COLOR);
        rtypeNode.name.scope = possibilities#[0];
        return true;
    }

    if (match_count != 0)
    {
        message = RED + "[Error] Could not identify type's interface: "
                    + "found " + match_count + " matching interfaces[ ";
        foreach i in possibilities
        {
            message += i + ", " ;
        }
        message += "]." + DEFAULT_COLOR;
    }
    else
        message = RED + "[Error] Could not identify type: No match in the dependency tree." + DEFAULT_COLOR;
    traceLine(message);

    return false;
}

/*
 * This function checks whether an interface declares a pointcut described
 * by a RType node, by checking inside its tree.
 */
function        rtxTypeCheck_ItfCheckPointcut_recursive(pointcutRtype : node, interfaceNode : node,
                                                        match_count : node, possibilities : node)
{
    if (pointcutRtype.type != "__rtx_rtype__")
        error("Bad node type. Received: " + pointcutRtype.type);


    // Unkown scope and not explicit global ?
    if (pointcutRtype.name.scope == "" && pointcutRtype.name.global == false)
    {
        if (rtxTypeCheck_ItfDefinesPointcut(pointcutRtype, interfaceNode) == true)
        {
            // Increment match_count and add interface name into possibilities list
            increment(match_count);
            pushItem possibilities;
            possibilities#back = interfaceNode.name;
        }

        // Recursive check in parents interfaces.
        foreach parentInterface in interfaceNode.inheritance
        {
            // Here don't check the return value as we want to try with every interface
            rtxTypeCheck_ItfCheckPointcut_recursive(pointcutRtype, parentInterface,
                                                    match_count, possibilities);
        }
    }
    else if (pointcutRtype.name.global == false) // known scope
    {
        if (pointcutRtype.name.scope != interfaceNode.name && !isEmpty(interfaceNode.inheritance))
        {
            if (!findElement(pointcutRtype.name.scope, interfaceNode.inheritance))
            {
                foreach parentInterface in interfaceNode.inheritance
                {
                    if (rtxTypeCheck_ItfCheckPointcut_recursive(pointcutRtype, parentInterface,
                                                                match_count, possibilities) == true)
                        return true;
                }
                traceLine(RED + "[Error] The interface "+interfaceNode.name
                          +" does not depend on interface '"+pointcutRtype.name.scope
                          +"': The pointcut cannot be declared." + DEFAULT_COLOR);
                return false;
            }

            if (rtxTypeCheck_ItfDefinesPointcut(pointcutRtype, interfaceNode.inheritance[pointcutRtype.name.scope]) == true)
                return true;
        }
        else if (rtxTypeCheck_ItfDefinesPointcut(pointcutRtype, interfaceNode) == true)
            return true;

    }
    else // explicit global == true
    {
        // XXX TODO FIXME
        // builtin item management.
        if (pointcutRtype.name.name == "CALL"
            || pointcutRtype.name.name == "IMPLEMENTATION")
            return true;
    }

    return false;
}

/*
 * This wrapper to rtxTypeCheck_ItfCheckPointcut_recursive takes care of checking
 * and ambiguous type use. Read code for more information.
 */
function        rtxTypeCheck_ItfCheckPointcut(rtypeNode : node, interfaceNode : node)
{
    local match_count = 0;
    local possibilities;
    local message;

    if (rtxTypeCheck_ItfCheckPointcut_recursive(rtypeNode, interfaceNode,
                                                match_count, possibilities) == true)
        return true;

    if (match_count == 1)
    {
        traceLine(PURPLE + "[Debug] Found one possibility for pointcut identification."
                  +" Validating interface " + toString(possibilities,true) + DEFAULT_COLOR);
        rtypeNode.name.scope = possibilities#[0];
        return true;
    }

    if (match_count != 0)
    {
        message = RED + "[Error] Could not identify pointcut's interface: "
                    + "found " + match_count + " matching interfaces[ ";
        foreach i in possibilities
        {
            message += i + ", " ;
        }
        message += "]." + DEFAULT_COLOR;
    }
    else
        message = RED + "[Error] Could not identify pointcut: No match in the dependency tree." + DEFAULT_COLOR;
    traceLine(message);

    return false;
}





#end
