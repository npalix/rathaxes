#if !existFunction(rtxTypingRoutines_Mid_version)

function rtxTypingRoutines_Mid_version()
{ return "1.0"; }

#include "typing/routines/rtxTypingRoutines_Common.inc.cws"

function        rtxItfIdNodeToRType(idNode: node, rtypeNode : node)
{
    local dummy_out_ref;

    rtxNodeRType(rtypeNode, idNode, dummy_out_ref);
}

/*
 * This function checks whether an interface contains a type described
 * by a RType node, by checking inside its tree.
 */
function        rtxInterfaceHasType(rtypeNode : node, interfaceNode : node)
{
    if (rtypeNode.type != "__rtx_rtype__")
        error("Bad node type. Received: " + rtypeNode.type);

    local name = rtxRTypeName<rtypeNode.type>(rtypeNode);
    // Unkown scope and not explicit global ?
    if (rtypeNode.name.scope == "" && rtypeNode.name.global == false)
    {
        // We are searching for qualified items, thus set the scope before checking.
        rtypeNode.name.scope = interfaceNode.name;
        name = rtxRTypeName<rtypeNode.type>(rtypeNode);
        // Check current interface.
        if (findElement(name + "{}", interfaceNode.types) == true)
        {
            rtypeNode.name.scope = interfaceNode.name;
            return true;
        }
        rtypeNode.name.scope = "";

        // Recursive check in parents interfaces.
        foreach parentInterface in interfaceNode.inheritance
        {
            if (rtxInterfaceHasType(rtypeNode, parentInterface) == true)
            {
                // then set the interface's name
                rtypeNode.name.scope = parentInterface.name;
                return true;
            }
        }
    }
    else if (rtypeNode.name.global == false) // known scope
    {
        if (rtypeNode.name.scope != interfaceNode.name)
        {
            // If it's not a direct inheritance, try out by going through the parent first to find the itf...
            if (!findElement(rtypeNode.name.scope, interfaceNode.inheritance))
            {
                foreach parentInterface in interfaceNode.inheritance
                {
                    if (rtxInterfaceHasType(rtypeNode, parentInterface) == true)
                        return true;
                }
                traceLine(RED + "[Error] Could not find interface '"+rtypeNode.name.scope+"' in inheritance tree." + DEFAULT_COLOR);
                return false;
            }

            if (findElement(name + "{}", interfaceNode.inheritance[rtypeNode.name.scope].types) != false)
                return true;
        }
        else if (findElement(name + "{}", interfaceNode.types) == true)
            return true;
    }
    else // explicit global == true
    {
        // XXX FIXME TODO
        // builtin item management.
        if (rtypeNode.name.name == "register")
            return true;
        if (rtypeNode.name.name == "register_field")
            return true;
        if (rtypeNode.name.name == "register_value")
            return true;
        if (rtypeNode.name.name == "string")
            return true;
        if (rtypeNode.name.name == "number")
            return true;
        if (rtypeNode.name.name == "numser")
            return true;
    }

    return false;
}



/*
 * This function checks whether an interface declares a pointcut described
 * by a RType node, by checking inside its tree.
 */
function        rtxTypeCheck_ItfCheckPointcut(pointcutId : node, interfaceNode : node)
{
    if (pointcutId.type != "__rtx_id__")
        error("Bad node type. Received: " + pointcutId.type);

    // Unkown scope and not explicit global ?
    if (pointcutId.scope == "" && pointcutId.global == false)
    {
        if (rtxTypeCheck_ItfDefinesPointcut(pointcutId, interfaceNode) == true)
        {
            // then set the interface's name
            pointcutId.scope = interfaceNode.name;
            return true;
        }

        // Recursive check in parents interfaces.
        foreach parentInterface in interfaceNode.inheritance
        {
            if (rtxTypeCheck_ItfCheckPointcut(pointcutId, parentInterface) == true)
            {
                // then set the interface's name
                pointcutId.scope = parentInterface.name;
                return true;
            }
        }
    }
    else if (pointcutId.global == false) // known scope
    {
        if (pointcutId.scope != interfaceNode.name && !isEmpty(interfaceNode.inheritance))
        {
            if (!findElement(pointcutId.scope, interfaceNode.inheritance))
            {
                foreach parentInterface in interfaceNode.inheritance
                {
                    if (rtxTypeCheck_ItfCheckPointcut(pointcutId, parentInterface) == true)
                        return true;
                }
                traceLine(RED + "[Error] The interface "+interfaceNode.name
                          +" does not depend on interface '"+pointcutId.scope
                          +"': The pointcut cannot be declared." + DEFAULT_COLOR);
                return false;
            }

            if (rtxTypeCheck_ItfDefinesPointcut(pointcutId, interfaceNode.inheritance[pointcutId.scope]) == true)
                return true;
        }
        else if (rtxTypeCheck_ItfDefinesPointcut(pointcutId, interfaceNode) == true)
            return true;

    }
    else // explicit global == true
    {
        // XXX TODO FIXME
        // builtin item management.
        if (pointcutId.name == "CALL"
            || pointcutId.name == "IMPLEMENTATION")
            return true;
    }
    return false;
}


/*
 *
 * The set of functions rtxItfCheckTypesDeclarations<T> walk through a tree
 * and help check whether a type used for a parameter of a template is defined
 * in the associated interface. They also allow to check whether an interface
 * provides a pointcut to be used by the checked one.
 *
 */
function        rtxItfCheckTypesDeclarations<T>(currentDeclaration : node,
                                                currentInterface : node,
                                                interfacesList : node)
{
    return true;
}

function        rtxItfCheckTypesDeclarations<"type">(currentDeclaration : node,
                                                     currentInterface : node,
                                                     interfacesList : node)
{
    if (currentDeclaration.rtype.name.global == false)
    {
        currentDeclaration.rtype.name.scope = currentInterface.name;
    }
    rtxItfAddTypeToList(currentDeclaration, currentInterface.types);
    return true;
}

function        rtxItfCheckTypesDeclarations<"builtintype">(currentDeclaration : node,
                                                            currentInterface : node,
                                                            interfacesList : node)
{
    if (currentDeclaration.rtype.name.global == false)
    {
        currentDeclaration.rtype.name.scope = currentInterface.name;
    }
    rtxItfAddTypeToList(currentDeclaration, currentInterface.types);
    return true;
}

function        rtxItfCheckTypesDeclarations<"variable">(currentDeclaration : node,
                                                         currentInterface : node,
                                                         interfacesList : node)
{
    local scope = currentDeclaration.rtype.name.scope;
    local name = currentDeclaration.rtype.name.name;
    local typeName = rtxRTypeName<currentDeclaration.rtype.type>(currentDeclaration.rtype);
    local varname = currentDeclaration.identifiers.scope + "::" + currentDeclaration.identifiers.name;
    local ret = false;

    if (scope == "" && currentDeclaration.rtype.name.global == false)
    {
        traceLine(RED + "[Error] Type '"+name+"' should be defined in the global namespace." + DEFAULT_COLOR);
        ret = true;
    }
    else
    {
        ret = rtxInterfaceHasType(currentDeclaration.rtype, currentInterface);
        if (ret == false)
            traceLine(RED + "[Error] Type ``" + typeName + "''"
                      + " could not be found for variable ``" + varname + "''." + DEFAULT_COLOR);
    }
    return ret;
}

function        rtxItfCheckTypesDeclarations<"sequence">(currentDeclaration : node,
                                                         currentInterface : node,
                                                         interfacesList : node)
{
    local scope = currentDeclaration.rtype.name.scope;
    local name = currentDeclaration.rtype.name.name;
    local typeName = rtxRTypeName<currentDeclaration.rtype.type>(currentDeclaration.rtype);
    local errcount = 0;

    // First, check the types of the parameters.
    foreach entry in currentDeclaration.rtype.params
    {
        local rtypeNode;
        rtxItfIdNodeToRType(entry, rtypeNode);
        if (rtxInterfaceHasType(rtypeNode, currentInterface) == false)
        {
            traceLine(RED + "[Error] Parameter type ``"
                      + rtypeNode.name.scope + "::" + rtypeNode.name.name + "''"
                      + " could not be found for sequence ``"
                      + typeName + "''." + DEFAULT_COLOR);
            increment(errcount);
        }
        else // Success -> update the rtypeNode
        {
            entry.scope = rtypeNode.name.scope;
            if (entry.scope == "")
                entry.global = true;
        }
    }

    // Second, check that the pointcuts to be implemented exist.
    foreach decl in currentDeclaration.body.block
    {
        if (decl.type == "__rtx_itf_decl__" && decl.specifier == "chunk")
        {
            if (rtxTypeCheck_ItfCheckPointcut(decl.body.pointcut, currentInterface) == false)
            {
                traceLine(RED + "[Error] Pointcut '"
                          + rtxRTypeName<decl.body.pointcut.type>(decl.body.pointcut)
                          +"' is not declared." + DEFAULT_COLOR);
                increment(errcount);
            }
            // In the case of success, the scoped identifier is already updated.
        }
    }
    if (errcount != 0)
        return false;

    // It's all good, so make sure that the scope is set.
    if (currentDeclaration.rtype.name.global == false)
    {
        currentDeclaration.rtype.name.scope = currentInterface.name;
    }
    rtxItfAddTypeToList(currentDeclaration, currentInterface.name);

    return true;
}

function        rtxItfCheckTypesDeclarations<"__rtx_itf__">(currentDeclaration : node,
                                                            currentInterface : node,
                                                            interfacesList : node)
{
    local errcount = 0;
    foreach decl in currentDeclaration.body.block
    {
        if (rtxItfCheckTypesDeclarations<decl.specifier>(decl, currentDeclaration, interfacesList) == false)
            increment(errcount);
    }
    if (errcount != 0)
        return false;
    return true;
}

function        rtxItfCheckTypesDeclarations<"__block__">(currentDeclaration : node,
                                                          currentInterface : node,
                                                          interfacesList : node)
{
    local errcount = 0;
    foreach item in currentDeclaration.block
    {
        if (rtxItfCheckTypesDeclarations<item.type>(item,
                                                    currentInterface,
                                                    interfacesList) == false)
            increment(errcount);
    }
    if(errcount != 0)
        return false;
    return true;
}
function        rtxItfCheckTypesDeclarations<"__rtx_with__">(currentDeclaration : node,
                                                             currentInterface : node,
                                                             interfacesList : node)
{
    return rtxItfCheckTypesDeclarations<"__block__">(currentDeclaration, currentInterface, interfacesList);
}
function        rtxItfCheckTypesDeclarations<"__root_block__">(currentDeclaration : node,
                                                               currentInterface : node,
                                                               interfacesList : node)
{
    return rtxItfCheckTypesDeclarations<"__block__">(currentDeclaration, currentInterface, interfacesList);
}

function        rtxItfCheckTypesDeclarations_walk(local_node : node,
                                                  interfacesList : node)
{
    return rtxItfCheckTypesDeclarations<local_node.type>(local_node, local_node, interfacesList);
}




#end
