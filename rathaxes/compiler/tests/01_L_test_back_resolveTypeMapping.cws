/*
	TEST for template codeworker generation
*/

#include  "01_G_test_back_registerToCache.cws"

#include "passes/common/rtxResolve.inc.cws"

// Load the template :
// First, hash the prototype, then find every template matching it,
// And finally reduce the selection to only one template before loading.

// Build the rtype node for the template
local theRtype;
local name;
local params;
rtxNodeIdentifier(name, "test", "LKM");
rtxNodeRType(theRtype, name, params);
pushItem params;
rtxNodeIdentifier(params#back, "Context", "", true);

local theWith;
local theTemplates;

build_config(theWith);
insert this.config;
setall this.config = theWith;

if (rtxLink_findTemplates(theRtype, theTemplates) == false)
    error("01_L_test_back_resolveTypeMapping.cws:"
          +" The template could not be found by rtxLink.");
traceLine("A list of " + getArraySize(theTemplates)
          + " templates was found matching the prototype '"
          + theProto + "'");

try {
    rtxLink_selectUniqueTemplate(theTemplates, theWith);
}
catch (sError) {
    error("01_L_test_back_resolveTypeMapping.cws:"
          +" rtxLink could not select an unique template :"+toString(theTemplates, true));
}
    traceLine("An Unique template could be identified for resolution.");

local theChunk;
if (rtxLink_selectChunkFromTemplate(theTemplates, "::CALL", theChunk) == false)
    error("01_L_test_back_resolveTypeMapping.cws:"
          +" rtxLink could not find a '::CALL' chunk in template "
          +rtxRTypeName<theRtype.type>(theRtype));
traceLine("The chunk '::CALL' was found for the template.");

traceLine("Loading template : LKM::test(Context ctx)...");
local c_tree;
if (rtxLink_LoadItem(theChunk, c_tree) == false)
    error("01_L_test_back_resolveTypeMapping.cws: Could not load script for chunk"
          + " 'CALL' for template "+rtxRTypeName<theRtype.type>(theRtype));

traceLine("====>Codeworker Script and tree Loaded with success.");


// Now, try the C code generation out : simulate an input (the resVal node)
// And start the resolution of the placeHolders.
local resVals;
local curvalue;
rtxNodeResVal(resVals);
insert resVals["config"];
rtxNodeResVal(resVals["config"]);
insert resVals["config"]["OS"];
curvalue = "Linux";
rtxNodeResValLeaf(resVals["config"]["OS"], curvalue);
insert resVals["Buffer"];
curvalue = "t_rtxBltinBuf";
rtxNodeResValLeaf(resVals["Buffer"], curvalue);
insert resVals["ctx"];
rtxNodeResVal(resVals["ctx"]);
insert resVals["ctx"]["name"];
curvalue = "theContextValue";
rtxNodeResValLeaf(resVals["ctx"]["name"], curvalue);

instanceChunk<c_tree.instanceKey>(resVals, c_tree.body, source);
traceLine("INSTANCIATING TEMPLATE[CALL]: LKM::test(Context ctx)");
traceLine("Template resolved : The call will be replaced by :"
          + cnorm2c(c_tree.body));

