/*
	TEST for template codeworker generation
*/

#include  "01_G_test_back_registerToCache.cws"

#include "passes/common/rtxResolve.inc.cws"

// Load the template :
// First, hash the prototype, then find every template matching it,
// And finally reduce the selection to only one template before loading.

// Build the rtype node for the template
local theRtype;
local name;
local params;
rtxNodeIdentifier(name, "test_call", "LKM");
rtxNodeRType(theRtype, name, params);
pushItem params;
rtxNodeIdentifier(params#back, "Context");

local theWith;
local theTemplates;

build_config(theWith);
setall this.config = theWith;

if (rtxLink_findTemplates(theRtype, theTemplates) == false)
    error("01_N_test_back_resolveSequenceCall.cws:"
          +" The template could not be found by rtxLink.");
traceLine("A list of " + getArraySize(theTemplates)
          + " templates was found matching the prototype '"
          + theProto + "'");

if (rtxLink_selectUniqueTemplate(theTemplates, theWith) == false)
    error("01_N_test_back_resolveSequenceCall.cws:"
          +" rtxLink could not select an unique template :"+toString(theTemplates, true));
traceLine("An Unique template could be identified for resolution.");

local theChunk;
if (rtxLink_selectChunkFromTemplate(theTemplates, "::CALL", theChunk) == false)
    error("01_N_test_back_resolveSequenceCall.cws:"
          +" rtxLink could not find a '::CALL' chunk in template "
          +rtxRTypeName<theRtype.type>(theRtype));
traceLine("The chunk '::CALL' was found for the template.");

traceLine("Loading template : "+rtxRTypeName<theRtype.type>(theRtype)+"...");
local c_tree;
if (rtxLink_LoadItem(theChunk, c_tree) == false)
    error("01_N_test_back_resolveSequenceCall.cws: Could not load script for chunk"
          + " 'CALL' for template "+rtxRTypeName<theRtype.type>(theRtype));

traceLine("====>Codeworker Script and tree Loaded with success.");

// Now, try the C code generation out : simulate an input (the resVal node)
// And start the resolution of the placeHolders.
local resVals;
local curvalue;
rtxNodeResVal(resVals);
insert resVals["config"];
rtxNodeResVal(resVals["config"]);
insert resVals["config"]["OS"];
curvalue = "Linux";
rtxNodeResValLeaf(resVals["config"]["OS"], curvalue);
insert resVals["KK"];
curvalue = "caca";
rtxNodeResValLeaf(resVals["KK"], curvalue);
insert resVals["KKK"];
curvalue = "_tri_k";
rtxNodeResValLeaf(resVals["KKK"], curvalue);
insert resVals["TOTO"];
curvalue = "(*grump)->nia";
rtxNodeResValLeaf(resVals["TOTO"], curvalue);
insert resVals["TYPE"];
curvalue = "t_theType";
rtxNodeResValLeaf(resVals["TYPE"], curvalue);
insert resVals["ctx"];
rtxNodeResVal(resVals["ctx"]);
insert resVals["ctx"]["name"];
curvalue = "theContextValue";
rtxNodeResValLeaf(resVals["ctx"]["name"], curvalue);
insert resVals["symbol"];
insert resVals["symbol"]["name"];
curvalue = "global_init.open";
rtxNodeResValLeaf(resVals["symbol"]["name"], curvalue);

instanceChunk<c_tree.instanceKey>(resVals, c_tree.body, source);
traceLine("INSTANCIATING TEMPLATE[CALL]: "+rtxRTypeName<theRtype.type>(theRtype));
traceLine("Template resolved : The call will be replaced by :"
          + cnorm2c(c_tree.body));
