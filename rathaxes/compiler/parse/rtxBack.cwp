
/////// TEMPLATE
rtx_stmt<"template">(theBlock : node) ::=
        // Initialize the current node
/**/    =>traceLine("TEMPLATE!");
/**/    #pushItem(theBlock.block)
/**/    => local lastNode;
/**/    #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))

        // Create a rtxTPL node.
        // The chunk_block var will reference the block of chunks
/**/    => local prototype; 
/**/    => local chunk_block;
/**/    #check(rtxNodeTpl(lastNode, prototype, chunk_block))

        // Now, retrieve the template's prototype.
/**/    => local rtype;
/**/    => local identifiers;
        #readIdentifier:sType
/**/    #check(rtxNodeTplPrototype(prototype, sType, rtype, identifiers))
        rtx_template_prototype(rtype, identifiers)

        // And parse the template's block
/**/    #continue(sError, "Expected block after template prototype.")
        '{'
                rtx_stmt_template_content<prototype.tpl_type>(lastNode, chunk_block)
        '}'
;

// TEMPLATE SEQUENCE
rtx_stmt_template_content<"sequence">(theTemplate : node, theBlock : node) ::=
/**/    =>traceLine("Template sequence block!");
        [
                // Theoretically, the template should only contain chunks...
                "chunk" rtx_stmt<"chunk">(theBlock)
        ]*
;

// TEMPLATE TYPE
rtx_stmt_template_content<"type">(theTemplate : node, theBlock : node) ::=
/**/    =>traceLine("Template type block!");
        [
                "chunk" rtx_stmt<"chunk">(theBlock)
        |
                "map"
/**/            =>traceLine("MAP");
/**/            =>local mapping;
/**/            =>local body;
/**/            #check(rtxNodeTpl_AddMapping(theTemplate, mapping))
/**/            #check(rtxNodeTplTypeMapping(mapping, body))
/**/            #continue(sError, "Mapping block expected after map statement.")
                rtx_type_map(mapping)
/**/            #continue(sError, "The mapping for template type "
/**/                + theTemplate.rtype.name.scope + "::"
/**/                + theTemplate.rtype.name.id + " is defined twice.")
        ]*
/**/    #continue(sError, "No mapping defined for template type"
/**/         + theTemplate.rtype.name.scope
/**/         + "::" + theTemplate.rtype.name.id + "!")
/**/    #check(rtxNodeTpl_HasMapping(theTemplate))
;

// TYPE MAPPING
rtx_type_map(theBlock : node) ::=
        '{'
                [ rtx_type_map_identifier(theBlock) ]*
        '}'
;

// MAP ONE ID
rtx_type_map_identifier(theMap : node) ::=
        #readIdentifier:sId
/**/    #continue(sError, "Mapping for identifier " + sId + " is already defined.")
/**/    #check(!rtxNodeTplTypeMapping_HasIdentifier(theMap, sId))
/**/    => local mapped_body;
/**/    #check(rtxNodeTplTypeMapping_AddIdentifier(theMap, sId, mapped_body))
/**/    #continue(sError, "Expected ':' after identifier " + sId)
        ':'
        // C expression here.
/**/    #continue(sError, "No C code defined for the mapping of identifier " + sId)
        single_statement(mapped_body)
;


//////// POINTCUT
rtx_pointcut(theBlock : node) ::=
/**/    =>traceLine("POINTCUT!");
/**/    #pushItem(theBlock.block)
/**/    => local lastNode;
/**/    #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
/**/    => local ph;
/**/    #check(rtxNodePointcut_Raw(lastNode, ph))
        rtx_template_code:sPlaceHolder
/**/    => ph = sPlaceHolder;
/**/    #continue(sError, "Expected ';' after pointcut in with block.")
        ';'
;

/////// WITH
rtx_stmt<"with">(theBlock : node) ::=
/**/    => traceLine("WITH");
        // create a block to host the with node
/**/    #pushItem(theBlock.block)
/**/    => local lastNode;
/**/    #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))

        // link to the variable mapping
/**/    => local interfaces;
/**/    => local constraints;
/**/    => local body;
/**/    => local c_block;
/**/    #check(rtxNodeWith(lastNode, interfaces, constraints, body, c_block))
        rtx_stmt_with_descript(interfaces, constraints)
        
        // block of the with node
/**/    #continue(sError, "Expected block after constraints.")
        '{'
                [
                // contains any kind of rtx stmt (with, template, chunk)
                rtx_declaration(body)
                |
                // or global pointcuts
                rtx_pointcut(c_block)
                ]*
        '}'
;

// Description part of a WITH
rtx_stmt_with_descript(theItfs : node, theConstraints : node) ::=
        // First read the dependencies...
        rtx_stmt_with_itf(theItfs)
        [
                "values"
/**/            #continue(sError, "Constraints expected after values keyword.")
                // variables of the with node
                rtx_stmt_with_constraints(theConstraints)
        ]?
;

// List of Interface concern by the WITH
rtx_stmt_with_itf(theItfs : node) ::=
/**/    #pushItem(theItfs)
        #readIdentifier:theItfs#back
        [
                ','
/**/            #continue(sError, "Interface list in constraint error")
/**/            #pushItem(theItfs)
                #readIdentifier:theItfs#back
        ]*
;

// List of constraints
rtx_stmt_with_constraints(theList: node) ::=
        rtx_stmt_with_constraint(theList)
        [
                ','
 /**/           #continue(sError, "Constraints list error.")
                rtx_stmt_with_constraint(theList)
        ]*
;

// One constraint
rtx_stmt_with_constraint(theList : node) ::=
/**/    #pushItem(theList)
/**/    => local identifier;
        rtx_scoped_identifier(identifier)
        rtx_stmt_with_operator:sOperator
/**/    => local theVal;
/**/    #check(rtxNodeWithConstraint(theList#back, identifier, sOperator, theVal))
        rtx_value(theVal)
;

// Constraint operator
rtx_stmt_with_operator ::=
	"=" | ["<=" | ">=" | '<' [#!ignore !'<'] | '>' [#!ignore !'>'] ]
;

//////// CHUNK
rtx_stmt<"chunk">(theBlock : node) ::=
/**/    => traceLine("CHUNK");
/**/    #continue(sError, "Expected pointcut associated to chunk declaration.")
        // Create an item in the Block list to host the chunk
/**/    #pushItem(theBlock.block)
/**/    => local lastNode;
/**/    #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))

        // Optional Joinpoint (argument of the pointcut)
        // Build the chunk node, and retrieve the references to it's internals
        // (body and parameters)
/**/    => local parameters;
/**/    => local body;
/**/    => local pointcut;
/**/    #check(rtxNodeChunk(lastNode, pointcut, parameters, body))
        rtx_scoped_identifier(pointcut)
/**/      #check(rtxNodeVarList(parameters))
        [ rtx_stmt_chunk_params(parameters) ]?
/**/    #continue(sError, "Expected block after chunk declaration.")
        rtx_chunk_body(body)
;

// If there is any parameters to the chunk, we push it into a param list
rtx_stmt_chunk_params(theParams : node) ::=
        '('
        [ rtx_var_list(theParams) ]?
/**/    #continue(sError, "Expected ')' to end parameter list.")
        ')'
;

// Chunk body
rtx_chunk_body(theBody : node) ::=
	'{'
/**/	        #check(cnormNodeDecl_Init(theBody))
		initializer_list(theBody)
                // last ',' but empty
		[',']? 
	'}'
    |
        // The two following lines prevent artefacts (by failing previous alternative) 
/**/    => clearVariable(theBody);
/**/    #check(cnormNodeBlock(theBody))
        rtx_chunk_compound_statement(theBody)
;

// block of code of chunk
rtx_chunk_compound_statement(theBlock : node) ::=
'{'
/**/	#check(cnormNodeBlock(theBlock, true))
	rtx_chunk_block_item_list(theBlock) 
'}'
;

// for DEFINE
#ignore["define"] ::= '\\' [' '|'\t']* '\n'
;

// chunk encapsulate C CODE
rtx_chunk_block_item_list(theBlock : node) ::=
[
	line_of_code(theBlock)
        | '#' 
        [
          "include" ['"' -> '"' | '<' -> '>' ]:sFile
/**/            #pushItem(theBlock.block)
/**/            => local lastNode;
/**/	        #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
/**/            => local sData = "\n#include " + sFile + " \n";
/**/            => cnormNode_Raw(lastNode, sData);
        | "define" #ignore("define") -> "\n":sData
/**/            #pushItem(theBlock.block)
/**/            => local lastNode;
/**/	        #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
/**/            => cnormNode_Raw(lastNode, "\n#define "+sData);
        ]
]*
;
 
///// META-VARIABLE HOOK
// Don't care... for now...
rtx_template_code ::= #!ignore "${" #continue(sError, "Expected '}' after \"'${\"") [rtx_template_brace]* '}' 
;

// consume all and take account of {}
rtx_template_brace ::=
[#!ignore
	'{' [rtx_template_brace]* '}'
	| #readCString
        | #readCChar
	| #readChar:c #check(c != "{" && c != "}" && c != "\"" && c != "'")
]
;

//This rule overload allows the template identifier concatenation for Rathaxes.
#overload
rootidentifier ::= #!ignore
    [ 'a'..'z' | 'A'..'Z' | '_' | rtx_template_code ]
    [ 'a'..'z' | 'A'..'Z' | '0'..'9' | '_' | rtx_template_code ]*
;
