/*
        External languages templated by rathaxes:
        - C (for now)
        - C++ (one day for Darwin driver)
        - Java? (why not)
        - Other? (!!!)
        */

function        rtx_templatedLang_normalize<T>(theBlock : reference)
{
        error("Not supported language:" + T);
}

// guess type from unknown
function        rtx_templatedLang_cnormpass(theDecl : reference)
{
        if (existVariable(theDecl.ctype.unknown) && $getArraySize(theDecl.ctype.unknown) > 0$ && theDecl.ctype.identifier == "auto")
        {
                //traceLine("Possible Declaration:" + toString(theDecl, true));
                // take the last unknown and transform it into type
                local it;
                if (createIterator(it, theDecl.ctype.unknown) && last(it))
                {
                        //traceLine("GOOD!!:" + key(it));
                        
                        theDecl.ctype.identifier = key(it);
                        removeLastElement(theDecl.ctype.unknown);
                        if ($getArraySize(theDecl.ctype.unknown) == 0$)
                        {       removeVariable(theDecl.ctype.unknown);}
                }
        }
}

// check if a C decl need normalization
function        rtx_templatedLang_cnormcheck(item : reference)
{
        if (item.type == "__decl__" || item.type == "__field_decl__" || item.type == "__param_decl__")
        { rtx_templatedLang_cnormpass(item);}
        else if (item.type == "__block__")
        { rtx_templatedLang_normalize<"C">(item);}
        if (existVariable(item.ctype.pointer))
        { 
                //traceLine("POINTER!!");
                rtx_templatedLang_cnormcheck(item.ctype.pointer);
        }
        if (existVariable(item.ctype.body))
        { rtx_templatedLang_normalize<"C">(item.ctype.body);}
        if (existVariable(item.ctype.param))
        { 
                //traceLine("PARAM!!");
                rtx_templatedLang_normalize<"C">(item.ctype.param);
        }
        if (existVariable(item.ctype.list))
        {
                foreach subitem in item.ctype.list
                {
                        localref it = subitem;
                        rtx_templatedLang_cnormcheck(it);
                }
        }
        // EXPR ZONE
        if (existVariable(item.expr))
        {
                //traceLine("EXPR");
                rtx_templatedLang_cnormcheck(item.expr);
        }
        if (existVariable(item.assign_expr))
        {
                //traceLine("ASSEXPR");
                rtx_templatedLang_cnormcheck(item.assign_expr);
        }
        if (existVariable(item.colon_expr))
        {
                //traceLine("COLOEXPR");
                rtx_templatedLang_cnormcheck(item.colon_expr);
        }
        if (existVariable(item.left))
        {
                //traceLine("LEFT");
                rtx_templatedLang_cnormcheck(item.left);
        }
        if (existVariable(item.right))
        {
                //traceLine("RIGHT");
                rtx_templatedLang_cnormcheck(item.right);
        }
        if (existVariable(item.condition))
        {
                //traceLine("COND");
                rtx_templatedLang_cnormcheck(item.condition);
        }
        if (existVariable(item.initialize))
        {
                //traceLine("INIT");
                rtx_templatedLang_normalize<"C">(item.initialize);
        }
        if (existVariable(item.increment))
        {
                //traceLine("INC");
                rtx_templatedLang_cnormcheck(item.increment);
        }
        if (existVariable(item.list))
        {
                foreach subitem in item.list
                {
                        localref        it = subitem;
                        rtx_templatedLang_cnormcheck(it);
                }
        }
        if (existVariable(item.body))
        { rtx_templatedLang_normalize<"C">(item.body);}
        if (existVariable(item.then))
        { rtx_templatedLang_normalize<"C">(item.then);}
        if (existVariable(item.else))
        { rtx_templatedLang_normalize<"C">(item.else);}
}

// normalize a C chunk tree
// - fix type
function        rtx_templatedLang_normalize<"C">(theBlock : reference)
{
        if ((theBlock.type == "__block__" || theBlock.type == "__root_block__") && $getArraySize(theBlock.block) > 0$)
        {
                foreach subitem in theBlock.block
                {
                        localref it = subitem;
                        rtx_templatedLang_cnormcheck(it);
                }
        }
        return true;
}

rtx_templatedLang_single_stmt<T>(theBody : node) ::= =>error("Not supported language:" + T);
;

rtx_templatedLang_body<T>(theBody : node) ::= =>error("Not supported language:" + T);
;

rtx_templatedLang_typedecl<T>(theChunk : node, theBody : node) ::= =>error("Not supported language:" + T);
;

/////////////////////// C LANGUAGE

// declaration
rtx_templatedLang_typedecl<"C">(theChunk : node, theBody : node) ::=
    '{'
        /*
         * Here, we manage Either the Values definitions of an enum
         * Or the definition of a type.
         */
        [
          [ declaration(theBody) | unstrict(theBody) ]+
          |
/**/      => local enumCtype;
          #check(rtxNodeChunk_EnumContent(theChunk, enumCtype))
          enumerator_list(enumCtype)
        ]
    #continue(sError, "Expected end of block for decl.")
    '}'
;

rtx_templatedLang_single_stmt<"C">(theBody : node) ::= single_statement(theBody)
;

// templated language body
// TODO: see to specialized chunk
rtx_templatedLang_body<"C">(theBody : node) ::=
/**/    #check(cnormNodeBlock(theBody))
        rtx_templatedLang_C_compound_stmt(theBody)
    |
        // The following line prevents artefacts (by failing previous alternative) 
/**/    => clearVariable(theBody);
	'{'
/**/	        #check(cnormNodeDecl_Init(theBody))
		initializer_list(theBody)
                // last ',' but empty
		[',']? 
	'}'
;

// block of code of chunk
rtx_templatedLang_C_compound_stmt(theBlock : node) ::=
'{'
/**/	#check(cnormNodeBlock(theBlock, true))
	rtx_templatedLang_C_block_item_list(theBlock) 
'}'
;

// for DEFINE
#ignore["define"] ::= '\\' [' '|'\t']* '\n'
;

// chunk encapsulate C CODE
rtx_templatedLang_C_block_item_list(theBlock : node) ::=
[
        '#' 
        [
          "include" ['"' -> '"' | '<' -> '>' ]:sFile
/**/            #pushItem(theBlock.block)
/**/            => local lastNode;
/**/	        #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
/**/            => local sData = "\n#include " + sFile + " \n";
/**/            => cnormNode_Raw(lastNode, sData);
        | "define" #ignore("define") -> "\n":sData
/**/            #pushItem(theBlock.block)
/**/            => local lastNode;
/**/	        #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
/**/            => cnormNode_Raw(lastNode, "\n#define "+sData);
        ]
	| 
        line_of_code(theBlock)
]*
;
 
///// META-VARIABLE HOOK
// Don't care... for now...done in rtxMeta
rtx_templatedLang_code ::= #!ignore "${" #continue(sError, "Expected '}' after \"'${\"") [rtx_templatedLang_brace]* '}' 
;

// consume all and take account of {}
rtx_templatedLang_brace ::=
[#!ignore
	'{' [rtx_templatedLang_brace]* '}'
	| #readCString
        | #readCChar
	| #readChar:c #check(c != "{" && c != "}" && c != "\"" && c != "'")
]
;

//This rule overload allows the template identifier concatenation for Rathaxes.
#overload
rootidentifier ::= #!ignore
    [ 'a'..'z' | 'A'..'Z' | '_' | rtx_templatedLang_code ]
    [ 'a'..'z' | 'A'..'Z' | '0'..'9' | '_' | rtx_templatedLang_code ]*
;
