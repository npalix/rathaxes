/*
        External languages templated by rathaxes:
        - C (for now)
        - C++ (one day for Darwin driver)
        - Java? (why not)
        - Other? (!!!)
        */

function        rtx_templatedLang_normalize<T>(theBlock : reference)
{
        error("Not supported language:" + T);
}

function        rtx_templatedLang_cnormpass(theDecl : reference)
{
        if (existVariable(theDecl.ctype.unknown) && $getArraySize(theDecl.ctype.unknown) > 0$ && theDecl.ctype.identifier == "auto")
        {
                traceLine("GRUMMMMMMMMMFFFF");
                traceLine("Possible Declaration:" + toString(theDecl, true));
                // take the last unknown and transform it into type
                local it;
                if (createIterator(it, theDecl.ctype.unknown) && last(it))
                {
                        theDecl.ctype.identifier = key(it);
                        removeLastElement(theDecl.ctype.unknown);
                        if ($getArraySize(theDecl.ctype.unknown) == 0$)
                        {       removeVariable(theDecl.ctype.unknown);}
                }
        }
}

// normalize a C chunk tree
// - fix type
function        rtx_templatedLang_normalize<"C">(theBlock : reference)
{
        if (theBlock.type == "__block__" && $getArraySize(theBlock.block) > 0$)
        {
                try
                {
                        //foreach item in theBlock.block
                        local it;
                        if !createIterator(it, theBlock.block) error("CAN'T CREATE ITERATOR");
                        do
                        {
                                localref item = it;
                                if (item.type == "__decl__" || item.type == "__field_decl__" || item.type == "__param_decl__")
                                { rtx_templatedLang_cnormpass(item);}
                                else if (item.type == "__block__")
                                { rtx_templatedLang_normalize<"C">(item);}
                                if (existVariable(item.ctype.body))
                                { rtx_templatedLang_normalize<"C">(item.ctype.body);}
                                if (existVariable(item.body))
                                { rtx_templatedLang_normalize<"C">(item.body);}
                                if (existVariable(item.then))
                                { rtx_templatedLang_normalize<"C">(item.then);}
                                if (existVariable(item.else))
                                { rtx_templatedLang_normalize<"C">(item.else);}
                        }
                        while (next(it));
                }
                catch (sError)
                {
                        traceLine("EXECPT:" + sError);
                }
        }
}

rtx_templatedLang_single_stmt<T>(theBody : node) ::= =>error("Not supported language:" + T);
;

rtx_templatedLang_body<T>(theBody : node) ::= =>error("Not supported language:" + T);
;

/////////////////////// C LANGUAGE

rtx_templatedLang_single_stmt<"C">(theBody : node) ::= single_statement(theBody)
;

// templated language body
// TODO: see to specialized chunk
rtx_templatedLang_body<"C">(theBody : node) ::=
/**/    #check(cnormNodeBlock(theBody))
        rtx_templatedLang_C_compound_stmt(theBody)
    |
        // The following line prevents artefacts (by failing previous alternative) 
/**/    => clearVariable(theBody);
	'{'
/**/	        #check(cnormNodeDecl_Init(theBody))
		initializer_list(theBody)
                // last ',' but empty
		[',']? 
	'}'
;

// block of code of chunk
rtx_templatedLang_C_compound_stmt(theBlock : node) ::=
'{'
/**/	#check(cnormNodeBlock(theBlock, true))
	rtx_templatedLang_C_block_item_list(theBlock) 
'}'
;

// for DEFINE
#ignore["define"] ::= '\\' [' '|'\t']* '\n'
;

// chunk encapsulate C CODE
rtx_templatedLang_C_block_item_list(theBlock : node) ::=
[
        '#' 
        [
          "include" ['"' -> '"' | '<' -> '>' ]:sFile
/**/            #pushItem(theBlock.block)
/**/            => local lastNode;
/**/	        #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
/**/            => local sData = "\n#include " + sFile + " \n";
/**/            => cnormNode_Raw(lastNode, sData);
        | "define" #ignore("define") -> "\n":sData
/**/            #pushItem(theBlock.block)
/**/            => local lastNode;
/**/	        #check(cnormNodeBlock_GetLastNode(theBlock, lastNode))
/**/            => cnormNode_Raw(lastNode, "\n#define "+sData);
        ]
	| 
        line_of_code(theBlock)
]*
;
 
///// META-VARIABLE HOOK
// Don't care... for now...done in rtxMeta
rtx_templatedLang_code ::= #!ignore "${" #continue(sError, "Expected '}' after \"'${\"") [rtx_templatedLang_brace]* '}' 
;

// consume all and take account of {}
rtx_templatedLang_brace ::=
[#!ignore
	'{' [rtx_templatedLang_brace]* '}'
	| #readCString
        | #readCChar
	| #readChar:c #check(c != "{" && c != "}" && c != "\"" && c != "'")
]
;

//This rule overload allows the template identifier concatenation for Rathaxes.
#overload
rootidentifier ::= #!ignore
    [ 'a'..'z' | 'A'..'Z' | '_' | rtx_templatedLang_code ]
    [ 'a'..'z' | 'A'..'Z' | '0'..'9' | '_' | rtx_templatedLang_code ]*
;
