#if !existFunction(rtxNode_version)

function rtxNode_version()
{return "1.0";}

function	rtxNode(local_node : node)
{
    cnormNode(local_node);
    local_node.type = "__rtx_node__";

    return true;
}

function rtxNodeNumber(local_node : node, nb : value)
{
    rtxNode(local_node);
    insert local_node.type = "__rtx_nb__";

    insert local_node.val = nb;

    return true;
}

function rtxNodeString(local_node : node, string : value)
{
    rtxNode(local_node);
    insert local_node.type = "__rtx_cstring__";

    insert local_node.val = string;

    return true;
}

function rtxNodeSerialUnit(local_node : node, theUnit : value)
{
    rtxNode(local_node);
    insert local_node.type = "__rtx_serial_unit__";

    insert local_node.val = theUnit;

    return true;
}

function rtxNodeSerialSep(local_node : node, theSeparator : value)
{
    rtxNode(local_node);
    insert local_node.type = "__rtx_serial_sep__";

    insert local_node.val = theSeparator;

    return true;
}

function rtxNodeSerial_AddUnit(theSerial : node, theSerialUnit : node)
{
    if (theSerial.type != "__rtx_serial__")
        return false;

    pushItem theSerial.list;
    setall theSerial.list#back = theSerialUnit;

    return true;
}

function rtxNodeSerial(local_node : node)
{
    rtxNode(local_node);
    insert local_node.type = "__rtx_serial__";

    insert local_node.list;

    return true;
}

function rtxNodeIdentifier(local_node : node, id : value, scope : value = "", global : value = false)
{
    rtxNode(local_node);
    insert local_node.type = "__rtx_id__";

    insert local_node.scope = scope;
    insert local_node.name = id;
    insert local_node.global = global;

    return true;
}

function rtxNodeVar_AddIdentifier(local_node : node, theField : value)
{
    pushItem local_node.identifiers;

    rtxNodeIdentifier(local_node.identifiers#back, theField);

    return true;
}

function rtxNodeVar(local_node      : node,
                    theIdentifier   : node)
{
    rtxNode(local_node);
    insert local_node.type = "__rtx_var__";

    // A list of chained identifiers constituting the real field identifier
    insert local_node.identifiers;
    // Add the var as the first identifier
    pushItem local_node.identifiers;
    setall local_node.identifiers#back = theIdentifier;

    return true;
}

function rtxNodeVarList_AddNode(local_node : node,
                                theVar     : node)
{
    pushItem local_node.list;
    setall local_node.list#back = theVar;

    return true;
}

function rtxNodeVarList(local_node : node)
{
    rtxNode(local_node);
    insert local_node.type = "__rtx_varlist__";

    insert local_node.list;

    return true;
}

function rtxNodeWithConstraint(local_node   : node,
                               theId        : node,
                               theOperator  : value,
                               out_ref_val  : reference)
{
    rtxNode(local_node);
    local_node.type = "__rtx_with_constraint__";

    insert local_node.var;
    setall local_node.var = theId;
    insert local_node.op = theOperator;
    insert local_node.val;
    ref out_ref_val = local_node.val;

    return true;
}

function rtxNodeWith(local_node             : node,
                     out_ref_interfaces     : reference,
                     out_ref_constraints    : reference,
                     out_ref_body           : reference,
                     out_ref_c_block        : reference)
{
    rtxNode(local_node);
    local_node.type = "__rtx_with__";

    // To be used by typechecking, to reorganize data.
    insert local_node.config;

    insert local_node.interfaces;
    ref out_ref_interfaces = local_node.interfaces;

    insert local_node.constraints;
    ref out_ref_constraints = local_node.constraints;

    insert local_node.body;
    cnormNodeBlock(local_node.body);
    ref out_ref_body = local_node.body;

    insert local_node.c_block;
    cnormNodeBlock(local_node.c_block);
    insert local_node.c_block.compile;
    insert local_node.c_block.compile.nbplaceholder = 0;
    ref out_ref_c_block = local_node.c_block;

    return true;
}

function rtxNodeWith_AssocInterfaceConstraint(local_node      : node,
                                              interface       : value,
                                              constraint_key  : value)
{
    if (!findElement(interface, local_node.config))
        insert local_node.config[interface];
    localref constraint = local_node.constraints[constraint_key];
    insert local_node.config[interface][constraint.var.name];
    setall local_node.config[interface][constraint.var.name] = constraint;

    return true;
}

function rtxNodeWith_BuildFromConstraints(local_node : node)
{
    local   to_remove;
    
    if (!existVariable(local_node.config))
        insert local_node.config;

    foreach constraint in local_node.constraints
    {
        rtxNodeWith_AssocInterfaceConstraint(local_node,
                                             constraint.var.scope, // itf name
                                             key(constraint));
        pushItem to_remove = key(constraint);
    }
    foreach theKey in to_remove
        removeElement(local_node.constraints, theKey);
    return true;
}


/*
 * This function transforms (Recursively, depending on the extensions) a
 * variable configuration (from the front end) into a with node for easy
 * comparison.
 *
 * Here, we should already have resolved the variables'interfaces.
 */
function rtxNodeWith_BuildFromConfigVar(local_node : node, config : node)
{
    local errcount = 0;
    local itfName = local_node.id.scope;
    local varName = local_node.id.name;

    if (!findElement(itfName, config))
        insert config[itfName];

    // Check that the variable is not defined twice.
    if (findElement(varName, config[itfName]))
    {
        traceLine(RED + "[Error] Configuration variable "
                  + itfName + "::" + varName + " is defined multiple times."
                  + DEFAULT_COLOR);
        return false;
    }
    insert config[itfName][varName].val;
    setall config[itfName][varName].val = local_node.val;

    if (existVariable(local_node.extension))
    {
        foreach var in local_node.extension.block
        {
            if (rtxNodeWith_BuildFromConfigVar(var, config) == false)
                increment(errcount);
        }
    }
    if (errcount != 0)
        return false;

    return true;
}

/*
 * This function transforms a config node (from the front end parsing)
 * into a with node (for constraint comparisons)
 */
function rtxNodeWith_BuildFromConfig(local_node : node, out_config : node)
{
    local errcount = 0;

    if (local_node.type != "__rtx_config__")
    {
        traceLine(RED + "[Error] Wrong node type given to function"
                  + " rtxNodeWith_BuildFromConfig." + DEFAULT_COLOR);
        return false;
    }

    foreach var in local_node.body.block
    {
        if (rtxNodeWith_BuildFromConfigVar(var, out_config) == false)
            increment(errcount);
    }
    if (errcount != 0)
        return false;

    return true;
}


/*
 *
 * Common nodes  for the middle-end/backend typechecking
 * And coherence.
 *
 */

function        rtxNodeRType(local_node     : node,
                             name           : node,
                             out_ref_params : reference)
{
    rtxNode(local_node);
    local_node.type = "__rtx_rtype__";

    insert local_node.name;
    setall local_node.name = name;

    insert local_node.params;
    ref out_ref_params = local_node.params;

    return true;
}

function        rtxRTypeName<T>(theNode : node)
{
    traceLine("Bad node type: " + T + "\n");
    error("Bad node type: " + T + "\n");
}

function        rtxRTypeName<"__rtx_rtype__">(rTypeNode : node)
{
    return rtxRTypeName<rTypeNode.name.type>(rTypeNode.name);
}

function        rtxRTypeName<"__rtx_id__">(theNode : node)
{
    if (theNode.global == false && theNode.scope == "")
    {
        return theNode.name;
    }
    else if (theNode.global == true)
    {
        return "::" + theNode.name;
    }
    else
        return theNode.scope + "::" + theNode.name;
}

function        rtxRTypeFullQualifiedName<T>(rTypeNode : node, identifiers : node)
{
    local       fullString;

    fullString = rtxRTypeName<rTypeNode.type>(rTypeNode) + "{";
    fullString += joinStrings(identifiers, ",");
    fullString += "}";
    return fullString;
}

function        rtxRTypeFullQualifiedName<"variable">(rTypeNode : node, identifiers : node)
{
    return rtxRTypeName<rTypeNode.type>(rTypeNode) + "{}";
}

function        rtxRTypeFullQualifiedName<"sequence">(rTypeNode : node,
                                                     identifiers : node)
{
    local       fullString;
    local       paramsNameList;

    fullString = rtxRTypeName<rTypeNode.type>(rTypeNode) + "(";
    foreach entry in rTypeNode.params
    {
        pushItem paramsNameList;
        paramsNameList#back = rtxRTypeName<entry.type>(entry);
    }
    fullString += joinStrings(paramsNameList, ",") + ")";
    return fullString;
}

function rtxNodePointcut(local_node         : node,
                         out_ref_pointcut   : reference,
                         out_ref_params     : reference,
                         out_ref_default    : reference)
{
    insert local_node.type = "__rtx_pointcut__";
    insert local_node.name;
    insert local_node.parameters;
    insert local_node.default;

    ref out_ref_pointcut = local_node.name;
    ref out_ref_params = local_node.parameters;
    ref out_ref_default = local_node.default;

    return true;
}

function rtxNodePointcut_Default(local_node : node,
                                 body       : reference)
{
    insert local_node.type = "__rtx_pointcut_default__";
    insert local_node.body;
    // the body Should pure C code.
    cnormNodeBlock(local_node.body);
    ref body = local_node.body;
    return true;
}

function rtxNodeChunk(local_node        : node,
                      out_ref_pointcut  : reference,
                      out_ref_params    : reference,
                      out_ref_body      : reference)
{
    rtxNode(local_node);
    local_node.type = "__rtx_chunk__";

    insert local_node.pointcut;
    insert local_node.parameters;
    insert local_node.body;
    cnormNodeBlock(local_node.body);
    insert local_node.body.compile;
    insert local_node.body.compile.nbplaceholder = 0;

    ref out_ref_pointcut = local_node.pointcut;
    ref out_ref_params = local_node.parameters;
    ref out_ref_body = local_node.body;

    return true;
}

declare function rtxNodeCall_paramType<T>(theParam : node, theSequence : node, out_param : node);

function rtxNodeCall_paramType<T>(theParam : node, theSequence : node, out_param : node)
{
    error("rtxNodeCall_paramType<"+T+"> not implemented.");
}

function rtxNodeCall_paramType<"string">(theParam : node, theSequence : node, out_param : node)
{
    return rtxNodeIdentifier(out_param, "string", "", true);
}

function rtxNodeCall_paramType<"number">(theParam : node, theSequence : node, out_param : node)
{
    return rtxNodeIdentifier(out_param, "number", "", true);
}

function rtxNodeCall_paramType<"symbol">(theParam : node, theSequence : node, out_param : node)
{
    // Since it's a symbol, we truncate at the first '.'
    local varParts;
    cutString(theParam.val, '.', varParts);

    // First, search inside the parameters of the implemented sequence.
    foreach item in theSequence.seqParamName
    {
        if (item == varParts[0])
        {
            setall out_param = theSequence.rtype.params[index(item)];
            // Now that the variable is identified, we must check the mappings if there's some
            if (getArraySize(varParts) > 1)
            {
                // Then we're using a mapping
                traceLine(YELLOW + "[Warning] Mapping checking not implemented."+ DEFAULT_COLOR);
                return false;
            }
            // Success.
            return true;
        }
    }

    // If it's not a parameter of the implemented sequence, is it a register ?
    localref theDevice = theSequence#parent#parent#parent;
    foreach decl in theDevice.body.block
    {
        // The variable was actually a register... Let's check it thoroughly
        if (decl.type == "__rtx_register__" && decl.name == varParts[0]
            && getArraySize(varParts) == 1)
        {
            // Set the id as a '::register'
            rtxNodeIdentifier(out_param, "register", "", true);
            return true;
        }
        else if (decl.type == "__rtx_register__" && decl.name == varParts[0])
        {
            foreach field in decl.body.block
            {
                if (field.name == varParts[1] && getArraySize(varParts) == 2)
                {
                    // Set the id as a '::register_field'
                    rtxNodeIdentifier(out_param, "register_field", "", true);
                    return true;
                }
                else if (field.name == varParts[1])
                {
                    foreach val in field.listmask
                    {
                        if (val.name == varParts[2])
                        {
                            if (getArraySize(varParts) > 3)
                            {
                                traceLine(RED + "[Error] A register value cannot contain elements: '"
                                  + theParam.val + "'." + DEFAULT_COLOR);
                                return false;
                            }
                            // Set the id as a '::register_value'
                            rtxNodeIdentifier(out_param, "register_value", "", true);
                            return true;
                        }
                    }
                    traceLine(RED + "[Error] Value '" + varParts[2] + "' not defined for field '"
                              + varParts[1] + "' of register '" + varParts[0] + "'." + DEFAULT_COLOR);
                    return false;
                }
            }
            traceLine(RED + "[Error] Field '" + varParts[1] + "' not defined for register '"
                      + varParts[0] + "'." + DEFAULT_COLOR);
            return false;
        }
    }

    traceLine(RED + "[Error] Variable '" + varParts[0] + "' is not defined in the sequence '"
              + rtxRTypeName<theSequence.rtype.type>(theSequence.rtype) + "'.");
    return false;
}

function rtxNodeCall_toRtype(theCall : node, theSequence : node, theRtype : node)
{
    local errcount = 0;
    local params; // ref to fill in later.
    rtxNodeRType(theRtype, theCall.sequence, params);
    foreach param in theCall.args
    {
        pushItem params;
        if (rtxNodeCall_paramType<param.type>(param, theSequence, params#back) == false)
        {
            traceLine(RED + "[Error] Could not identify type of " + param.val
                      + "(parameter index: " + index(param) + ") to sequence "
                      + rtxRTypeName<theCall.sequence.type>(theCall.sequence)
                      + "." + DEFAULT_COLOR);
            increment(errcount);
        }
    }
    if (errcount != 0)
        return false;
    return true;
}

#include "rtxNodeFront.inc.cws"
#include "rtxNodeMiddle.inc.cws"
#include "rtxNodeBack.inc.cws"

#end
