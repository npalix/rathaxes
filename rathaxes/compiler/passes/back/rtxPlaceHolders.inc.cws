#if !existFunction(rtxPlaceHolders_version)

function rtxPlaceHolders_version()
{return "1.0";}

/*
 * The goal of this func is to go thru all item in the global tree and create PlaceHolders for ${} expression
*/
declare function	rtxPH_walk<T>(local_node : node);

/*
* Go thru C code and placeholderize ${}
*/
declare function	rtxPH_compile<T>(local_node : node, compile : node,
                                      node_idx : value);


// TODO: specialize all __rtx_
function	rtxPH_walk<T>(local_node : node)
{
        return true;
//    traceLine("Unknown rtx_node :" + T);
//	error("Unknown rtx_node :" + T);
}

function	rtxPH_walk<"__rtx_tpl__">(local_node : node)
{
	traceLine("template! walk on " + local_node.prototype);
    foreach chunk in local_node.body.block
    {
        rtxPH_walk<chunk.type>(chunk);
    }
    if (existVariable(local_node.mapping))
    {
        local   dummyIdx = $-1$;
        foreach item in local_node.mapping.body.block
        {
            rtxPH_compile<item.body.type>(item.body,
                                           item.compile,
                                           dummyIdx);
        }
    }
}

function    rtxPH_walk<"__rtx_chunk__">(local_node : node)
{
    local   dummyIdx = $-1$;
    traceLine("walking lone chunk...");
    rtxPH_compile<local_node.body.type>(local_node.body,
                                         local_node.body.compile,
                                         dummyIdx);
}

function	rtxPH_walk<"__block__">(local_node : node)
{
    // Should only be used for the block of a with node.
    traceLine("WALKING BLOCK");

    // This variable allows retrieving 
	foreach item in local_node.block
	{ rtxPH_walk<item.type>(item); }
}

function	rtxPH_walk<"__rtx_with__">(local_node : node)
{
	traceLine("with! recurs body");
    // First walk the block of templates
	rtxPH_walk<local_node.body.type>(local_node.body);
    // And then compile the C block containing the pointcuts.
    rtxPH_compile<local_node.c_block.type>(local_node.c_block,
                                            local_node.c_block.compile,
                                            $-1$);
}


////////
// Tool functions in order to find the placeHolders

function	rtxPH_havePlaceHolder(ref_node : reference)
{
	traceLine("havePH?:" + ref_node);
	return (findString(ref_node, "${") != -1);
}

function	rtxPH_mapPlaceHolder(ref_node : reference, compile : node,
                                  node_idx : value)
{
    if (!existVariable(compile.nbplaceholder))
        insert compile.nbplaceholder;
	compile.nbplaceholder = $compile.nbplaceholder + 1$;
	local sKey = "_" + compile.nbplaceholder;
    insert compile[sKey].block_idx = node_idx;
	insert compile[sKey].ref_placeholder;
	ref compile[sKey].ref_placeholder = ref_node;
	insert compile[sKey].template_expr = compile[sKey].ref_placeholder;
	compile[sKey].ref_placeholder = sKey;
}

////////

function	rtxPH_compile<T>(local_node : node, compile : node,
                              node_idx : value)
{
    error("rtxPH_compile<"+T+"> Hasn't been implemented yet ("+T+")...");
}

function	rtxPH_compile<"__block__">(local_node : node, compile : node,
                                        node_idx : value)
{
	traceLine("COMPILE BLOCK");
	// find every single placeHolder in the cNorm tree
    foreach item in local_node.block
	{
        if (isEmpty(item) && !existVariable(item.type))
        {
            error(RED + "A parsing artefact may have been left into the block: empty item:"+toString(item) + DEFAULT_COLOR);
        }
        rtxPH_compile<item.type>(item, compile, index(item));
    }
}
function rtxPH_compile<"__source_block__">(local_node : node, compile : node, node_idx : value)
{ rtxPH_compile<"__block__">(local_node, compile, node_idx); }
function rtxPH_compile<"__block_init__">(local_node : node, compile : node, node_idx : value)
{ rtxPH_compile<"__block__">(local_node, compile, node_idx); }



function	rtxPH_compile<"__decl__">(local_node : node, compile : node,
                                       node_idx : value)
{
	traceLine("COMPILE DECL");
	// walk the ctype node
	localref ctype_ref = local_node.ctype;
	do
	{
		// name of a type
		if (existVariable(ctype_ref.identifier)
            && rtxPH_havePlaceHolder(ctype_ref.identifier))
		{
			traceLine("MAP PLACE HOLDER:" + toString(ctype_ref.identifier));
			rtxPH_mapPlaceHolder(ctype_ref.identifier, compile, node_idx);
		}
        if (existVariable(ctype_ref.list))
        {
            foreach item in ctype_ref.list
            {
                rtxPH_compile<item.type>(item, compile, node_idx);
            }
        }
		// recurse param list
		//...
		// recurse field list
		//...
		if (!existVariable(ctype_ref.pointer))
		{break;}
		// deref
		ref ctype_ref = ctype_ref.pointer.ctype;
	} while(true);

	// variable name
	if (existVariable(local_node.name)
        && rtxPH_havePlaceHolder(local_node.name))
	{
		traceLine("MAP PLACE HOLDER:" + toString(local_node.name));
		rtxPH_mapPlaceHolder(local_node.name, compile, node_idx);
	}

    // And check each of the possible members...
    // the colon expression for C++ ctor init list and bitfields
    if (existVariable(local_node.colon_expr))
        rtxPH_compile<local_node.colon_expr.type>(local_node.colon_expr,
                                                       compile, node_idx);
    // the assign_expression for initialization list
    if (existVariable(local_node.assign_expr))
        rtxPH_compile<local_node.assign_expr.type>(local_node.assign_expr,
                                                        compile, node_idx);

	// recurse on the function's code
	if (existVariable(local_node.body))
	{
        rtxPH_compile<local_node.body.type>(local_node.body, compile,
                                             node_idx);
    }
}
function	rtxPH_compile<"__field_decl__">(local_node : node, compile : node, node_idx : value)
{ rtxPH_compile<"__decl__">(local_node, compile, node_idx); }
function	rtxPH_compile<"__param_decl__">(local_node : node, compile : node, node_idx : value)
{ rtxPH_compile<"__decl__">(local_node, compile, node_idx); }
function	rtxPH_compile<"__fwd_decl__">(local_node : node, compile : node, node_idx : value)
{ rtxPH_compile<"__decl__">(local_node, compile, node_idx); }


// The subtypes of expression offer many different attributes to the node,
// So do not bother with subtypes and check them all and then recurse.
function	rtxPH_compile<"__expr__">(local_node : node, compile : node,
                                       node_idx : value)
{
	if (existVariable(local_node.left))
	{
        rtxPH_compile<local_node.left.type>(local_node.left, compile,
                                             node_idx);
    }
	if (existVariable(local_node.right))
	{
        rtxPH_compile<local_node.right.type>(local_node.right, compile,
                                              node_idx);
    }
    if (existVariable(local_node.condition))
    {
        rtxPH_compile<local_node.condition.type>(local_node.condition, compile,
                                                  node_idx);
    }
    if (existVariable(local_node.then))
    {
        rtxPH_compile<local_node.then.type>(local_node.then, compile,
                                             node_idx);
    }
    if (existVariable(local_node.else))
    {
        rtxPH_compile<local_node.else.type>(local_node.else, compile,
                                             node_idx);
    }
    if (existVariable(local_node.body))
    {
        rtxPH_compile<local_node.body.type>(local_node.body, compile,
                                             node_idx);
    }
    if (existVariable(local_node.list))
    {
        foreach item in local_node.list
        {
            if (existVariable(item.expr.list))
            {
                foreach param in item.expr.list
                {
                    if (existVariable(param.expr_type))
                        rtxPH_compile<param.type>(param, compile, node_idx);
                }
            }
        }
    }
	if (existVariable(local_node.id) && rtxPH_havePlaceHolder(local_node.id))
	{
		traceLine("MAP PLACE HOLDER:" + toString(local_node.id));
		rtxPH_mapPlaceHolder(local_node.id, compile, node_idx);
	}
}

function	rtxPH_compile<"__stmt__">(local_node : node, compile : node,
                                       node_idx : value)
{
	if (existVariable(local_node.expr))
	{
        rtxPH_compile<local_node.expr.type>(local_node.expr, compile,
                                             node_idx);
    }
    if (existVariable(local_node.label) && rtxPH_havePlaceHolder(local_node.label))
    {
		traceLine("MAP PLACE HOLDER:" + toString(local_node.label));
		rtxPH_mapPlaceHolder(local_node.label, compile, node_idx);
    }
    if (existVariable(local_node.ctrl) && rtxPH_havePlaceHolder(local_node.ctrl))
    {
		traceLine("MAP PLACE HOLDER:" + toString(local_node.ctrl));
		rtxPH_mapPlaceHolder(local_node.ctrl, compile, node_idx);
    }
    if (existVariable(local_node.condition))
    {
        rtxPH_compile<local_node.condition.type>(local_node.condition, compile,
                                                  node_idx);
    }
    if (existVariable(local_node.then))
    {
        rtxPH_compile<local_node.then.type>(local_node.then, compile,
                                             node_idx);
    }
    if (existVariable(local_node.else))
    {
        rtxPH_compile<local_node.else.type>(local_node.else, compile,
                                             node_idx);
    }
    if (existVariable(local_node.init))
    {
        rtxPH_compile<local_node.init.type>(local_node.init, compile,
                                             node_idx);
    }
    if (existVariable(local_node.increment))
    {
        rtxPH_compile<local_node.increment.type>(local_node.increment, compile,
                                                  node_idx);
    }
    if (existVariable(local_node.body))
    {
        rtxPH_compile<local_node.body.type>(local_node.body, compile,
                                             node_idx);
    }
}

/*
 * Walker functions for annex node types.
 */
function rtxPH_compile<"__index_designation__">(local_node : node, compile : node,
                                                 node_idx : value)
{
    // First, look into the index (most likely an expression/terminal expr)
	rtxPH_compile<local_node.index.type>(local_node.index, compile, node_idx);
    // Next look into the rhs expr.
	rtxPH_compile<local_node.expr.type>(local_node.expr, compile, node_idx);
}

function rtxPH_compile<"__field_designation__">(local_node : node, compile : node,
                                                 node_idx : value)
{
    // First check that the field is not a placeHolder
    if (rtxPH_havePlaceHolder(local_node.name))
    {
        rtxPH_mapPlaceHolder(local_node.name, compile, node_idx);
    }
    // Next check the rhs for a placeHolder
	rtxPH_compile<local_node.expr.type>(local_node.expr, compile, node_idx);
}




function    rtxPH_compile<"__rtx_pointcut_raw__">(local_node : node,
                                                   compile : node,
                                                   node_idx : value)
{
    traceLine("MAP PLACE HOLDER:" + toString(local_node.id));
    rtxPH_mapPlaceHolder(local_node.id, compile, node_idx);
}

#end
