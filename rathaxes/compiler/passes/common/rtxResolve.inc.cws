#if !existFunction(rtxResolve_version)

function rtxResolve_version()
{ return "1.0"; }


/*
 * Those functions are generated by rtxGen
 */
declare function instanceChunk<T>(resVals : node, c_tree : node, source_tree : reference);
declare function instanceMapping<T>(resVals : node, c_tree : node, source_tree : reference);

/*
 * Those functions may be either generated by passes/back/rtxGen or written for a builtin.
 *
 * The type_map function should usually receive an array containing at most one identifier.
 * The arrays containing two identifiers are either local variables ( ${local.buf.sz} )
 * or erroneous variables.... (never planned on supporting multiple nested types : ${local.array.memory.test()} )
 */
declare function type_map<T>(resolverValues : node, theRtype : node, mappedIds : node, placeHolder : node, out_node : node, source_tree : reference);
declare function type_call<T>(resolverValues : node, chunkName : value, placeHolder : node, source_tree : reference);

// Injection functions
declare function inject<sNodeType>(resolverValues : node, treeNode : node, local_node : node, source_tree : reference);
declare function inject_pointcut<T>(resolverValues : node, treeNode : node, local_node : node, source_tree : reference);

declare function isBuiltinVariable(varname : value);
declare function insertModifier(theBlock : node, thePointcut : node);
declare function rtxResolve_InsertCode(destBlock : node, startIdx : node, phName : value, phIdx : node, sourceNode : node);
declare function rtxResolve_insertTypeMap(theType : node, source_tree : reference);
declare function rtxResolve_InsertType(theDecl : node, typeDeclBlock : node, source_tree : reference);
declare function rtxResolve_BuildParameterResVals(src_resVals : node, src_params : node, dst_resVals : node, dst_params : node, source_tree : reference);
declare function rtxResolve_BuildFrontResVals(src_resVals : node, src_params : node, dst_resVals : node, dst_params : node, source_tree : reference);
declare function rtxResolve_replaceCalls(theSeq : node, resolverValues : node, source_tree : reference);


// TODO FIXME XXX WORKAROUND TO BE REMOVED.
declare function rtxGetTypeFromVariableID<T>(out_type : node);



/*
 *
 * Those two functions are the functions generated through passes/back/rtxGen
 *
 */
function	     instanceChunk<T>(resVals : node, c_tree : node, source_tree : reference)
{
	// If this cocde is called, there was a linking problem.
	error("instanceChunk: BAD LINK - Unkown registry value: " + T);
}

function instanceMapping<T>(resVals : node, c_tree : node, source_tree : reference)
{
    //If this code is called, there was a linking problem.
    error("instanceMapping: BAD LINK - Unkown registry value: "+T);
}


function isBuiltinVariable(varname : value)
{
    return (varname == "local" || varname == "config");
}

function insertModifier(theBlock : node, thePointcut : node)
{
    if (!existVariable(theBlock.modifier))
        insert theBlock.modifier = 0;
    thePointcut.block_idx = $thePointcut.block_idx + theBlock.modifier$;

    // Since removeElement uses the keys instead of indexes (what we store...), lets get an iterator at the right index.
    local iterator_id = thePointcut.block_idx;
    local   it;
    createIterator(it, theBlock);
    while (iterator_id != 0)
    {
        next(it);
        decrement(iterator_id);
    }
    removeElement(theBlock, key(it));
    decrement(theBlock.modifier);
}

/*
 *
 * Function that allow weaving ASTs by injecting the function definitions into
 * the global scope, and every other node in the block starting at the current
 * index.
 *
 * It is only used by a link resolution.
 *
 * XXX TODO FIXME
 * Should this function update the placeHolders' block_idx ?
 * I fear it may insert wrongly with many multiple inclusions for different
 * placholders in a same chunk of code.
 *
 */
function    rtxResolve_InsertCode(destBlock : node, startIdx : node,
                                  phName : value, phIdx : node,
                                  sourceNode : node)
{
    local modifier = $0$;
    local sKey;

    // Here, we are at the root of the resolved template AST.
    foreach item in sourceNode.block
    {
        sKey = phName + "_" + phIdx;

        insertElementAt(destBlock, sKey, startIdx);
        setall destBlock#[startIdx] = item;

        increment(startIdx);
        increment(phIdx);
        increment(modifier);
    }
    if (existVariable(destBlock.modifier))
        destBlock.modifier = $destBlock.modifier + modifier$;
}



function    rtxResolve_insertTypeMap(theType : node, source_tree : reference)
{
    localref    mapping = source_tree.c_types;

    if (theType.ctype.storage != "typedef")
    {
        // Check the specifier is not already inserted (struct, union, etc...)
        if (!findElement(theType.ctype.specifier, mapping))
            insert mapping[theType.ctype.specifier];
        // Then it's already defined.
        if (findElement(theType.ctype.identifier, mapping[theType.ctype.specifier]))
            return;
        insert mapping[theType.ctype.specifier][theType.ctype.identifier];
        ref mapping = mapping[theType.ctype.specifier][theType.ctype.identifier];
    }
    else
    {
        // If it's already defined, then it's ok.
        if (findElement(theType.name, mapping))
            return;
        insert mapping[theType.name];
        ref mapping = mapping[theType.name];
    }

    // First, insert the type into the type map.
    insert mapping.c_decl;
    setall mapping.c_decl = theType;
    // Then, go through the types dependencies.
    insert mapping.deps;
    foreach subtype in theType.ctype.body.block
    {
        localref theCtype = subtype.ctype;
        if (theCtype.storage == "typedef")
        {
            if (!findElement(theCtype.name, mapping.deps))
                insert mapping.deps[theCtype.name];
        }
        else
        {
            if (!findElement(theCtype.specifier, mapping.deps))
                insert mapping.deps[theCtype.specifier];
            if (!findElement(theCtype.identifier, mapping.deps[theCtype.specifier]))
                insert mapping.deps[theCtype.specifier][theCtype.identifier];
        }
    }
    return;
}

/*
 * This function takes the node of the variable declaration as theDecl,
 * and the resolved chunk of the type's declaration as typeDeclBlock
 *
 * If the type declaration is a typedef, the typedef is inserted in the var decl
 * If the type declaration is not a typedef, the associated type replaces the type of the var decl.
 */
function    rtxResolve_InsertType(theDecl : node, typeDeclBlock : node, source_tree : reference)
{
    local typeDef;
    local typeDecl;
    // those booleans are a fucking workaround cause the isEmpty()
    // function doesn't seem to work as expected.
    local hasTypeDef = 0;
    local hasTypeDecl = 0;

    foreach decl in typeDeclBlock.block
    {
        if (decl.ctype.storage == "typedef")
        {
            ref typeDef = decl;
            hasTypeDef = 1;
        }
        else if (decl.ctype.storage == "auto") // not a typedef, then a simple decl
        {
            ref typeDecl = typeDeclBlock.block[key(decl)];
            hasTypeDecl = 1;
        }
    }
    if (hasTypeDef == 1)
    {
        // First, insert the type definition into a map of defined types.
        rtxResolve_insertTypeMap(typeDef, source_tree);
        // Then, replace the type by the typedef if there's one
        theDecl.ctype.identifier = typeDef.name;
    }
    else if (hasTypeDecl)
    {
        // One variable or one structure -> insert the type into the type map.
        rtxResolve_insertTypeMap(typeDecl, source_tree);
        // Now, set the type into the variable decl.
        theDecl.ctype.specifier = typeDecl.ctype.specifier;
        theDecl.ctype.identifier = typeDecl.ctype.identifier;
    }
    else
    {
        traceLine("rtxResolve_InsertType:<ERROR> Could not identify how to weave type !");
        return false;
    }
    return true;
}


/*
 *
 * Functions to manipulate the "ResolverValues", a hashtree of
 * values to be used in the resolution of a template.
 *
 */

/*
 * In this function, both params are rtx Var List Nodes
 *
 * The src_params and src_resVals are the caller's container's parameters and values.
 * The dst_params and dst_resVals are the params of the chunk we're calling and the values
 *      we have to set.
 */
function rtxResolve_BuildParameterResVals(src_resVals   : node,
                                          src_params    : node,
                                          dst_resVals   : node,
                                          dst_params    : node, 
                                          source_tree : reference)
{
    local idx = $0$;
    // TODO: failed to get the param from ::IMPLEM
    /* 
    if (getArraySize(src_params.list) != getArraySize(dst_params.list))
    {
        traceLine(RED + "[Error] Wrong number of parameters given to the sequence (expected "+getArraySize(dst_params.list)
                  +", got "+getArraySize(src_params.list)+")." + DEFAULT_COLOR);
        traceLine(toString(dst_params, true)+toString(src_params, true));
        error("test");
        return false;
    }*/

    foreach dst_param in dst_params.list
    {
        local newValue;
        localref theValue = src_resVals;
        if (!existVariable(src_params.list) || !findElement(idx, src_params.list))
            traceLine(RED + "[Error] src_params do not contain the required field: "+toString(dst_param,true)+" in "+toString(src_params, true) + DEFAULT_COLOR);
        localref theParam = src_params.list#[idx];

        // The parameter can be either a resVal or a rtx variable.
        if (existVariable(theParam.identifiers)) // this is an identifier and not a literal value -> rtx type mapping
        {
            // Two ways to resolve :
            //  - already in the resVals (simple walk/copy)
            //  - not in the ResVals -> gotta build a resVal from the rtx Type (cnormNode).

            // By default, consider it's in the resVals
            foreach param_field in theParam.identifiers
            {
                if (!findElement(param_field.name, theValue))
                {
                    localref theChunk = src_params#root;
                    // There, it is not in the resVals anymore...
                    if (index(param_field) == 0) // Then we're on a rathaxes variable
                    {
                        localref placeHolder = src_params; // We're in a placeHolder anyways, so gotta roll up (called from pointcut or chunk call)
                        while (placeHolder.type != "__rtx_tpl_placeHolder__")
                        { ref placeHolder = placeHolder#parent; }

                        local   paramRtype;
                        if (rtxGetTypeFromVariableID<param_field.name>(paramRtype) == false)
                        {
                            error("Could not find a rathaxes variable named " + param_field.name
                                  + " in the source Resolver values or in the template variables.");
                        }

                        local typename = rtxRTypeName<paramRtype.type>(paramRtype);
                        local dummyResVal;
                        local mapping;
                        local subParam;
                        setall subParam = theParam.identifiers;
                        local subidentifiers;
                        select n in subParam[].name { pushItem subidentifiers; subidentifiers#back = n; }

                        if (type_map<typename>(dummyResVal, paramRtype, subidentifiers, placeHolder, mapping, source_tree) == false)
                        {
                            error("Could not resolve variable '"+param_field.name+"' for type '"+typename+"'");
                        }

                        rtxNodeResValLeaf(newValue, mapping);

                        ref theValue = newValue;
                        break ;
                    }
                    error("Could not find an element named " + param_field.name
                          + " in the source Resolver values or in the C variables.");
                }
                else // Element in previous resolver values.
                {
                    ref theValue = theValue[param_field.name];
                }
            }
        }
        else // We are on a rtx-type value...
        {
            // A RTX parameter MUST be a rtx type.
            local translatedParam;
            if (!rtxNode2cnormNode<theParam.type>(theParam, translatedParam))
                error("Could not translate rathaxes node " + toString(theParam, true) + " to a resVal (containing one cnorm) node.");
            rtxNodeResValLeaf(newValue, translatedParam);
            ref theValue = newValue;
        }

        if (existVariable(dst_param.type) && dst_param.type == "__rtx_var__")
            ref dst_param = dst_param.identifiers#[0].name;
        insert dst_resVals[dst_param];
        setall dst_resVals[dst_param] = theValue;
        increment(idx);
    }

    return true;
}


/*
 * This function is a clone of rtxResolve_BuildParameterResVals, instead it's specialized for
 * the calls from the front-end.
 */
function rtxResolve_BuildFrontResVals(src_resVals   : node,
                                      src_params    : node,
                                      dst_resVals   : node,
                                      dst_params    : node,
                                      source_tree   : reference)
{
    local idx = $0$;
    local newValue;

    if (getArraySize(src_params) != getArraySize(dst_params))
    {
        traceLine(RED + "[Error] Wrong number of parameters given to the sequence (expected "
                  + getArraySize(dst_params) + ", got "+getArraySize(src_params)+")." + DEFAULT_COLOR);
        return false;
    }

    foreach dst_param in dst_params
    {
        localref theValue = src_resVals;
        if (!existVariable(src_params) || !findElement(idx, src_params))
            traceLine(RED + "[Error] src_params do not contain the required field: "+toString(dst_param,true)+" in "+toString(src_params, true) + DEFAULT_COLOR);
        localref theParam = src_params[idx];
        if (existVariable(theParam.identifiers))
        {
            foreach param_field in theParam.identifiers
            {
                if (!findElement(param_field.name, theValue))
                {
                    localref theChunk = src_params#root;
                    if (existVariable(theChunk.variables) && (getArraySize(theParam.identifiers) != 1 || !findElement(param_field.name, theChunk.variables)))
                    {
                        error("Could not find an element named " + param_field.name
                              + " in the source Resolver values or in the C variables.");
                    }
                    else // Element in chunk C variables.
                    {
                        ref theValue = theChunk.variables[param_field.name];
                    }
                }
                else // Element in previous resolver values.
                {
                    ref theValue = theValue[param_field.name];
                }
            }
        }
        else
        {
            // Then we're building a node leaf from another thing
            if (findElement(theParam.val, theValue))
            {
                ref theValue = theValue[theParam.val];
            }
            else
            {
                local translatedParam;
                if (!rtxNode2cnormNode<theParam.type>(theParam, translatedParam))
                    error("Could not translate rathaxes node "
                          + toString(theParam, true) + " to cnorm node.");
                rtxNodeResValLeaf(newValue, translatedParam);
                ref theValue = newValue;
            }
        }
        insert dst_resVals[dst_param];
        setall dst_resVals[dst_param] = theValue;
        increment(idx);
    }

    return true;
}


/*
 * This function iterates over a sequence implementation (front end)
 * and replaces each sequence call by the associated chunk.
 * This function must be use before inserting the implementation into
 * the backend implem of the sequence.
 */
function rtxResolve_replaceCalls(theSeq : node, resolverValues : node, source_tree : reference)
{
    local   errcount = 0;
    local   dummy;
    local   startIdx = 0;
    local   phName = "call";
    local   phIdx = 0;

//////////
traceLine("REPLACE CALL sidx:" + startIdx);
traceLine("REPLACE CALL bidx:" + getArraySize(theSeq.body.block));
//////////

    while ($startIdx < getArraySize(theSeq.body.block)$)
    {
        localref call = theSeq.body.block#[startIdx];
        local   templateCache;
        local   chunkCache;
        local   chunkTree;
        if (!rtxLink_findTemplates(call.rtype, templateCache))
        {
            traceLine(RED + "[Error] Could not find template "
                      + "associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(call.rtype, dummy)
                      + DEFAULT_COLOR);
            return false;
        }
        if (!rtxLink_selectUniqueTemplate(templateCache, source_tree.config))
        {
            traceLine(RED + "[Error] Could not select an unique template"
                      + " associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(call.rtype, dummy)
                      + DEFAULT_COLOR);
            return false;
        }
        if (!rtxLink_selectChunkFromTemplate(templateCache, "::CALL", chunkCache))
        {
            traceLine(RED + "[Error] Could not select chunk '::CALL'"
                      + " associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(call.rtype, dummy)
                      + DEFAULT_COLOR);
            return false;
        }

        // Now that we have selected the decl chunk, load the tree & script
        if (rtxLink_LoadItem(chunkCache, chunkTree) == false)
        {
            traceLine(RED + "[Error] Could not load script or tree."
                      + DEFAULT_COLOR);
            return false;
        }

        // Now, resolve the loaded chunk...
        local resVals;
        rtxResolve_BuildFrontResVals(resolverValues, call.args, resVals, chunkTree.tpl_params, source_tree);
        if (instanceChunk<chunkTree.instanceKey>(resVals, chunkTree.body, source_tree) == false)
        {
            increment(errcount);
        }

        // And insert it in the sequence implem after having removed the original call node.
        local dummy;
        insert dummy.block_idx;
        dummy.block_idx = $startIdx - theSeq.body.block.modifier$; // Compute current original index (alias the key).
        insertModifier(theSeq.body.block, dummy);
        startIdx = dummy.block_idx; // retrieve updated startIdx from dummy.
        rtxResolve_InsertCode(theSeq.body.block, startIdx, phName, phIdx, chunkTree.body);
    }
    return true;
}

/*
 *
 * resolverValues -> the hash mapping of values used in the template

        increment(startIdx);
 * treeNode -> the root of the __rtx_tpl__ node
 * local_node -> current node
 *
 */

function    inject<"">(resolverValues : node, treeNode : node,
                       local_node : node, source_tree : reference)
{
    // we should NEVER fallback here.
    error("inject: BAD NODE - Empty Template Node Type !");
}

function    inject<sNodeType>(resolverValues : node, treeNode   : node,
                              local_node : node, source_tree : reference)
{
    // we should NEVER fallback here.
    error("inject: BAD NODE - Unknown Template Node Type : "+sNodeType);
}

function    inject<"__rtx_tpl_placeHolder__">(resolverValues    : node,
                                              treeNode          : node,
                                              local_node        : node, 
                                              source_tree : reference)
{
    //traceLine("Injecting into placeHolder : realType = "+treeNode.body.type);
    return inject<local_node.body.type>(resolverValues, treeNode, local_node, source_tree);
}

/*
 * resolverValues : hashtable of key/values
 *
 * Both treeNode and local_node are located in the .compile of a chunk
 * They are located as is :
 * treeNode is still undefined.
 *  .compile = {
 *      [
 *          "_X" : {
 *              .node = {
 *                  .body = {   <-- local_node
 *                  }
 *              }
 *              ...
 *          }
 *      ]
 *  }
 */
function    inject<"__rtx_var__">(resolverValues : node, treeNode : node,
                                      local_node : node, source_tree : reference)
{
    //traceLine("Injecting into var : "+toString(local_node));
    local curCtxNode;

    traceLine("inject<\"__rtx_var__\">:<LOG> Injecting code into placeHolder "+local_node#parent.template_expr);
    /*
     *
     * This block of code has for role to check wether we're manipulating
     * a rathaxes type or a variable of a rathaxes type.
     *
     * Here we can manage the access to a mapped identifier in a type
     * We need to build the ResVal for the "${self}" placeHolder of the var.
     *
     */
    //    local_node <=> with.c_block.compile[X].node
    // or local_node <=> chunk.body.compile[X].node
    // or local_node <=> chunk.body.compile[X].node
    localref theChunk = local_node#parent#parent#parent#parent;
    localref varName = local_node.body.identifiers[0].name;
    // First, check that there is not prefix or suffix.
    if (isEmpty(local_node.prefix) && isEmpty(local_node.suffix))
    {
        // TODO FIXME XXX FIME TODO          A
        // TODO FIXME XXX FIME TODO         / \
        // TODO FIXME XXX FIME TODO        / | \
        // TODO FIXME XXX FIME TODO       /  .  \
        // TODO FIXME XXX FIME TODO      /_______\

        // identify if it's a type declaration (i.e. "${Builtin::Buffer} buf;")
        if (local_node#parent.weave_type == "__weave_type_id__")
        {
            traceLine("inject<\"__rtx_var__\">:<LOG> Injecting a type name.");
            // first, retrieve the name of the variable associated to the type or pointer
            localref theDecl = local_node#parent.ref_placeholder#parent#parent;
            while (!existVariable(theDecl.name) && theDecl.type == "__decl__")
            { ref theDecl = theDecl#parent#parent; }
            local   varName = theDecl.name;
            // go back to theDecl where we replace an identifier.
            ref theDecl = local_node#parent.ref_placeholder#parent#parent;
            local   theRtype;
            setall theRtype = theChunk.type_map[varName];
            // First we must select an unique template matching the rtype and config
            local   templates;
            local   declChunk;
            if (!rtxLink_findTemplates(theRtype, templates))
            {
                traceLine("inject<\"__rtx_var__\">:<ERROR> Could not find template "
                          + "associated to type "
                          + rtxRTypeName<theRtype.type>(theRtype));
                return false;
            }
            if (!rtxLink_selectUniqueTemplate(templates, source_tree.config))
            {
                traceLine("inject<\"__rtx_var__\">:<ERROR> Could not select an unique template"
                          + " associated to type "
                          + rtxRTypeName<theRtype.type>(theRtype));
                return false;
            }
            if (!rtxLink_selectChunkFromTemplate(templates, "::decl", declChunk))
            {
                traceLine("inject<\"__rtx_var__\">:<ERROR> Could not select chunk '::decl'"
                          + " associated to type "
                          + rtxRTypeName<theRtype.type>(theRtype));
                return false;
            }

            // Now that we have selected the decl chunk, load the tree & script
            local   subtree;
            rtxLink_LoadItem(declChunk, subtree);

            if (rtxResolve_InsertType(theDecl, subtree.body, source_tree) == false)
                return false;

            return true;
        }
        // If not, is it a variable of a rathaxes type : check in type_map ?
        else if (existVariable(theChunk.type_map)
                 && findElement(varName, theChunk.type_map))
        {
            traceLine("inject<\"__rtx_var__\">:<LOG> Injecting a type mapping.");
            // Create the resolvervalues for the type resolution:
            // This should not need any more than config and var's identifier.
            local resVal;
            setall resVal = resolverValues;
            insert resVal["self"];
            rtxNodeResValLeaf(resVal["self"], varName);

            local qTypeName = rtxRTypeName<theChunk.type_map[varName].type>(
                                    theChunk.type_map[varName]
                                );

            local    mapping;
            local subParam;
            setall subParam = local_node.body.identifiers;
            local subidentifiers;
            select n in subParam[].name { pushItem subidentifiers; subidentifiers#back = n; }

            if (type_map<qTypeName>(resVal, theChunk.type_map[varName],
                                    subidentifiers,
                                    local_node, mapping, source_tree) == false)
            {
                traceLine(RED + "[Error] Could not resolve mapping of '"
                          + subidentifiers[0] + "' for identifier '"
                          + local_node.body.identifiers[0].name + "'." + DEFAULT_COLOR);
                return false;
            }

            // Here, the interesting thing to replace is the id's parent.
            localref theNode = local_node#parent.ref_placeholder#parent;
            if (!existVariable(mapping.type)
                && theNode.type == "__expr__" && theNode.expr_type == "__terminal__")
            { setall theNode.id = mapping; }
            else if (theNode.type == "__expr__")
            { setall theNode = mapping; }
            else if (theNode.type == "__decl__")
            { setall theNode.name = mapping; }
            else
            {
                traceLine(RED + "[Error] inject<\"__rtx_var__\">: Could not weave for node of type '"
                          + theNode.type + "' not implemented." + DEFAULT_COLOR);
                return false;
            }

            return true;
        }
        else if (isBuiltinVariable(varName))
        {
            local dummyResVal;
            local dummyRtype;
            local    mapping;

            local subParam;
            setall subParam = local_node.body.identifiers;
            local subidentifiers;
            select n in subParam[].name { pushItem subidentifiers; subidentifiers#back = n; }

            if (type_map<"Builtin::"+varName>(dummyResVal, dummyRtype,
                                              subidentifiers,
                                              local_node, mapping, source_tree) == false)
            {
                traceLine(RED + "[Error] Could not resolve mapping for builtin variable '"
                          + local_node.body.identifiers[0].name + "'" + DEFAULT_COLOR);
                return false;
            }

            // Here, the interesting thing to replace is the id's parent.
            localref theNode = local_node#parent.ref_placeholder#parent;
            if (!existVariable(mapping.type)
                && theNode.type == "__expr__" && theNode.expr_type == "__terminal__")
            { setall theNode.id = mapping; }
            else if (theNode.type == "__expr__")
            { setall theNode = mapping; }
            else if (theNode.type == "__decl__")
            { setall theNode.name = mapping; }
            else
            {
                traceLine(RED + "[Error] inject<\"__rtx_var__\">: Could not weave for node of type '"
                          + theNode.type + "' (weaving "+toString(mapping)+"): not implemented." + DEFAULT_COLOR);
                return false;
            }

            return true;
        }


        // If both of the conditionis weren't entered, then that means that
        // it is a simple value weaving, and the next part takes care of it.
    }
    if (local_node#parent.ref_placeholder#parent.ctype.storage == "typedef")
    {
        local_node#parent.ref_placeholder = "TARTE";
        return true;
    }
    traceLine("inject<\"__rtx_var__\">:<LOG> Could not find any type manipulation for injection.");
    if (local_node#parent.ref_placeholder#parent.ctype.storage == "typedef")
    {
        local_node#parent.ref_placeholder = "TARTE";
        return true;
    }


    /*
     *
     * This block of code means to replace the placeHolder by a simple
     * identifier in the code. (May be used for the self resolution)
     *
     */
    local fieldValue;
    local finalNode;
    rtxNodeResVal_GetField(resolverValues, local_node.body.identifiers, fieldValue);
    // The ResValLeaf is a whole node : setall it into the placeholder's parent
    if (existVariable(fieldValue.type))
    {
        traceLine("inject<\"__rtx_var__\">:<LOG> Replacing identifier : "+toString(local_node.body.identifiers));
        localref theId = local_node#parent.ref_placeholder;
        //traceLine("So we have the resolver placeholders parent : "+toString(local_node#parent.ref_placeholder#parent#parent, true));
        setall theId#parent = fieldValue;
        //traceLine("So we have the resolver placeholders parent resolved : "+toString(local_node#parent.ref_placeholder#parent#parent, true));
    }
    else
    {
        traceLine("inject<\"__rtx_var__\">:<LOG> Concatenating identifier : "+toString(local_node.body.identifiers));
        // First concat prefix
        finalNode = finalNode + local_node.prefix;
        // Next resolve the value and concat it
        finalNode = finalNode + fieldValue;
        // Finally, concat suffix
        finalNode = finalNode + local_node.sufix;
        local_node#parent.ref_placeholder = finalNode;
    }
    return true;
}

/*
 * resolverValues : hashtable of key/values
 *
 * Both treeNode and local_node are located in the .compile of a chunk
 * They are located as is :
 * treeNode is still undefined.
 *  .compile = {
 *      [
 *          "_X" : {
 *              .node = {
 *                  .body = {   <-- local_node
 *                  }
 *              }
 *              ...
 *          }
 *      ]
 *  }
 */
function    inject<"__rtx_tpl_sequence_call__">(resolverValues : node, treeNode : node,
                                                local_node : node, source_tree : reference)
{
    // Tool variable for code replacing.
    local       errcount = 0;
    local       dummy;
    local       startIdx = 0;
    local       phName = "call";
    local       phIdx = 0;
    localref    theBlock = local_node#parent.ref_placeholder#parent;
    while (theBlock.type != "__block__")
    {
        ref theBlock = theBlock#parent;
    }

    // Two variables to create the rtype associated to the sequence call
    local       theRtype;
    local       paramTypes;

    // Tree variables to help manipulate the cache
    local       templateCache;
    local       chunkCache;
    local       chunkTree;

    // First, build the rtype node.
    rtxNodeRType(theRtype, local_node.body.seqName, paramTypes);
    foreach param in local_node.body.seqArgs
    {
        if (existVariable(param.rtype))
        {
            pushItem paramTypes;
            setall paramTypes#back = param.rtype;
        }
        else
        {
            traceLine(RED + "[Error] Could not find rtx type associated to param '"+param.val
                      +"' for sequence call '"+local_node#parent.template_expr+"'." + DEFAULT_COLOR);
        }
    }

    // Then load the chunk ::CALL to resolve.
    if (!rtxLink_findTemplates(theRtype, templateCache))
    {
        traceLine(RED + "[Error] Could not find template "
                  + "associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(theRtype, dummy)
                  + DEFAULT_COLOR);
        return false;
    }
    if (!rtxLink_selectUniqueTemplate(templateCache, source_tree.config))
    {
        traceLine(RED + "[Error] Could not select an unique template"
                  + " associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(theRtype, dummy)
                  + DEFAULT_COLOR);
        return false;
    }
    if (!rtxLink_selectChunkFromTemplate(templateCache, "::CALL", chunkCache))
    {
        traceLine(RED + "[Error] Could not find '::CALL' chunk"
                  + " associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(theRtype, dummy)
                  + DEFAULT_COLOR);
        return false;
    }

    // Now that we have selected the decl chunk, load the tree & script
    if (rtxLink_LoadItem(chunkCache, chunkTree) == false)
    {
        traceLine(RED + "[Error] Could not load script or tree."
                  + DEFAULT_COLOR);
        return false;
    }

    // Now, resolve the loaded chunk...
    local resVals;
    rtxResolve_BuildFrontResVals(resolverValues, local_node.body.seqArgs, resVals, chunkTree.tpl_params, source_tree);
    if (instanceChunk<chunkTree.instanceKey>(resVals, chunkTree.body, source_tree) == false)
    {
        increment(errcount);
    }
    // And insert it in the sequence implem after having removed the original call node.
    local dummy;
    insert dummy.block_idx;
    dummy.block_idx = $startIdx - theBlock.block.modifier$; // Compute current original index (alias the key).
    insertModifier(theBlock.block, dummy);
    startIdx = dummy.block_idx; // retrieve updated startIdx from dummy.
    rtxResolve_InsertCode(theBlock.block, startIdx, phName, phIdx, chunkTree.body);

    return true;
}


/*
 * The default case of the function inject_pointcut will resolve a "normal"
 * pointcut: insert every chunk in place of the said pointcut.
 *
 * The specializations are meant to be the builtin pointcuts resolution.
 */
function inject_pointcut<T>(resolverValues : node, treeNode : node,
                                    local_node : node, source_tree : reference)
{
    localref theBlock = local_node#parent.ref_placeholder#parent#parent;
    localref thePointcut = local_node#parent;
    local pointcutName = rtxRTypeName<local_node.body.name.type>(local_node.body.name);
    // Variables for the node replacement
    local phName = thePointcut.ref_placeholder#parent.id;
    local phIdx = 0;
    local startIdx = 0;
    // cache-related variable
    local   chunks;
    local   errcount = 0;

    // First, search every chunk associated to the pointcut...
    if (rtxLink_findChunks(local_node.body.name, chunks) == false)
        traceLine("inject_pointcut<\""+T+"\">:<WARN> No chunk associated with"
                  +" the pointcut "
                  + pointcutName);

    // If we cannot find any chunk, let's use default behaviour (if there's one)
    if (isEmpty(chunks)
        || rtxLink_selectCompatibleChunks(chunks, source_tree.config) == false)
    {
        traceLine("inject_pointcut<\""+T+"\">:<WARN> No valid chunk,"
                  +" falling back to default behaviour.");
        // If there's a default block inside the poincut, then insert it
        // instead of the resolved chunks : one setall is enough
        // to both remove the pointcut and insert the code.
        if (existVariable(local_node.body.default.body))
        {
            if (theBlock#parent.type == "__block__")
            {
                if (getArraySize(theBlock) <= thePointcut.block_idx)
                {
                    error(RED+ "Trying to get index " + thePointcut.block_idx + " into block " +
                          toString(theBlock,true) +DEFAULT_COLOR);
                }
                setall theBlock#[thePointcut.block_idx] = local_node.body.default.body;
            }
            else if (theBlock.type == "__stmt__" && theBlock.stmt_type == "__expr__"
                     && theBlock.expr.expr_type == "__terminal__")
            {
                setall theBlock = local_node.body.default.body;
            }
            else
                error("Node type not supported for default resolution..");
        }
        else
        {
            if (theBlock.type == "__block__")
            {
                // removes the current placeHolder and inserts the modifier
                insertModifier(theBlock, thePointcut);
            }
            else if (theBlock#parent.type == "__block__")
            {
                // removes the current placeHolder and inserts the modifier
                insertModifier(theBlock, thePointcut);
            }
        }
    }
    // There are some chunks left, so it's up to us to resolve them
    // and then insert them in-place of the pointcut.
    else
    {
        // make sure it's the block.
        while (theBlock.type != "__block__")
            ref theBlock = theBlock#parent;
        ref theBlock = theBlock.block;
        // First, remove the current placeHolder, in case there was no statement
        insertModifier(theBlock, thePointcut);
        startIdx = thePointcut.block_idx;
        foreach chunk in chunks
        {
            local c_tree;
            if (rtxLink_LoadItem(chunk, c_tree) == false)
            {
                traceLine("inject_pointcut<\""+T+"\">:<ERROR> Could not "
                          +"load script for one chunk for pointcut "+pointcutName+".");
                increment(errcount);
            }
            local resVals;
            if (rtxResolve_BuildParameterResVals(resolverValues,
                                                 local_node.body.parameters,
                                                 resVals, c_tree.parameters, source_tree) == false)
            {
                traceLine(RED + "[Error] Wrong parameters given to pointcut '" + pointcutName + "'." + DEFAULT_COLOR);
                return false;
            }

            if (instanceChunk<c_tree.instanceKey>(resVals, c_tree.body, source_tree) != false)
                rtxResolve_InsertCode(theBlock, startIdx, phName, phIdx, c_tree.body);
            else
            {
                traceLine("inject_pointcut<\""+T+"\">:<ERROR> Could not instanciate chunk '"+c_tree.instanceKey+"'.");
                increment(errcount);
            }
        }
        if (errcount != 0)
            return false;
    }
    return true;
}

function inject_pointcut<"::IMPLEMENTATION">(resolverValues : node, treeNode : node,
                                             local_node : node, source_tree : reference)
{
    localref theBlock = local_node#parent.ref_placeholder#parent;
    // Make sure TheBlock references the parent block (should always be the case for this kind of pointcut).
    while (theBlock.type != "__block__")
    {
        ref theBlock = theBlock#parent;
    }
    ref theBlock = theBlock.block;

    localref thePointcut = local_node#parent;
    // Some variables for the InsertCode function
    local phName = thePointcut.ref_placeholder#parent.id;
    local phIdx = 0;
    local startIdx = 0;
    local dummy;

    // Find the right impl to include from the front by walking
    // through the front tree and checking the tpl against the chunk's hash.
    foreach item in source_tree.block
    {
        if (item.type == "__rtx_device__")
        {
            foreach decl in item.body.block
            {
                if (decl.type == "__rtx_sequence__"
                    && rtxRTypeFullQualifiedName<"sequence">(decl.rtype, dummy) == local_node#parent.tpl_hash)
                {
                    local resVals;
                    local parameters;
                    local theVar;
                    local curId;
                    rtxNodeVarList(parameters);
                    foreach param in decl.seqParamName
                    {
                        clearVariable(curId);
                        rtxNodeIdentifier(curId, param, "");
                        rtxNodeVar(theVar, curId);
                        //foreach id in ???
                        //{
                        //    rtxNodeVar_AddIdentifier(theVar, curId);
                        //}
                        rtxNodeVarList_AddNode(parameters, theVar);
                    }

                    rtxResolve_BuildParameterResVals(resolverValues, 
                                                     local_node.body.parameters,
                                                     resVals, parameters, source_tree);

                    // Then replace each Tpl CALL by the CALL chunks associated.
                    if (rtxResolve_replaceCalls(decl, resVals, source_tree) == false)
                    {
                        traceLine(YELLOW + "Could not replace Call for ::IMPLEMENTATION pointcut for template '" + local_node#parent.tpl_hash + "'."+ DEFAULT_COLOR);
                        return false;
                    }

                    //traceLine(BLUE + "[Debug] Resolved implementation call to " + rtxRTypeFullQualifiedName<"sequence">(decl.rtype, dummy) + ":" + toString(decl.body, true)+DEFAULT_COLOR);
                    //traceLine(PURPLE + "[Debug] Resolved implementation:"+cnorm2c(decl.body)+DEFAULT_COLOR);

                    // Finally, insert the block in-place of the placeHolder.
                    insertModifier(theBlock, thePointcut);
                    startIdx = thePointcut.block_idx; // updated block_idx prevents "index out of bounds"
                    rtxResolve_InsertCode(theBlock, startIdx, phName, phIdx, decl.body);

                    return true;
                }
            }
        }
    }
    traceLine(YELLOW + "Could not resolve ::IMPLEMENTATION pointcut for template " + local_node#parent.tpl_hash + DEFAULT_COLOR);
    return false;
}

/*
 *
 * This function takes a resolver value node, the tree node in which
 * the resolution is needed, and the local_node which is the placeHolder to
 * resolve.
 *
 * This specialization takes care of the resolution of a pointcut, and manages
 * builtin pointcuts (like the ::CALL, ::IMPLEMENTATION pointcut for required/optional templates).
 *
 */
function    inject<"__rtx_pointcut__">(resolverValues   : node,
                                       treeNode         : node,
                                       local_node       : node, 
                                       source_tree : reference)
{
    local ptcutName = rtxRTypeName<local_node.body.name.type>(local_node.body.name);

    if (local_node.body.name.scope == "" && local_node.body.name.global == false)
    {
        error("inject<\"__rtx_pointcut__\">:<ERROR> An unexpected error occurred:"
              + " Unknown scope to poincut " + ptcutName + ".");
    }

    return inject_pointcut<ptcutName>(resolverValues, treeNode, local_node, source_tree);
}

//function    inject<"__rtx_tpl_chunk_call__">(resolverValues : node,
//                                             treeNode : node,
//                                             local_node : node)
//{
//}

/*
 *
 * This function is used to resolve an explicit call to a chunk
 * contained in a type template.
 * This model allows easy builtin implementations.
 *
 */
function    type_call<T>(resolverValues : node,
                         chunkName : value,
                         placeHolder : node, 
                         source_tree : reference)
{
    local   templates;
    local   theChunk;
    localref theRtype = placeHolder.body.rtype;
    local   startIdx;
    if (!rtxLink_findTemplates(theRtype, templates))
    {
        traceLine("type_call<"+T+">: Could not find template.");
        return false;
    }
    if (!rtxLink_selectUniqueTemplate(templates, source_tree.config))
    {
        traceLine("type_call<"+T+">: Could not select an unique template.");
        return false;
    }
    if (!rtxLink_selectChunkFromTemplate(templates, chunkName, theChunk))
    {
        traceLine("type_call<"+T+">: Could not select chunk '" + chunkName + "'.");
        return false;
    }

    // Now that we have selected the decl chunk, load the tree & script
    local   subtree;
    rtxLink_LoadItem(theChunk, subtree);

    // To actually resolve this, we need :
    //  * Current resolverValues (OK)
    //  * The parameters to the chunk (TBD) FIXME XXX TODO
    //
    local resVals;
    // Now add the "self" to the resVals
    insert resVals["self"];
    rtxNodeResValLeaf(resVals["self"], placeHolder.body.vars#back.name);
    // Then add the call (chunk's) parameters to the resval.
    rtxResolve_BuildParameterResVals(resolverValues, placeHolder.body.parameters,
                                     resVals, subtree.parameters, source_tree);

    traceLine("type_call<"+T+">:<LOG> Resolving chunk " + chunkName + "... ");
    if (instanceChunk<subtree.instanceKey>(resVals, subtree.body, source_tree) == false)
    {
        traceLine("type_call<\""+T+"\">:<ERROR> Could not instance Chunk '"+subtree.instanceKey+"'.");
        return false;
    }

    // Now, insert the subtree in place of the placeHolder !
    // placeHolder actually is : block.[idx].expr.id, so unwind until theBlock.type != "__block__".
    localref theBlock = placeHolder#parent.ref_placeholder;
    do { ref theBlock = theBlock#parent; } while (theBlock.type != "__block__");
    localref theCall = placeHolder#parent;
    local phIdx = 0;
    // First, remove the current placeHolder, in case there was no statement
    insertModifier(theBlock.block, theCall);
    startIdx = theCall.block_idx;
    rtxResolve_InsertCode(theBlock.block, startIdx,
                          theCall.ref_placeholder, phIdx, subtree.body);

    traceLine("type_call<"+T+">:<LOG> Resolved call to chunk " + chunkName + "...");
    return true;
}


/*
 * The functions that resolve a type mapping.
 */

// Builtin functions for type mapping
declare function instanceMapping<T>(resVals : node, c_tree : node, source_tree : reference);

/*
 * The function to call when encountering a type mapping...
 *
 * resolverValues : hashtable of values for placeHolder resolution
 * theRtype       : a __rtx_rtype__ node  matching the template's type
 * mappedIds       : the identifier used in the mapping call
 * local_node     : the mapping's placeHolder .node
 */
function type_map<T>(resolverValues : node,
                     theRtype : node, mappedIds : node,
                     placeHolder : node, out_node : node, source_tree : reference)
{
    traceLine("rtxResolve:<LOG> type_map<"+T+"> for variable '"+mappedIds#[0]+"' ("+toString(mappedIds)+")");
    // First we must select an unique template matching the rtype and config
    local   templates;
    if (!rtxLink_findTemplates(theRtype, templates))
    {
        traceLine("type_map<"+T+">:<ERROR> Could not find template associated to type "
                  + rtxRTypeName<theRtype.type>(theRtype));
        return false;
    }
    if (!rtxLink_selectUniqueTemplate(templates, source_tree.config))
    {
        traceLine("type_map<"+T+">:<ERROR> Could not select an unique template associated"
                  " to type " + rtxRTypeName<theRtype.type>(theRtype));
        return false;
    }

    if (getArraySize(mappedIds) > 1)
    {
        // Now that we have selected an unique template, load the tree+script
        local   subtree;
        rtxLink_LoadItem(templates, subtree);
        localref theMapping = subtree.mapping.body.block[mappedIds#[1]];

        // Call the right mapping function (based on hash + identifier mapped).
        traceLine("type_map<"+T+">:<LOG> type_map<" + T + ">: Calling mapping key : "
                  + theMapping.instanceKey);

        if (instanceMapping<theMapping.instanceKey>(resolverValues, subtree, source_tree) == false)
        {
            traceLine("type_map<"+T+">:<ERROR> instanceMapping<\""+theMapping.instanceKey+"\"> failed.");
            return false;
        }

        setall out_node = theMapping.body.expr;
    }
    else
    {
        // just conform to the called function's interface...
        local identifiers;
        foreach n in mappedIds { pushItem identifiers; rtxNodeIdentifier(identifiers#back, n); }
        //traceLine(BLUE + "Trying value mapping here..." +toString(resolverValues,true) + toString(identifiers,true)+ DEFAULT_COLOR);

        local val;
        if (rtxNodeResVal_GetField(resolverValues, identifiers, val) == false)
            error("Could not get value...");
        setall out_node = val;
    }

    return true;
}

// FIXME TODO XXX
// TO BE REMOVED WHEN PLACEHOLDER TYPECHECKING WILL BE ALRIGHT
function        rtxGetTypeFromVariableID<T>(out_type : node)
{ return false; }
function        rtxGetTypeFromVariableID<"local">(out_type : node)
{
    local id;
    local dummy;
    rtxNodeIdentifier(id, "local", "Builtin");
    rtxNodeRType(out_type, id, dummy);
    return true;
}
function        rtxGetTypeFromVariableID<"config">(out_type : node)
{
    local id;
    local dummy;
    rtxNodeIdentifier(id, "config", "Builtin");
    rtxNodeRType(out_type, id, dummy);
    return true;
}


// The builtin specializations.
function type_map<"Builtin::local">(resolverValues : node,
                                    theRtype : node, mappedIds : node,
                                    placeHolder : node, out_node : node, source_tree : reference)
{
    local data;
    localref theChunk = placeHolder#root;

    removeFirstElement(mappedIds); // remove the "local."
    if (!findElement(mappedIds#[0], theChunk.variables))
    {
        traceLine(RED + "[ERROR] Could not find local variable '" + mappedIds#[0] + "' in block." + DEFAULT_COLOR);
        return false;
    }

    localref theVar = theChunk.variables[mappedIds#[0]];
    if (getArraySize(mappedIds) == 1) // we're searching for a simple value/identifier
    {
            cnormNode_TerminalId(out_node, mappedIds#[0]);
    }
    else
    {
        if (theVar.type == "ctype") // the variable is a pure C type
        {
            error(BLUE + toString(theChunk.variables[mappedIds#[0]],true)+ DEFAULT_COLOR);
        }
        else if (theVar.type == "rtxtype")// the variable is a declared rathaxes type-> check for mapping
        {
            local rtype;
            setall rtype = theVar.type_node;
            local resVal;
            setall resVal = resolverValues;
            insert resVal["self"];
            rtxNodeResValLeaf(resVal["self"], mappedIds#[0]);
            return type_map<rtxRTypeName<rtype.type>(rtype)>(resVal, rtype, mappedIds, placeHolder, out_node, source_tree);
        }
        else
            return false;
    }

    return true;
}

// The builtin specializations.
function type_map<"Builtin::config">(resolverValues : node,
                                     theRtype : node, mappedIds : node,
                                     placeHolder : node, out_node : node, source_tree : reference)
{
    removeFirstElement(mappedIds); // remove the "config."
    foreach itf in source_tree.config
    {
        if (findElement(mappedIds#[0], itf))
        {
            local retval;
            if (existVariable(itf[mappedIds#[0]].val.rtype)) // then it's a rtx var...
            {
                return rtxNode2cnormNode<itf[mappedIds#[0]].type>(itf[mappedIds#[0]].val, out_node);
            }
            else if (itf[mappedIds#[0]].type == "__rtx_id__")
            {
                out_node = placeHolder.prefix + itf[mappedIds#[0]].val.name + placeHolder.sufix;
                return true;
            }
            else
            {
                traceLine(RED + "[Error] Unmanaged type in Builtin::config type_map<> function : '"+itf[mappedIds#[0]].type+"'");
            }
            traceLine(RED + "[Error] Cannot translate node of type '" + itf[mappedIds#[0]].type
                      + "' into a C value for config item replacement." + DEFAULT_COLOR);
            return false;
        }
    }
    return false;
}

// The builtin specializations.


#end
