#if !existFunction(rtxResolve_version)

function rtxResolve_version()
{ return "1.0"; }


/*
 * Those functions are generated by rtxGen
 */
declare function instanceChunk<T>(resVals : node, c_tree : node);
declare function instanceMapping<T>(resVals : node, c_tree : node);

/*
 * Those functions may be either generated by passes/back/rtxGen or written for a builtin.
 */
declare function type_map<T>(resolverValues : node, theRtype : node, mappedId : value, placeHolder : node);
declare function type_call<T>(resolverValues : node, chunkName : value, placeHolder : node);

// Injection functions
declare function inject<sNodeType>(resolverValues : node, treeNode   : node, local_node : node);
declare function inject_pointcut<T>(resolverValues : node, treeNode : node, local_node : node);

declare function isBuiltinVariable(varname : value);
declare function insertModifier(theBlock : node, thePointcut : node);
declare function rtxResolve_InsertCode(destBlock : node, startIdx : node, phName : value, phIdx : node, sourceNode : node);
declare function rtxResolve_insertTypeMap(theType : node);
declare function rtxResolve_InsertType(theDecl : node, typeDeclBlock : node);
declare function rtxResolve_BuildParameterResVals(src_resVals   : node, src_params    : node, dst_resVals   : node, dst_params    : node);
declare function rtxResolve_BuildFrontResVals(src_resVals   : node, src_params    : node, dst_resVals   : node, dst_params    : node);
declare function rtxResolve_replaceCall(theSeq : node, resolverValues : node);


/*
 *
 * Those two functions are the functions generated through passes/back/rtxGen
 *
 */
function	     instanceChunk<T>(resVals : node, c_tree : node)
{
	// If this cocde is called, there was a linking problem.
	error("instanceChunk: BAD LINK - Unkown registry value: " + T);
}

function instanceMapping<T>(resVals : node, c_tree : node)
{
    //If this code is called, there was a linking problem.
    error("instanceMapping: BAD LINK - Unkown registry value: "+T);
}


function isBuiltinVariable(varname : value)
{
    return (varname == "local" || varname == "config");
}

function insertModifier(theBlock : node, thePointcut : node)
{
    if (!existVariable(theBlock.modifier))
        insert theBlock.modifier = 0;
    thePointcut.block_idx = $thePointcut.block_idx + theBlock.modifier$;

    // Since removeElement uses the keys instead of indexes (what we store...), lets get an iterator at the right index.
    local iterator_id = thePointcut.block_idx;
    local   it;
    createIterator(it, theBlock);
    while (iterator_id != 0)
    {
        next(it);
        decrement(iterator_id);
    }
    removeElement(theBlock, key(it));
    decrement(theBlock.modifier);
}

/*
 *
 * Function that allow weaving ASTs by injecting the function definitions into
 * the global scope, and every other node in the block starting at the current
 * index.
 *
 * It is only used by a link resolution.
 *
 * XXX TODO FIXME
 * Should this function update the placeHolders' block_idx ?
 * I fear it may insert wrongly with many multiple inclusions for different
 * placholders in a same chunk of code.
 *
 */
function    rtxResolve_InsertCode(destBlock : node, startIdx : node,
                                  phName : value, phIdx : node,
                                  sourceNode : node)
{
    local modifier = $0$;
    local sKey;

    // Here, we are at the root of the resolved template AST.
    foreach item in sourceNode.block
    {
        sKey = phName + "_" + phIdx;

        insertElementAt(destBlock, sKey, startIdx);
        setall destBlock#[startIdx] = item;

        increment(startIdx);
        increment(phIdx);
        increment(modifier);
    }
    if (existVariable(destBlock.modifier))
        destBlock.modifier = $destBlock.modifier + modifier$;
}



function    rtxResolve_insertTypeMap(theType : node)
{
    localref    mapping = this.c_types;

    if (theType.ctype.storage != "typedef")
    {
        // Check the specifier is not already inserted (struct, union, etc...)
        if (!findElement(theType.ctype.specifier, mapping))
            insert mapping[theType.ctype.specifier];
        // Then it's already defined.
        if (findElement(theType.ctype.identifier, mapping[theType.ctype.specifier]))
            return;
        insert mapping[theType.ctype.specifier][theType.ctype.identifier];
        ref mapping = mapping[theType.ctype.specifier][theType.ctype.identifier];
    }
    else
    {
        // If it's already defined, then it's ok.
        if (findElement(theType.name, mapping))
            return;
        insert mapping[theType.name];
        ref mapping = mapping[theType.name];
    }

    // First, insert the type into the type map.
    insert mapping.c_decl;
    setall mapping.c_decl = theType;
    // Then, go through the types dependencies.
    insert mapping.deps;
    foreach subtype in theType.ctype.body.block
    {
        localref theCtype = subtype.ctype;
        if (theCtype.storage == "typedef")
        {
            if (!findElement(theCtype.name, mapping.deps))
                insert mapping.deps[theCtype.name];
        }
        else
        {
            if (!findElement(theCtype.specifier, mapping.deps))
                insert mapping.deps[theCtype.specifier];
            if (!findElement(theCtype.identifier, mapping.deps[theCtype.specifier]))
                insert mapping.deps[theCtype.specifier][theCtype.identifier];
        }
    }
    return;
}

/*
 * This function takes the node of the variable declaration as theDecl,
 * and the resolved chunk of the type's declaration as typeDeclBlock
 *
 * If the type declaration is a typedef, the typedef is inserted in the var decl
 * If the type declaration is not a typedef, the associated type replaces the type of the var decl.
 */
function    rtxResolve_InsertType(theDecl : node, typeDeclBlock : node)
{
    local typeDef;
    local typeDecl;
    // those booleans are a fucking workaround cause the isEmpty()
    // function doesn't seem to work as expected.
    local hasTypeDef = 0;
    local hasTypeDecl = 0;

    foreach decl in typeDeclBlock.block
    {
        if (decl.ctype.storage == "typedef")
        {
            ref typeDef = decl;
            hasTypeDef = 1;
        }
        else if (decl.ctype.storage == "auto") // not a typedef, then a simple decl
        {
            ref typeDecl = typeDeclBlock.block[key(decl)];
            hasTypeDecl = 1;
        }
    }
    if (hasTypeDef == 1)
    {
        // First, insert the type definition into a map of defined types.
        rtxResolve_insertTypeMap(typeDef);
        // Then, replace the type by the typedef if there's one
        theDecl.ctype.identifier = typeDef.name;
    }
    else if (hasTypeDecl)
    {
        // One variable or one structure -> insert the type into the type map.
        rtxResolve_insertTypeMap(typeDecl);
        // Now, set the type into the variable decl.
        theDecl.ctype.specifier = typeDecl.ctype.specifier;
        theDecl.ctype.identifier = typeDecl.ctype.identifier;
    }
    else
    {
        traceLine("rtxResolve_InsertType:<ERROR> Could not identify how to weave type !");
        return false;
    }
    return true;
}


/*
 *
 * Functions to manipulate the "ResolverValues", a hashtree of
 * values to be used in the resolution of a template.
 *
 */

/*
 * In this function, both params are rtx Var List Nodes
 *
 * The src_params and src_resVals are the caller's container's parameters and values.
 * The dst_params and dst_resVals are the params of the chunk we're calling and the values
 *      we have to set.
 */
function rtxResolve_BuildParameterResVals(src_resVals   : node,
                                          src_params    : node,
                                          dst_resVals   : node,
                                          dst_params    : node)
{
    local idx = $0$;
    local newValue;
    if (getArraySize(src_params.list) != getArraySize(dst_params.list))
    {
        traceLine(RED + "[Error] Wrong number of parameters given to the sequence (expected "+getArraySize(dst_params.list)
                  +", got "+getArraySize(src_params.list)+")." + DEFAULT_COLOR);
        return false;
    }

    foreach dst_param in dst_params.list
    {
        localref theValue = src_resVals;
        if (!existVariable(src_params.list) || !findElement(idx, src_params.list))
            traceLine(RED + "[Error] src_params do not contain the required field: "+toString(dst_param,true)+" in "+toString(src_params, true) + DEFAULT_COLOR);
        localref theParam = src_params.list#[idx];
        if (existVariable(theParam.identifiers))
        {
            foreach param_field in theParam.identifiers
            {
                if (!findElement(param_field.name, theValue))
                {
                    localref theChunk = src_params#root;
                    if (getArraySize(theParam.identifiers) != 1 || !findElement(param_field.name, theChunk.variables))
                    {
                        error("Could not find an element named " + param_field.name
                              + " in the source Resolver values or in the C variables.");
                    }
                    else // Element in chunk C variables.
                    {
                        ref theValue = theChunk.variables[param_field.name];
                    }
                }
                else // Element in previous resolver values.
                {
                    ref theValue = theValue[param_field.name];
                }
            }
        }
        else
        {
            // Then we're building a node leaf from another thing
            local translatedParam;
            if (!rtxNode2cnormNode<theParam.type>(theParam, translatedParam))
                error("Could not translate rathaxes node "
                      + toString(theParam, true) + " to cnorm node.");
            rtxNodeResValLeaf(newValue, translatedParam);
            ref theValue = newValue;
        }
        insert dst_resVals[dst_param.identifiers[0].name];
        setall dst_resVals[dst_param.identifiers[0].name] = theValue;
        increment(idx);
    }

    return true;
}


/*
 * This function is a clone of rtxResolve_BuildParameterResVals, instead it's specialized for
 * the calls from the front-end.
 */
function rtxResolve_BuildFrontResVals(src_resVals   : node,
                                      src_params    : node,
                                      dst_resVals   : node,
                                      dst_params    : node)
{
    local idx = $0$;
    local newValue;

    if (getArraySize(src_params) != getArraySize(dst_params))
    {
        traceLine(RED + "[Error] Wrong number of parameters given to the sequence (expected "+getArraySize(dst_params)
                  +", got "+getArraySize(src_params)+")." + DEFAULT_COLOR);
        return false;
    }

    foreach dst_param in dst_params
    {
        localref theValue = src_resVals;
        if (!existVariable(src_params) || !findElement(idx, src_params))
            traceLine(RED + "[Error] src_params do not contain the required field: "+toString(dst_param,true)+" in "+toString(src_params, true) + DEFAULT_COLOR);
        localref theParam = src_params[idx];
        if (existVariable(theParam.identifiers))
        {
            foreach param_field in theParam.identifiers
            {
                if (!findElement(param_field.name, theValue))
                {
                    localref theChunk = src_params#root;
                    if (existVariable(theChunk.variables) && (getArraySize(theParam.identifiers) != 1 || !findElement(param_field.name, theChunk.variables)))
                    {
                        error("Could not find an element named " + param_field.name
                              + " in the source Resolver values or in the C variables.");
                    }
                    else // Element in chunk C variables.
                    {
                        ref theValue = theChunk.variables[param_field.name];
                    }
                }
                else // Element in previous resolver values.
                {
                    ref theValue = theValue[param_field.name];
                }
            }
        }
        else
        {
            // Then we're building a node leaf from another thing
            local translatedParam;
            if (!rtxNode2cnormNode<theParam.type>(theParam, translatedParam))
                error("Could not translate rathaxes node "
                      + toString(theParam, true) + " to cnorm node.");
            rtxNodeResValLeaf(newValue, translatedParam);
            ref theValue = newValue;
        }
        insert dst_resVals[dst_param];
        setall dst_resVals[dst_param] = theValue;
        increment(idx);
    }

    return true;
}


/*
 * This function iterates over a sequence implementation (front end)
 * and replaces each sequence call by the associated chunk.
 * This function must be use before inserting the implementation into
 * the backend implem of the sequence.
 */
function rtxResolve_replaceCall(theSeq : node, resolverValues : node)
{
    local   errcount = 0;
    local   dummy;
    local   startIdx = 0;
    local   phName = "call";
    local   phIdx = 0;

    while (startIdx < getArraySize(theSeq.body.block))
    {
        localref call = theSeq.body.block#[startIdx];
        local   templateCache;
        local   chunkCache;
        local   chunkTree;
        if (!rtxLink_findTemplates(call.rtype, templateCache))
        {
            traceLine(RED + "[Error] Could not find template "
                      + "associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(call.rtype, dummy)
                      + DEFAULT_COLOR);
            return false;
        }
        if (!rtxLink_selectUniqueTemplate(templateCache, this.config))
        {
            traceLine(RED + "[Error] Could not select an unique template"
                      + " associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(call.rtype, dummy)
                      + DEFAULT_COLOR);
            return false;
        }
        if (!rtxLink_selectChunkFromTemplate(templateCache, "::CALL", chunkCache))
        {
            traceLine(RED + "[Error] Could not select chunk '::CALL'"
                      + " associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(call.rtype, dummy)
                      + DEFAULT_COLOR);
            return false;
        }

        // Now that we have selected the decl chunk, load the tree & script
        if (rtxLink_LoadItem(chunkCache, chunkTree) == false)
        {
            traceLine(RED + "[Error] Could not load script or tree."
                      + DEFAULT_COLOR);
            return false;
        }

        // Now, resolve the loaded chunk...
        local resVals;
        rtxResolve_BuildFrontResVals(resolverValues, call.args, resVals, chunkTree.tpl_params);
        if (instanceChunk<chunkTree.instanceKey>(resVals, chunkTree.body) == false)
        {
            increment(errcount);
        }

        // And insert it in the sequence implem after having removed the original call node.
        local dummy;
        insert dummy.block_idx;
        dummy.block_idx = $startIdx - theSeq.body.block.modifier$; // Compute current original index (alias the key).
        insertModifier(theSeq.body.block, dummy);
        startIdx = dummy.block_idx; // retrieve updated startIdx from dummy.
        rtxResolve_InsertCode(theSeq.body.block, startIdx, phName, phIdx, chunkTree.body);
    }
    return true;
}

/*
 *
 * resolverValues -> the hash mapping of values used in the template

        increment(startIdx);
 * treeNode -> the root of the __rtx_tpl__ node
 * local_node -> current node
 *
 */

function    inject<"">(resolverValues : node, treeNode : node,
                       local_node : node)
{
    // we should NEVER fallback here.
    error("inject: BAD NODE - Empty Template Node Type !");
}

function    inject<sNodeType>(resolverValues : node, treeNode   : node,
                              local_node : node)
{
    // we should NEVER fallback here.
    error("inject: BAD NODE - Unknown Template Node Type : "+sNodeType);
}

function    inject<"__rtx_tpl_placeHolder__">(resolverValues    : node,
                                              treeNode          : node,
                                              local_node        : node)
{
    //traceLine("Injecting into placeHolder : realType = "+treeNode.body.type);
    return inject<local_node.body.type>(resolverValues, treeNode, local_node);
}

/*
 * resolverValues : hashtable of key/values
 *
 * Both treeNode and local_node are located in the .compile of a chunk
 * They are located as is :
 * treeNode is still undefined.
 *  .compile = {
 *      [
 *          "_X" : {
 *              .node = {
 *                  .body = {   <-- local_node
 *                  }
 *              }
 *              ...
 *          }
 *      ]
 *  }
 */
function    inject<"__rtx_var__">(resolverValues : node, treeNode : node,
                                      local_node : node)
{
    //traceLine("Injecting into var : "+toString(local_node));
    local curCtxNode;

    traceLine("inject<\"__rtx_var__\">:<LOG> Injecting code into placeHolder "+local_node#parent.template_expr);
    /*
     *
     * This block of code has for role to check wether we're manipulating
     * a rathaxes type or a variable of a rathaxes type.
     *
     * Here we can manage the access to a mapped identifier in a type
     * We need to build the ResVal for the "${self}" placeHolder of the var.
     *
     */
    //    local_node <=> with.c_block.compile[X].node
    // or local_node <=> chunk.body.compile[X].node
    // or local_node <=> chunk.body.compile[X].node
    localref theChunk = local_node#parent#parent#parent#parent;
    localref varName = local_node.body.identifiers[0].name;
    // First, check that there is not prefix or suffix.
    if (isEmpty(local_node.prefix) && isEmpty(local_node.suffix))
    {
        // TODO FIXME XXX FIME TODO          A
        // TODO FIXME XXX FIME TODO         / \
        // TODO FIXME XXX FIME TODO        / | \
        // TODO FIXME XXX FIME TODO       /  .  \
        // TODO FIXME XXX FIME TODO      /_______\

        // identify if it's a type declaration (i.e. "${Builtin::Buffer} buf;")
        if (local_node#parent.weave_type == "__weave_type_id__")
        {
            traceLine("inject<\"__rtx_var__\">:<LOG> Injecting a type name.");
            // first, retrieve the name of the variable associated to the type or pointer
            localref theDecl = local_node#parent.ref_placeholder#parent#parent;
            while (!existVariable(theDecl.name) && theDecl.type == "__decl__")
            { ref theDecl = theDecl#parent#parent; }
            local   varName = theDecl.name;
            // go back to theDecl where we replace an identifier.
            ref theDecl = local_node#parent.ref_placeholder#parent#parent;
            local   theRtype;
            setall theRtype = theChunk.type_map[varName];
            // First we must select an unique template matching the rtype and config
            local   templates;
            local   declChunk;
            if (!rtxLink_findTemplates(theRtype, templates))
            {
                traceLine("inject<\"__rtx_var__\">:<ERROR> Could not find template "
                          + "associated to type "
                          + rtxRTypeName<theRtype.type>(theRtype));
                return false;
            }
            if (!rtxLink_selectUniqueTemplate(templates, this.config))
            {
                traceLine("inject<\"__rtx_var__\">:<ERROR> Could not select an unique template"
                          + " associated to type "
                          + rtxRTypeName<theRtype.type>(theRtype));
                return false;
            }
            if (!rtxLink_selectChunkFromTemplate(templates, "::decl", declChunk))
            {
                traceLine("inject<\"__rtx_var__\">:<ERROR> Could not select chunk '::decl'"
                          + " associated to type "
                          + rtxRTypeName<theRtype.type>(theRtype));
                return false;
            }

            // Now that we have selected the decl chunk, load the tree & script
            local   subtree;
            rtxLink_LoadItem(declChunk, subtree);

            if (rtxResolve_InsertType(theDecl, subtree.body) == false)
                return false;

            return true;
        }
        // If not, is it a variable of a rathaxes type : check in type_map ?
        else if (existVariable(theChunk.type_map)
                 && findElement(varName, theChunk.type_map))
        {
            traceLine("inject<\"__rtx_var__\">:<LOG> Injecting a type mapping.");
            // Create the resolvervalues for the type resolution:
            // This should not need any more than config and var's identifier.
            local resVal;
            setall resVal = resolverValues;
            insert resVal["self"];
            rtxNodeResValLeaf(resVal["self"], varName);

            local qTypeName = rtxRTypeName<theChunk.type_map[varName].type>(
                                    theChunk.type_map[varName]
                                );

            return type_map<qTypeName>(resVal, theChunk.type_map[varName],
                                       local_node.body.identifiers[1].name,
                                       local_node);

        }
        else if (isBuiltinVariable(varName))
        {
            local dummyResVal;
            local dummyRtype;
            return type_map<"::"+varName>(dummyResVal, dummyRtype,
                                          local_node.body.identifiers[1].name, local_node);
        }


        // If both of the conditionis weren't entered, then that means that
        // it is a simple value weaving, and the next part takes care of it.
    }
    if (local_node#parent.ref_placeholder#parent.ctype.storage == "typedef")
    {
        local_node#parent.ref_placeholder = "TARTE";
        return true;
    }
    traceLine("inject<\"__rtx_var__\">:<LOG> Could not find any type manipulation for injection.");
    if (local_node#parent.ref_placeholder#parent.ctype.storage == "typedef")
    {
        local_node#parent.ref_placeholder = "TARTE";
        return true;
    }


    /*
     *
     * This block of code means to replace the placeHolder by a simple
     * identifier in the code. (May be used for the self resolution)
     *
     */
    local fieldValue;
    local finalNode;
    rtxNodeResVal_GetField(resolverValues, local_node.body.identifiers,
                           fieldValue);
    // The ResValLeaf is a whole node : setall it into the placeholder's parent
    if (existVariable(fieldValue.type))
    {
        traceLine("inject<\"__rtx_var__\">:<LOG> Replacing identifier : "+toString(local_node.body.identifiers));
        localref theId = local_node#parent.ref_placeholder;
        //traceLine("So we have the resolver placeholders parent : "+toString(local_node#parent.ref_placeholder#parent#parent, true));
        setall theId#parent = fieldValue;
        //traceLine("So we have the resolver placeholders parent resolved : "+toString(local_node#parent.ref_placeholder#parent#parent, true));
    }
    else
    {
        traceLine("inject<\"__rtx_var__\">:<LOG> Concatenating identifier : "+toString(local_node.body.identifiers));
        // First concat prefix
        finalNode = finalNode + local_node.prefix;
        // Next resolve the value and concat it
        finalNode = finalNode + fieldValue;
        // Finally, concat suffix
        finalNode = finalNode + local_node.sufix;
        local_node#parent.ref_placeholder = finalNode;
    }
    return true;
}

/*
 * resolverValues : hashtable of key/values
 *
 * Both treeNode and local_node are located in the .compile of a chunk
 * They are located as is :
 * treeNode is still undefined.
 *  .compile = {
 *      [
 *          "_X" : {
 *              .node = {
 *                  .body = {   <-- local_node
 *                  }
 *              }
 *              ...
 *          }
 *      ]
 *  }
 */
function    inject<"__rtx_tpl_sequence_call__">(resolverValues : node, treeNode : node,
                                                local_node : node)
{
    // Tool variable for code replacing.
    local       errcount = 0;
    local       dummy;
    local       startIdx = 0;
    local       phName = "call";
    local       phIdx = 0;
    localref    theBlock = local_node#parent.ref_placeholder#parent;
    while (theBlock.type != "__block__")
    {
        ref theBlock = theBlock#parent;
    }

    // Two variables to create the rtype associated to the sequence call
    local       theRtype;
    local       paramTypes;

    // Tree variables to help manipulate the cache
    local       templateCache;
    local       chunkCache;
    local       chunkTree;

    // First, build the rtype node.
    rtxNodeRType(theRtype, local_node.body.seqName, paramTypes);
    foreach param in local_node.body.seqArgs
    {
        if (existVariable(param.rtype))
        {
            pushItem paramTypes;
            setall paramTypes#back = param.rtype;
        }
        else
        {
            traceLine(RED + "[Error] Could not find rtx type associated to param '"+param.val
                      +"' for sequence call '"+local_node#parent.template_expr+"'." + DEFAULT_COLOR);
        }
    }

    // Then load the chunk ::CALL to resolve.
    if (!rtxLink_findTemplates(theRtype, templateCache))
    {
        traceLine(RED + "[Error] Could not find template "
                  + "associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(theRtype, dummy)
                  + DEFAULT_COLOR);
        return false;
    }
    if (!rtxLink_selectUniqueTemplate(templateCache, this.config))
    {
        traceLine(RED + "[Error] Could not select an unique template"
                  + " associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(theRtype, dummy)
                  + DEFAULT_COLOR);
        return false;
    }
    if (!rtxLink_selectChunkFromTemplate(templateCache, "::CALL", chunkCache))
    {
        traceLine(RED + "[Error] Could not find '::CALL' chunk"
                  + " associated to sequence " + rtxRTypeFullQualifiedName<"sequence">(theRtype, dummy)
                  + DEFAULT_COLOR);
        return false;
    }

    // Now that we have selected the decl chunk, load the tree & script
    if (rtxLink_LoadItem(chunkCache, chunkTree) == false)
    {
        traceLine(RED + "[Error] Could not load script or tree."
                  + DEFAULT_COLOR);
        return false;
    }

    // Now, resolve the loaded chunk...
    local resVals;
    rtxResolve_BuildFrontResVals(resolverValues, local_node.body.seqArgs, resVals, chunkTree.tpl_params);
    if (instanceChunk<chunkTree.instanceKey>(resVals, chunkTree.body) == false)
    {
        increment(errcount);
    }
    // And insert it in the sequence implem after having removed the original call node.
    local dummy;
    insert dummy.block_idx;
    dummy.block_idx = $startIdx - theBlock.block.modifier$; // Compute current original index (alias the key).
    insertModifier(theBlock.block, dummy);
    startIdx = dummy.block_idx; // retrieve updated startIdx from dummy.
    rtxResolve_InsertCode(theBlock.block, startIdx, phName, phIdx, chunkTree.body);

    return true;
}


/*
 * The default case of the function inject_pointcut will resolve a "normal"
 * pointcut: insert every chunk in place of the said pointcut.
 *
 * The specializations are meant to be the builtin pointcuts resolution.
 */
function inject_pointcut<T>(resolverValues : node, treeNode : node,
                                    local_node : node)
{
    localref theBlock = local_node#parent.ref_placeholder#parent#parent;
    localref thePointcut = local_node#parent;
    local pointcutName = rtxRTypeName<local_node.body.name.type>(local_node.body.name);
    // Variables for the node replacement
    local phName = thePointcut.ref_placeholder#parent.id;
    local phIdx = 0;
    local startIdx = 0;
    // cache-related variable
    local   chunks;
    local   errcount = 0;

    // First, search every chunk associated to the pointcut...
    if (rtxLink_findChunks(local_node.body.name, chunks) == false)
        traceLine("inject_pointcut<\""+T+"\">:<WARN> No chunk associated with"
                  +" the pointcut "
                  + pointcutName);

    // If we cannot find any chunk, let's use default behaviour (if there's one)
    if (isEmpty(chunks)
        || rtxLink_selectCompatibleChunks(chunks, this.config) == false)
    {
        traceLine("inject_pointcut<\""+T+"\">:<WARN> No valid chunk,"
                  +" falling back to default behaviour.");
        // If there's a default block inside the poincut, then insert it
        // instead of the resolved chunks : one setall is enough
        // to both remove the pointcut and insert the code.
        if (existVariable(local_node.body.default.body))
        {
            if (theBlock#parent.type == "__block__")
            {
                if (getArraySize(theBlock) <= thePointcut.block_idx)
                {
                    error(RED+ "Trying to get index " + thePointcut.block_idx + " into block " +
                          toString(theBlock,true) +DEFAULT_COLOR);
                }
                setall theBlock#[thePointcut.block_idx] = local_node.body.default.body;
            }
            else if (theBlock.type == "__stmt__" && theBlock.stmt_type == "__expr__"
                     && theBlock.expr.expr_type == "__terminal__")
            {
                setall theBlock = local_node.body.default.body;
            }
            else
                error("Node type not supported for default resolution..");
        }
        else
        {
            if (theBlock.type == "__block__")
            {
                // removes the current placeHolder and inserts the modifier
                insertModifier(theBlock, thePointcut);
            }
            else if (theBlock#parent.type == "__block__")
            {
                // removes the current placeHolder and inserts the modifier
                insertModifier(theBlock, thePointcut);
            }
        }
    }
    // There are some chunks left, so it's up to us to resolve them
    // and then insert them in-place of the pointcut.
    else
    {
        // make sure it's the block.
        while (theBlock.type != "__block__")
            ref theBlock = theBlock#parent;
        ref theBlock = theBlock.block;
        // First, remove the current placeHolder, in case there was no statement
        insertModifier(theBlock, thePointcut);
        startIdx = thePointcut.block_idx;
        foreach chunk in chunks
        {
            local c_tree;
            if (rtxLink_LoadItem(chunk, c_tree) == false)
            {
                traceLine("inject_pointcut<\""+T+"\">:<ERROR> Could not "
                          +"load script for one chunk for pointcut "+pointcutName+".");
                increment(errcount);
            }
            local resVals;
            if (rtxResolve_BuildParameterResVals(resolverValues,
                                                 local_node.body.parameters,
                                                 resVals, c_tree.parameters) == false)
            {
                traceLine(RED + "[Error] Wrong parameters given to pointcut '" + pointcutName + "'." + DEFAULT_COLOR);
                return false;
            }

            if (instanceChunk<c_tree.instanceKey>(resVals, c_tree.body) != false)
                rtxResolve_InsertCode(theBlock, startIdx, phName, phIdx, c_tree.body);
            else
            {
                traceLine("inject_pointcut<\""+T+"\">:<ERROR> Could not instanciate chunk '"+c_tree.instanceKey+"'.");
                increment(errcount);
            }
        }
        if (errcount != 0)
            return false;
    }
    return true;
}

function inject_pointcut<"::IMPLEMENTATION">(resolverValues : node, treeNode : node,
                                             local_node : node)
{
    localref theBlock = local_node#parent.ref_placeholder#parent;
    // Make sure TheBlock references the parent block (should always be the case for this kind of pointcut).
    while (theBlock.type != "__block__")
    {
        ref theBlock = theBlock#parent;
    }
    ref theBlock = theBlock.block;

    localref thePointcut = local_node#parent;
    // Some variables for the InsertCode function
    local phName = thePointcut.ref_placeholder#parent.id;
    local phIdx = 0;
    local startIdx = 0;
    local dummy;

    // Find the right impl to include from the front by walking
    // through the front tree and checking the tpl against the chunk's hash.
    foreach item in this.front.block
    {
        if (item.type == "__rtx_device__")
        {
            foreach decl in item.body.block
            {
                if (decl.type == "__rtx_sequence__"
                    && rtxRTypeFullQualifiedName<"sequence">(decl.rtype, dummy) == local_node#parent.tpl_hash)
                {
                    // Then replace each Tpl CALL by the CALL chunks associated.
                    if (rtxResolve_replaceCall(decl, resolverValues) == false)
                    {
                        traceLine(YELLOW + "Could not resolve ::IMPLEMENTATION pointcut for template '" + local_node#parent.tpl_hash + "'."+ DEFAULT_COLOR);
                        return false;
                    }

                    //traceLine(BLUE + "[Debug] Resolved implementation:"+toString(decl.body, true));

                    // Finally, insert the block in-place of the placeHolder.
                    insertModifier(theBlock, thePointcut);
                    startIdx = thePointcut.block_idx; // updated block_idx prevents "index out of bounds"
                    rtxResolve_InsertCode(theBlock, startIdx, phName, phIdx, decl.body);

                    return true;
                }
            }
        }
    }
    traceLine(YELLOW + "Could not resolve ::IMPLEMENTATION pointcut for template " + local_node#parent.tpl_hash + DEFAULT_COLOR);
    return false;
}

/*
 *
 * This function takes a resolver value node, the tree node in which
 * the resolution is needed, and the local_node which is the placeHolder to
 * resolve.
 *
 * This specialization takes care of the resolution of a pointcut, and manages
 * builtin pointcuts (like the ::algo pointcut for required/optional templates).
 *
 */
function    inject<"__rtx_pointcut__">(resolverValues   : node,
                                       treeNode         : node,
                                       local_node       : node)
{
    local ptcutName = rtxRTypeName<local_node.body.name.type>(local_node.body.name);

    if (local_node.body.name.scope == "" && local_node.body.name.global == false)
    {
        error("inject<\"__rtx_pointcut__\">:<ERROR> An unexpected error occurred:"
              + " Unknown scope to poincut " + ptcutName + ".");
    }

    return inject_pointcut<ptcutName>(resolverValues, treeNode, local_node);
}

//function    inject<"__rtx_tpl_chunk_call__">(resolverValues : node,
//                                             treeNode : node,
//                                             local_node : node)
//{
//}

/*
 *
 * This function is used to resolve an explicit call to a chunk
 * contained in a type template.
 * This model allows easy builtin implementations.
 *
 */
function    type_call<T>(resolverValues : node,
                         chunkName : value,
                         placeHolder : node)
{
    local   templates;
    local   theChunk;
    localref theRtype = placeHolder.body.rtype;
    local   startIdx;

    if (!rtxLink_findTemplates(theRtype, templates))
    {
        traceLine("type_call<"+T+">: Could not find template.");
        return false;
    }
    if (!rtxLink_selectUniqueTemplate(templates, this.config))
    {
        traceLine("type_call<"+T+">: Could not select an unique template.");
        return false;
    }
    if (!rtxLink_selectChunkFromTemplate(templates, chunkName, theChunk))
    {
        traceLine("type_call<"+T+">: Could not select chunk '" + chunkName + "'.");
        return false;
    }

    // Now that we have selected the decl chunk, load the tree & script
    local   subtree;
    rtxLink_LoadItem(theChunk, subtree);

    // To actually resolve this, we need :
    //  * Current resolverValues (OK)
    //  * The parameters to the chunk (TBD) FIXME XXX TODO
    //
    local resVals;
    //insert resVals["global"];
    //setall resVals["global"] = resolverValues["global"];
    // Now add the "self" to the resVals
    insert resVals["self"];
    rtxNodeResValLeaf(resVals["self"], placeHolder.body.var.name);
    // Then add the call (chunk's) parameters to the resval.
    rtxResolve_BuildParameterResVals(resolverValues, placeHolder.body.parameters,
                                     resVals, subtree.parameters);

    traceLine("type_call<"+T+">:<LOG> Resolving chunk " + chunkName + "... ");
    if (instanceChunk<subtree.instanceKey>(resVals, subtree.body) == false)
    {
        traceLine("type_call<\""+T+"\">:<ERROR> Could not instance Chunk '"+subtree.instanceKey+"'.");
        return false;
    }

    // Now, insert the subtree in place of the placeHolder !
    // placeHolder actually is : block.[idx].expr.id, so unwind until theBlock.type != "__block__".
    localref theBlock = placeHolder#parent.ref_placeholder;
    do { ref theBlock = theBlock#parent; } while (theBlock.type != "__block__");
    localref theCall = placeHolder#parent;
    local phIdx = 0;
    // First, remove the current placeHolder, in case there was no statement
    insertModifier(theBlock.block, theCall);
    startIdx = theCall.block_idx;
    rtxResolve_InsertCode(theBlock.block, startIdx,
                          theCall.ref_placeholder, phIdx, subtree.body);

    traceLine("type_call<"+T+">:<LOG> Resolved call to chunk " + chunkName + "...");
    return true;
}


/*
 * The functions that resolve a type mapping.
 */

// Builtin functions for type mapping
declare function instanceMapping<T>(resVals : node, c_tree : node);

/*
 * The function to call when encountering a type mapping...
 *
 * resolverValues : hashtable of values for placeHolder resolution
 * theRtype       : a __rtx_rtype__ node  matching the template's type
 * mappedId       : the identifier used in the mapping call
 * local_node     : the mapping's placeHolder .node
 */
function type_map<T>(resolverValues : node,
                     theRtype : node, mappedId : value,
                     placeHolder : node)
{
    traceLine("rtxResolve:<LOG> type_map<"+T+"> for identifier '"+mappedId+"'");
    // First we must select an unique template matching the rtype and config
    local   templates;
    if (!rtxLink_findTemplates(theRtype, templates))
    {
        traceLine("type_map<"+T+">:<ERROR> Could not find template associated to type "
                  + rtxRTypeName<theRtype.type>(theRtype));
        return false;
    }
    if (!rtxLink_selectUniqueTemplate(templates, this.config))
    {
        traceLine("type_map<"+T+">:<ERROR> Could not select an unique template associated"
                  " to type " + rtxRTypeName<theRtype.type>(theRtype));
        return false;
    }

    // Now that we have selected an unique template, load the tree+script
    local   subtree;
    rtxLink_LoadItem(templates, subtree);
    localref theMapping = subtree.mapping.body.block[mappedId];

    // Call the right mapping function (based on hash + identifier mapped).
    traceLine("type_map<"+T+">:<LOG> type_map<" + T + ">: Calling mapping key : "
              + subtree.mapping.body.block[mappedId].instanceKey);

    if (instanceMapping<theMapping.instanceKey>(resolverValues, subtree) == false)
    {
        traceLine("type_map<"+T+">:<ERROR> instanceMapping<\""+theMapping.instanceKey+"\"> failed.");
        return false;
    }

    // Here, the interesting thing to replace is the id's parent.
    localref theNode = placeHolder#parent.ref_placeholder#parent;
    if (theNode.type == "__expr__")
    {
        setall theNode = theMapping.body.expr;
    }
    else
    {
        traceLine("type_map<"+T+">:<ERROR>: type_map<" + T + ">: Weaving for node of type '"
                  + theNode.type + "' not implemented.");
        return false;
    }

    return true;
}

// The builtin specializations.
function type_map<"::local">(resolverValues : node,
                             theRtype : node, mappedId : value,
                             placeHolder : node)
{
    error(RED + "Builtin '::local' functions not implemented yet." + DEFAULT_COLOR);
}

// The builtin specializations.
function type_map<"::config">(resolverValues : node,
                             theRtype : node, mappedId : value,
                             placeHolder : node)
{
    foreach itf in this.config
    {
        if (findElement(mappedId, itf))
        {
            local retval;
            if (itf[mappedId].type == "__rtx_cstring__")
            {
                retval = itf[mappedId].val.val;
                // Ok for a terminal literal
                if (placeHolder#parent.ref_placeholder#parent.type == "__expr__"
                    && placeHolder#parent.ref_placeholder#parent.expr_type == "__terminal__")
                    setall placeHolder#parent.ref_placeholder#parent.id = retval;
                else
                    error("Placeholder type not supported.");

                return true;
            }
            else if (itf[mappedId].type == "__rtx_id__")
            {
                retval = placeHolder.prefix + itf[mappedId].val.name + placeHolder.sufix;
                // Ok for a terminal id
                if (placeHolder#parent.ref_placeholder#parent.type == "__expr__"
                    && placeHolder#parent.ref_placeholder#parent.expr_type == "__terminal__")
                    setall placeHolder#parent.ref_placeholder#parent.id = retval;
                // Ok for a decl
                else if (placeHolder#parent.ref_placeholder#parent.type == "__decl__")
                    setall placeHolder#parent.ref_placeholder#parent.name = retval;
                else
                    error("Placeholder type not supported.");

                return true;
            }
            else
            {
                local cNode;
                if (rtxNode2cnormNode<itf[mappedId].type>(itf[mappedId].val, cNode) == true)
                {
                    // Now that we have the C node, we can replace in the c tree.
                    setall placeHolder#parent.ref_placeholder#parent = cNode;
                    return true;
                }
                
            }
            traceLine(RED + "[Error] Cannot translate node of type '" + itf[mappedId].type
                      + "' into a C value for config item replacement." + DEFAULT_COLOR);
            return false;
        }
    }
    return false;
}

// The builtin specializations.


#end
