#if !existFunction(rtxResolve_version)

function rtxResolve_version()
{ return "1.0"; }

#include "rtxResolve_TypeReordering.inc.cws"


/*
 * Those functions are generated by rtxGen
 */
declare function instanceChunk<T>(resVals : node, c_tree : node, source_tree : reference);
declare function instanceMapping<T>(resVals : node, c_tree : node, source_tree : reference);

/*
 * Those functions may be either generated by passes/back/rtxGen or written for a builtin.
 *
 * The type_map function should usually receive an array containing at most one identifier.
 * The arrays containing two identifiers are either local variables ( ${local.buf.sz} )
 * or erroneous variables.... (never planned on supporting multiple nested types : ${local.array.memory.test()} )
 */
declare function type_map<T>(resolverValues : node, theRtype : node, mappedIds : node, placeHolder : node, out_node : node, source_tree : reference);
declare function type_call<T>(resolverValues : node, methodProto : value, placeHolder : node, source_tree : reference);

// Injection functions
declare function inject<sNodeType>(resolverValues : node, treeNode : node, local_node : node, source_tree : reference);
declare function inject_pointcut<T>(resolverValues : node, treeNode : node, local_node : node, source_tree : reference);

declare function isBuiltinVariable(varname : value);
declare function insertModifier(theBlock : node, thePointcut : node);
declare function rtxResolve_MangleTypeName(theRtype : node, is_pointer : value);
declare function rtxResolve_RefScalarTranscribe(expr : node, in_type : value, out_type : value);
declare function rtxResolve_WrapChunkIntoType(chunkTree : node);

declare function rtxResolve_InsertCode(destBlock : node, startIdx : node, phName : value, phIdx : node, sourceNode : node);
declare function rtxResolve_BuildParameterResVals(src_resVals   : node, src_params    : node, dst_resVals   : node, dst_params    : node, source_tree   : reference, search_chunk  : value = true, tpl_seq : value = false);
declare function rtxResolve_replaceCalls(theSeq : node, resolverValues : node, source_tree : reference);


// TODO FIXME XXX WORKAROUND TO BE REMOVED.
declare function rtxGetTypeFromVariableID<T>(out_type : node);



/*
 *
 * Those two functions are the functions generated through passes/back/rtxGen
 *
 */
function	     instanceChunk<T>(resVals : node, c_tree : node, source_tree : reference)
{
	// If this cocde is called, there was a linking problem.
	error("instanceChunk: BAD LINK - Unkown registry value: " + T);
}

function instanceMapping<T>(resVals : node, c_tree : node, source_tree : reference)
{
    //If this code is called, there was a linking problem.
    error("instanceMapping: BAD LINK - Unkown registry value: "+T);
}


function isBuiltinVariable(varname : value)
{
    return (varname == "local" || varname == "config");
}

function insertModifier(theBlock : node, thePointcut : node)
{
    if (!existVariable(theBlock.modifier))
        insert theBlock.modifier = 0;
    thePointcut.block_idx = $thePointcut.block_idx + theBlock.modifier$;

    removeVariable(theBlock#[$thePointcut.block_idx$]);
    decrement(theBlock.modifier);
}

// Mangles a Rtx Type into a name for a C typedef (either pointer or not)
function rtxResolve_MangleTypeName(theRtype : node, is_pointer : value)
{
    local name;
    
    name = "rtxType_" + theRtype.name.scope + "_" + theRtype.name.name;
    if (is_pointer)
        name = name + "_ptr";

    return name;
}

function rtxResolve_WrapChunkIntoType(chunkTree : node)
{
    localref theRtype = chunkTree#parent.tpl_rtype;
    local typedef_name = rtxResolve_MangleTypeName(theRtype, false);
    local typedef_name_ptr = rtxResolve_MangleTypeName(theRtype, true);
    // Data to craft the block with both typedefs
    local dst_block;
    local decl;
    local ctype;
    // Then, it's a composed Type that we want (struct)
    if (chunkTree#parent.decl_type == "block")
    {
        slideNodeContent(chunkTree, ctype.body);
        insert chunkTree.type = "__decl__";
        insert chunkTree.name = typedef_name;
        // type of the node ... it's a ctype
        insert chunkTree.ctype.type = "__ctype__";
        // type of cdecl ... (primary,composed)
        insert chunkTree.ctype.cdecl_type = "__composed__"; // We're defining a struct -> composed
        // only one storage class by decl (auto,register,typedef,static,extern)
        insert chunkTree.ctype.storage = "typedef"; // Enforce typedef
        // only one qualifier by decl (auto, const, volatile,restrict)
        insert chunkTree.ctype.qualifier = "auto";
        // only one specifier by decl (auto,inline,dll*,struct,enum,union,long,short)
        insert chunkTree.ctype.specifier = "struct"; // defining a struct by default
        // only one funspecifier by decl (auto,inline, and in C++ virtual,explicit)
        insert chunkTree.ctype.funspecifier = "auto";
        // only one identifier by decl (char,int,float,double,void,typedefname, struct/union/enum/name)
        insert chunkTree.ctype.identifier = "";

        insert chunkTree.ctype.body.map;
        foreach field in chunkTree.ctype.body.block
        {
            insert chunkTree.ctype.body.map[field.name] = key(field);
        }

        // Now, craft the block to wrap the typedefs
        cnormNodeBlock(dst_block);
        // Copy the original type decl
        cnormNodeBlock_AddNode(dst_block);
        cnormNodeBlock_GetLastNode(dst_block, decl);
        setall decl = chunkTree;
        setall chunkTree = dst_block;
    }
    // Otherwise it should be an enum's values enumeration list
    else if (chunkTree#parent.decl_type == "enum")
    {
        // The body is currently a ctype defining the values of the enum..
        chunkTree.block#front.ctype.storage = "typedef";
        insert chunkTree.block#front.name = typedef_name;
    }
    else
        error(RED + "[Error] Cannot identify how to generate type for node of type '" + chunkTree#parent.decl_type + "'" + DEFAULT_COLOR);


    // Add the typedef for the reference rtxType
    cnormNodeBlock_AddNode(chunkTree);
    cnormNodeBlock_GetLastNode(chunkTree, decl);
    cnormNodeDecl(decl);
    cnormNodeDecl_GetCtype(decl, ctype);
    ctype.storage = "typedef";
    ctype.identifier = typedef_name;
    cnormNodeDecl_AddRef(decl);
    cnormNodeDecl_SetName(decl, typedef_name_ptr);

//  local code_to_insert = "typedef " + typedef_name + " * " + typedef_name_ptr + ";";
//  if (cnormPatchGlobalDeclaration(last_node, code_to_insert, "__unstrict__") == false || existVariable(last_node.error))
//  {
//      traceLine(RED + "[Error] Could not Generate type's ref typedef: '" + code_to_insert+ "'." + DEFAULT_COLOR);
//      return false;
//  }

    return true;
}

/*
 * This function modifies an expression to suit the needed expression:
 * On a variable of the same type, it can transcribe an expression from ref to scalar and vis versa.
 */
function rtxResolve_RefScalarTranscribe(expr : node, in_type : value, out_type : value)
{
    local op = "";
    local do_wrap = 0;

    // First, normalize the "ref" and "pointer" as "pointer.
    if (in_type == "ref")
        in_type = "pointer";
    if (out_type == "ref")
        out_type = "pointer";

    // Then, check if we need any changes or not for the out_type
    if (out_type == "copy") // Copy means that we keep the current state, whether pointer or scalar.
        return true;

    // make sure in and out types are either scalar or ref
    if ((in_type != "scalar" && in_type != "pointer")
        || (out_type != "scalar" && out_type != "pointer"))
        error(RED + "[Error] In_type or Out_type are neither scalar nor ref: in='"
              + in_type + "', and out='" + out_type + "'." + DEFAULT_COLOR);

    // Make sure we're manipulating an expr
    if (expr.type != "__expr__")
        error(RED + "[Error] Node to transcribe is NOT an expression." + DEFAULT_COLOR);

    if (in_type == out_type)
        return true;

    if (in_type == "scalar")
    {
        op = '&';
        // If expr is not an unary &, wrap into it; otherwise we'll remove the unary outer layer.
        if (expr.expr_type != "__unary__" || expr.op != '&')
            do_wrap = 1;
    }
    else
    {
        op = '*';
        // If expr is not an unary *, wrap into it; otherwise we'll remove the unary outer layer.
        if (expr.expr_type != "__unary__" || expr.op != '*')
            do_wrap = 1;
    }

    // It was determined that the expression is to be wrapped within an unary expr.
    if (do_wrap)
    {
        slideNodeContent(expr, right);
        insert expr.operator = op;
        insert expr.type = "__expr__";
        insert expr.expr_type = "__unary__";
    }
    // Or we can shrug off the useless outer layer of unary exprs
    else
    {
        local temp;
        setall temp = expr.right;
        setall expr = temp;
    }
    
    return true;
}

/*
 *
 * Function that allow weaving ASTs by injecting the function definitions into
 * the global scope, and every other node in the block starting at the current
 * index.
 *
 * It is only used by a link resolution.
 *
 * XXX TODO FIXME
 * Should this function update the placeHolders' block_idx ?
 * I fear it may insert wrongly with many multiple inclusions for different
 * placholders in a same chunk of code.
 *
 */
function    rtxResolve_InsertCode(destBlock : node, startIdx : node,
                                  phName : value, phIdx : node,
                                  sourceNode : node)
{
    local modifier = $0$;
    local sKey;

    // Here, we are at the root of the resolved template AST.
    foreach item in sourceNode.block
    {
        sKey = phName + "_" + phIdx;

        insertElementAt(destBlock, sKey, startIdx);
        setall destBlock#[startIdx] = item;

        increment(startIdx);
        increment(phIdx);
        increment(modifier);
    }
    if (existVariable(destBlock.modifier))
        destBlock.modifier = $destBlock.modifier + modifier$;
}

/*
 *
 * Functions to manipulate the "ResolverValues", a hashtree of
 * values to be used in the resolution of a template.
 *
 */
/*
 * Tool function which builds the "self" for a Builtin::Local variable.
 */
function rtxResolve_BuildLocalSelf(resVals : node, theChunk : node, placeHolder : node,
                                   identifiers : node)
{
    local arg_rtype;
    local arg_value;

    // Retrieve argument actual type and value from the chunk first.
    if (identifiers#[0] != "local")
    {
        error(RED + "[Error] Trying to access chunk's local variable '"
              + identifiers#[0] + "' without the use of the 'local' prefix at "
              + placeHolder#parent.location + DEFAULT_COLOR);
    }
    local varName = identifiers#[1];
    if (!existVariable(theChunk.variables[varName]))
    {
        error(RED + "[Error] Unknown local variable '" + varName + "'" + endl()
              + "[Error]   at location " + placeHolder#parent.location + "." + DEFAULT_COLOR);
    }

    local local_name;
    local dummy;
    // Craft the rtype
    rtxNodeIdentifier(local_name, "local", "Builtin", false);
    rtxNodeRType(arg_rtype, local_name, dummy);
    // Then craft a terminal expr with the name as the identifier.
    cnormNode_TerminalId(arg_value, varName);

    // Finally, craft the argument holder.
    rtxNodeArgs_AppendArg(resVals, "self", arg_rtype, arg_value);
}

/*
 * In this function, both params are rtx Var List Nodes
 *
 * The src_params and src_resVals are the caller's container's parameters and values.
 * The dst_params and dst_resVals are the params of the chunk we're calling and the values
 *      we have to set.
 */
function rtxResolve_BuildParameterResVals(src_resVals   : node,
                                          src_params    : node,
                                          dst_resVals   : node,
                                          dst_params    : node, 
                                          source_tree   : reference,
                                          search_chunk  : value = true,
                                          tpl_seq       : value = false)
{
    localref   dst_list = dst_params;

    if (rtxNodeArgs(dst_resVals) == false)
        error(RED + "[Error] Could not intialize argument container." + DEFAULT_COLOR);

    if (search_chunk && tpl_seq == false)
        ref dst_list = dst_list.list;

    foreach dst_p in dst_list
    {
        local src_p;
        if (search_chunk && tpl_seq == false)
            ref src_p = src_params.list#[index(dst_p)];
        else
            ref src_p = src_params#[index(dst_p)];
        localref param_name = dst_p;
        if (existVariable(dst_p.identifiers))
            ref param_name = dst_p.identifiers#front.name;
        local param_type;
        local param_src_value;
        local param_value;
        local src_arg;

        // First case: A rtx variable (either comes from src ResVals or from chunk itself)
        // Second case: A litteral
        if (existVariable(src_p.identifiers))
        {
            // Two ways to resolve :
            //  - already in the resVals (simple walk/copy)
            //  - not in the ResVals -> gotta build a resVal from the rtx Type (cnormNode).
            localref theChunk = src_params#root;
            local src_name = src_p.identifiers#front.name;
            local resolver_type; // Type used for the resolver (!= Actual type of the variable, to manage local variables)
            localref placeHolder = src_params; // We're in a placeHolder anyways, so gotta roll up (called from pointcut or chunk call)
            if (search_chunk == true) // Buildin resval for back-end weaving
            {
                while (placeHolder.type != "__rtx_tpl_placeHolder__")
                { ref placeHolder = placeHolder#parent; }
            }

            //  Prepare field list
            local subidentifiers;
            select n in src_p.identifiers[].name { pushItem subidentifiers; subidentifiers#back = n; }

            // Prepare mapping results and resVal before the resolution of the parameters.
            local mapping;
            local subResVal;
            rtxNodeArgs(subResVal);

            if (rtxNodeArgs_GetArgByName(src_resVals, src_name, src_arg) == true)
            {
                // Argument comes from the resVals
                if (rtxNodeArg_getRType(src_arg, param_type) == false)
                    return false;
                setall resolver_type = param_type;
                if (rtxNodeArg_getValue(src_arg, param_src_value) == false)
                    return false;

                setall param_value = param_src_value;
                // In case a recursive resolution is necessary, we need to setup a "self"
                rtxNodeArgs_AppendArg(subResVal, "self", resolver_type, param_value);
            }
            else if (search_chunk)
            {
                // Argument comes from the Chunk, so we retrieve the *real* type
                // That will be resolved after the "local" resolution.

                if (subidentifiers#front == "local")
                    rtxResolve_BuildLocalSelf(subResVal, theChunk, placeHolder, subidentifiers);
                else
                {
                    local src_arg;
                    local src_type;
                    local src_value;
                    rtxNodeArgs_GetArgByName(src_resVals, "self", src_arg);
                    if (rtxNodeArg_getRType(src_arg, src_type) == false)
                        return false;
                    if (rtxNodeArg_getValue(src_arg, src_value) == false)
                        return false;
                    rtxNodeArgs_AppendArg(subResVal, "self", src_type, src_value);
                }
                local local_self;
                rtxNodeArgs_GetArgByName(subResVal, "self", local_self);
                local local_type;
                rtxNodeArg_getRType(local_self, local_type);
                setall resolver_type = local_type;

                src_name = subidentifiers#[1];
                if (findElement(src_name, theChunk.type_map))
                    setall param_type = theChunk.type_map[src_name];
                else
                {
                    setall param_type = theChunk.variables[src_name].type_node;
                }
            }
            else
            {
                error(RED + "[Error] Front-end argument '" + src_name
                      + "' could not be found within the sequence's arguments." + DEFAULT_COLOR);
            }

            local typename = rtxRTypeName<resolver_type.type>(resolver_type);

            if (type_map<typename>(subResVal, resolver_type, subidentifiers, placeHolder, mapping, source_tree) == false)
            {
                error(RED + "[Error] Could not resolve variable '"+ src_name+"' for type '"+typename+"'" + DEFAULT_COLOR);
            }
            setall param_value = mapping;

            // Only retrieve sub-type if it exists.
            if ($getArraySize(subidentifiers) > 1$)
            {
                //  Prepare field list

                // Now resolve the finaltype of the argument -> Retrieve actual param_type
                removeVariable(subidentifiers#[0]); // Remove the first identifiers for the type resolution
                local result_type;
                if (rtxTypingLookup_ResolveTypeFields(resolver_type, subidentifiers, theChunk, source_tree, result_type) == false)
                {
                    error(RED + "[Error] Could not resolve type fields for variable '"
                          + subidentifiers#front + "'" + DEFAULT_COLOR);
                }
                setall param_type = result_type;
            }

        }
        else if (search_chunk == false) // This may be the rtx implementation chunk -> different way to resolve...
        {

            if (rtxNodeArgs_GetArgByName(src_resVals, src_p.val, src_arg) == true)
            {
                if (rtxNodeArg_getRType(src_arg, param_type) == false)
                    return false;
                if (rtxNodeArg_getValue(src_arg, param_value) == false)
                    return false;
                param_name = dst_p;
            }
            else
            {
                if (rtxNode2cnormNode<src_p.type>(src_p, param_value) == false)
                    error(RED + "Could not translate rathaxes node " + toString(src_p, true)
                          + " to a resVal (containing one cnorm) node." + DEFAULT_COLOR);

                setall param_type = src_p.rtype;
                if (param_value.type == "__expr__" && param_value.operator != "__literal__")
                {
                    local src_arg;
                    local src_name = param_value.id;
                    if (rtxNodeArgs_GetArgByName(src_resVals, src_name, src_arg))
                        return false;
                    if (rtxNodeArg_getRType(src_arg, param_type) == false)
                        return false;
                    if (rtxNodeArg_getValue(src_arg, param_value) == false)
                        return false;
                    param_name = dst_p;
                }
            }
        }
        else
        {
            // Retrieve the expr associated to the litteral
            if (rtxNode2cnormNode<src_p.type>(src_p, param_value) == false)
                error(RED + "Could not translate rathaxes node " + toString(src_p, true)
                      + " to a resVal (containing one cnorm) node." + DEFAULT_COLOR);
            setall param_type = src_p.rtype;
        }

        // Now that we have both the source type (important for the qualifier: scalar or ref) and value, 
        // Add it to the destination resvals.
        if (rtxNodeArgs_AppendArg(dst_resVals, param_name, param_type, param_value) == false)
        {
            error(RED + "[Error] Could not append argument to arguments container." + DEFAULT_COLOR);
        }
    }

    return true;
}



/*
 * This function iterates over a sequence implementation (front end)
 * and replaces each sequence call by the associated chunk.
 * This function must be use before inserting the implementation into
 * the backend implem of the sequence.
 */
function rtxResolve_replaceCalls(theSeq : node, resolverValues : node, source_tree : reference)
{
    local   errcount = 0;
    local   dummy;
    local   startIdx = 0;
    local   phName = "call";
    local   phIdx = 0;

    while ($startIdx < getArraySize(theSeq.body.block)$)
    {
        localref    call = theSeq.body.block#[startIdx];
        local       chunkTree;
        local       callRtype;
        local       callProto;

        // The Call's rtype is almost the same as the template's, so use it as a basis.
        setall callRtype = call.rtype;
        callRtype.name.name = "CALL";
        callRtype.name.scope = "";
        callRtype.name.global = true;
        clearVariable(callRtype.params); // Force 0 params for the CALL
        callProto = rtxRTypeFullQualifiedName<"pointcut">(callRtype, dummy);

        // Now load the call's chunk
        if (rtxLink_LoadTplChunk(call.rtype, callProto, source_tree.config, chunkTree, true, "sequence") == false)
        {
            traceLine(RED + "[Error] Could not load script or tree associated to sequence "
                      + rtxRTypeFullQualifiedName<"sequence">(call.rtype, dummy)
                      + DEFAULT_COLOR);
            traceLine(RED + "        at " + theSeq#parent.location + "." + DEFAULT_COLOR);
            return false;
        }

        // Now, resolve the loaded chunk...
        local resVals;
        if (rtxResolve_BuildParameterResVals(resolverValues, call.args, resVals, chunkTree.tpl_params, source_tree, false) == false)
        {
            // TODO: should be an error, but will be break to many things at
            // this point:
            traceLine(RED + "[Error] Could not build front-end parameter resvals." + DEFAULT_COLOR);
        }

        if (instanceChunk<chunkTree.instanceKey>(resVals, chunkTree.body, source_tree) == false)
        {
            increment(errcount);
        }

        // And insert it in the sequence implem after having removed the original call node.
        local dummy;
        insert dummy.block_idx;
        dummy.block_idx = $startIdx - theSeq.body.block.modifier$; // Compute current original index (alias the key).
        insertModifier(theSeq.body.block, dummy);
        startIdx = dummy.block_idx; // retrieve updated startIdx from dummy.
        rtxResolve_InsertCode(theSeq.body.block, startIdx, phName, phIdx, chunkTree.body);
    }
    return true;
}

/*
 *
 * resolverValues -> the hash mapping of values used in the template
 * treeNode -> the root of the __rtx_tpl__ node
 * local_node -> current node
 *
 */

function    inject<"">(resolverValues : node, treeNode : node,
                       local_node : node, source_tree : reference)
{
    // we should NEVER fallback here.
    error("inject: BAD NODE - Empty Template Node Type !");
}

function    inject<sNodeType>(resolverValues : node, treeNode   : node,
                              local_node : node, source_tree : reference)
{
    // we should NEVER fallback here.
    error("inject: BAD NODE - Unknown Template Node Type : "+sNodeType);
}

function    inject<"__rtx_tpl_placeHolder__">(resolverValues    : node,
                                              treeNode          : node,
                                              local_node        : node, 
                                              source_tree : reference)
{
    //traceLine("Injecting into placeHolder : realType = "+treeNode.body.type);
    return inject<local_node.body.type>(resolverValues, treeNode, local_node, source_tree);
}

/*
 * resolverValues : hashtable of key/values
 *
 * Both treeNode and local_node are located in the .compile of a chunk
 * They are located as is :
 * treeNode is still undefined.
 *  .compile = {
 *      [
 *          "_X" : {
 *              .node = {   <-- local_node
 *                  .body = {
 *                  }
 *              }
 *              ...
 *          }
 *      ]
 *  }
 */
function    inject<"__rtx_rtype__">(resolverValues : node, treeNode : node,
                                    local_node : node, source_tree : reference)
{
    localref    theRtype = local_node.body;
    localref    theChunk = treeNode#root;
    local dummy;

    if (!existVariable(local_node#parent.ref_placeholder.identifier))
    {
        error(RED + "Cannot inject type name into badly built compile node: "
        + toString(local_node#parent,true) + DEFAULT_COLOR);
    }
    traceLine("inject<\"__rtx_rtype__\">:<LOG> Injecting type name " + rtxRTypeName<theRtype.type>(theRtype)
    + " within Chunk " + rtxRTypeFullQualifiedName<theChunk.pointcut.type>(theChunk.pointcut,dummy)
    + " of template " + rtxRTypeFullQualifiedName<theChunk.tpl_rtype.type>(theChunk.tpl_rtype, dummy) + ".");

    // We want to set the mangled typedef name into the ctype's identifier:
    // (equivalent of: theDecl.ctype.identifier = COMPUTED_NAME;)
    local_node#parent.ref_placeholder.identifier = rtxResolve_MangleTypeName(theRtype, theRtype.qualifier != "scalar");

    return true;
}

function    inject<"__rtx_var__">(resolverValues : node, treeNode : node,
                                      local_node : node, source_tree : reference)
{
    //traceLine("Injecting into var : "+toString(local_node));
    local curCtxNode;

    traceLine("inject<\"__rtx_var__\">:<LOG> Injecting code into placeHolder "
              + local_node#parent.template_expr + ", target="+local_node#parent.type_target);
    /*
     *
     * This block of code has for role to check wether we're manipulating
     * a rathaxes type or a variable of a rathaxes type.
     *
     * Here we can manage the access to a mapped identifier in a type
     * We need to build the ResVal for the "${self}" placeHolder of the var.
     *
     */
    //    local_node <=> with.c_block.compile[X].node
    // or local_node <=> chunk.body.compile[X].node
    // or local_node <=> chunk.body.compile[X].node
    localref theChunk = local_node#parent#parent#parent#parent;
    localref varName = local_node.body.identifiers[0].name;
    // First, check that there is not prefix or suffix.
    switch (local_node#parent.type_target)
    {
    case "target_identifier":
        traceLine("inject<\"__rtx_var__\">:<LOG> Injecting an identifier");
        //traceLine("inject<\"__rtx_var__\">:<LOG> ID:theChunk: " + toString(theChunk, true));
        //traceLine("inject<\"__rtx_var__\">:<LOG> ID:varName: "+ toString(varName, true));
        //traceLine("inject<\"__rtx_var__\">:<LOG> ID:resolverValues: " + toString(resolverValues, true));
        //traceLine("inject<\"__rtx_var__\">:<LOG> ID:treeNode: " + toString(treeNode, true));
        traceLine("inject<\"__rtx_var__\">:<LOG> ID:local_node: " + toString(local_node#parent, true) + toString(local_node#parent.ref_placeholder,true));
        //traceLine("inject<\"__rtx_var__\">:<LOG> ID:source_tree: " + toString(source_tree, true));
        local fieldValue;
        // TODO: obsolete when builtintype will be typed
        if (isBuiltinVariable(varName))
        {
                local dummyResVal;
                local dummyRtype;
                local subidentifiers;
                select n in local_node.body.identifiers[].name { pushItem subidentifiers; subidentifiers#back = n; }
                if (type_map<"Builtin::"+varName>(dummyResVal, dummyRtype,
                                        subidentifiers, local_node, fieldValue, source_tree) == false)
                {
                        traceLine(RED + "[Error] Could not resolve mapping for builtin variable '"
                                        + local_node.body.identifiers[0].name + "'" + DEFAULT_COLOR);
                        traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                        return false;
                }
        }
        else
        {
            local field;
            if (rtxNodeArgs_GetArgByName(resolverValues, local_node.body.identifiers#front.name, field) == false)
            {
                traceLine(RED + "[Error] Could not retrieve argument '" + local_node.body.identifiers#front.name
                          + "' from resolverValues." + toString(local_node.body.identifiers,true) + DEFAULT_COLOR);
                error(RED + toString(resolverValues,true) + DEFAULT_COLOR);
                return false;
            }
            rtxNodeArg_getValue(field, fieldValue);
        }
        traceLine("inject<\"__rtx_var__\">:<LOG> ID:fieldValue: " + cnorm2c(fieldValue));
        if (fieldValue.type != "__expr__" || fieldValue.expr_type != "__terminal__" || fieldValue.operator != "__id__")
        {
            traceLine(RED + "[Error] Cannot concatenate prefix and suffix to something other than a terminal id !"
                      + toString(fieldValue, true) + DEFAULT_COLOR);
            return false;
        }
        // First concat prefix and suffix
        local sChunk = fieldValue.id;
        local finalNode = local_node.prefix + sChunk + local_node.suffix;
        traceLine("inject<\"__rtx_var__\"> ID:final value:" + finalNode);
        local_node#parent.ref_placeholder = finalNode;
        break;
    case "target_expr":
        // Is it a variable of a rathaxes type : check in type_map ?
        if (isEmpty(local_node.prefix) && isEmpty(local_node.suffix)
                 && ((existVariable(theChunk.type_map) && findElement(varName, theChunk.type_map))
                     || varName == "self"))
        {
            traceLine("inject<\"__rtx_var__\">:<LOG> Injecting a type mapping (" + varName + ").");
            // Create the resolverValues for the type resolution:
            // This should not need any more than config and var's identifier.
            local resVal;
            rtxNodeArgs(resVal);
            local self;
            local self_value;
            local self_type;
            // First, try to retrieve value from previous resVals, otherwise build it from chunk
            if (varName != "self")
            {
                //
                // XXX Note: Here, we may encounter some issues if the chunk's type_map isnt properly filled
                // (encountered once, the type was scalar instead of ref)
                //
                local self_reftype = "scalar";
                local self_rtype;
                if (rtxNodeArgs_GetArgByName(resolverValues, varName, self) == true)
                {
                    rtxNodeArg_getValue(self, self_value);
                    rtxNodeArg_getRType(self, self_rtype);
                    self_reftype = self_rtype.qualifier;
                }
                else
                {
                    traceLine(YELLOW + "[Warning] Using variable's identifier as resolved value (high probability to be wrong): "
                              + local_node#parent.location + DEFAULT_COLOR);
                    clearVariable(self_value);
                    cnormNode_TerminalId(self_value, varName);
                }
                setall self_rtype = theChunk.type_map[varName];
                self_rtype.qualifier = self_reftype;
                rtxNodeArgs_AppendArg(resVal, "self", self_rtype, self_value);
                setall self_type = self_rtype;
            }
            else
            {
                // "self" as an identifier means that we're within some Type Template code.
                // Thus the actual value is the associated ResVal, and the type the template's type itself.
                if (rtxNodeArgs_GetArgByName(resolverValues, varName, self) == true)
                {
                    rtxNodeArg_getValue(self, self_value);
                }
                rtxNodeArgs_AppendArg(resVal, "self", self.rtype, self_value);
                setall self_type = self.rtype;
            }

            local qTypeName = rtxRTypeName<self_type.type>(self_type);

            local    mapping;
            local subParam;
            setall subParam = local_node.body.identifiers;
            local subidentifiers;
            select n in subParam[].name { pushItem subidentifiers; subidentifiers#back = n; }

            if (type_map<qTypeName>(resVal, self_type, subidentifiers,
                                    local_node, mapping, source_tree) == false)
            {
                traceLine(RED + "[Error] Could not resolve mapping of '"
                          + subidentifiers[0] + "' for identifier '"
                          + local_node.body.identifiers[0].name + "'" + DEFAULT_COLOR);
                traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                return false;
            }

            // Here, the mapping should always be an expression
            if (!isString(mapping) && (!existVariable(mapping.type) || mapping.type != "__expr__"))
            {
                traceLine(RED + "[Error] inject<\"__rtx_var__\">: could not weave for node of type '"
                          + mapping.type + "' (weaving "+toString(mapping)+"): not implemented" + DEFAULT_COLOR);
                traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                return false;
            }

            if (isString(mapping))
            {
                local_node#parent.ref_placeholder.id = mapping;
            }
            else
            {
                local source_type;

                // First retrieve the type of the value we just resolved.
                if (getArraySize(subidentifiers) == 1)
                {
                    // If there's a resval argument for it, then take the source type from there
                    // Otherwise, use the chunk's type_map.
                    if (rtxNodeArg_getRType(self, source_type) == false)
                    { ref source_type = self_type; }
                    rtxNodeArg_getRType(self, source_type);
                }
                else
                {
                    // Now resolve the finaltype of the argument -> Retrieve actual param_type
                    removeVariable(subidentifiers#[0]); // Remove the first identifiers for the type resolution
                    local result_type;
                    if (rtxTypingLookup_ResolveTypeFields(self_type, subidentifiers, theChunk, source_tree, source_type) == false)
                    {
                        error(RED + "[Error] Could not resolve type fields for variable '"
                                + subidentifiers#front + "'" + DEFAULT_COLOR);
                    }
                }
                local in_type = source_type.qualifier;
                local out_type = local_node#parent.ph_type;
                if (rtxResolve_RefScalarTranscribe(mapping, in_type, out_type) == false)
                { error(RED + "[Error] Cannot transcribe an expression from " + in_type + " to " + out_type + DEFAULT_COLOR); }
                setall local_node#parent.ref_placeholder = mapping;
            }
        }
        else if (isBuiltinVariable(varName)) // Mapping for a  builtin type
        {
            local dummyRtype;
            local mapping;
            local subResVal;
            rtxNodeArgs(subResVal);

            local subParam;
            setall subParam = local_node.body.identifiers;
            local subidentifiers;
            select n in subParam[].name { pushItem subidentifiers; subidentifiers#back = n; }

            if (subidentifiers#[0] == "local")
                rtxResolve_BuildLocalSelf(subResVal, theChunk, local_node, subidentifiers);

            traceLine("inject<\"__rtx_var__\">:<LOG> Injecting a builtintype mapping (" + varName + ").");
            // TODO: obsolete when builtintype will be typed
            if (type_map<"Builtin::"+varName>(subResVal, dummyRtype,
                                              subidentifiers,
                                              local_node, mapping, source_tree) == false)
            {
                traceLine(RED + "[Error] Could not resolve mapping for builtin variable '"
                          + local_node.body.identifiers[0].name + "'" + DEFAULT_COLOR);
                traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                return false;
            }


            // Here, the mapping should always be an expression
            if (!isString(mapping) && (!existVariable(mapping.type) || mapping.type != "__expr__"))
            {
                traceLine(RED + "[Error] inject<\"__rtx_var__\">: could not weave for node of type '"
                          + mapping.type + "' (weaving "+toString(mapping)+"): not implemented" + DEFAULT_COLOR);
                traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                return false;
            }

            if (isString(mapping))
            {
                local_node#parent.ref_placeholder.id = mapping;
            }
            else
            {
                setall local_node#parent.ref_placeholder = mapping;
            }
        }
        // Mapping as a value
        else
        {
            /*
             * This block of code means to replace the placeHolder by a simple
             * identifier in the code. (May be used for the self resolution)
             */
            local field;
            local fieldValue;
            local finalNode;
            traceLine("inject<\"__rtx_var__\">:<LOG> Injecting a value placeHolder : " + local_node#parent.template_expr);
            if (rtxNodeArgs_GetArgByName(resolverValues, local_node.body.identifiers#front.name, field) == false)
            {
                traceLine(RED + "[Error] Could not retrieve argument '" + local_node.body.identifiers#front.name
                          + "' from resolverValues." + toString(local_node.body.identifiers,true)  + toString(resolverValues, true)+ DEFAULT_COLOR);
                error(RED + toString(resolverValues,true) + DEFAULT_COLOR);
                return false;
            }
            rtxNodeArg_getValue(field, fieldValue);
            // The Arg's value is a whole node : setall it into the placeholder's parent
            if (existVariable(fieldValue.type))
            {
                traceLine("inject<\"__rtx_var__\">:<LOG> Replacing identifier '"+toString(local_node.body.identifiers)+"' of type "+fieldValue.type);
                setall local_node#parent.ref_placeholder = fieldValue;
            }
            else // or craft the expr node...
            {
                traceLine("inject<\"__rtx_var__\">:<LOG> Concatenating identifier : "+toString(local_node.body.identifiers));
                // First concat prefix
                finalNode = finalNode + local_node.prefix;
                // Next resolve the value and concat it
                finalNode = finalNode + fieldValue;
                // Finally, concat suffix
                finalNode = finalNode + local_node.suffix;
                local_node#parent.ref_placeholder.id = finalNode;
            }
        }
        break ;
    case "target_decl": // it's a type declaration, should not reach here.
    default:
        error(RED + "[Error] Target type " + local_node#parent.type_target + " is not managed  (from "
              + local_node#parent.location + DEFAULT_COLOR);
        break ;
    }

    return true;
}

/*
 * resolverValues : hashtable of key/values
 *
 * Both treeNode and local_node are located in the .compile of a chunk
 * They are located as is :
 * treeNode is still undefined.
 *  .compile = {
 *      [
 *          "_X" : {
 *              .node = {
 *                  .body = {   <-- local_node
 *                  }
 *              }
 *              ...
 *          }
 *      ]
 *  }
 */
function    inject<"__rtx_tpl_sequence_call__">(resolverValues : node, treeNode : node,
                                                local_node : node, source_tree : reference)
{
    // Tool variable for code replacing.
    local       errcount = 0;
    local       dummy;
    local       startIdx = local_node#parent.block_idx;
    local       phName = "_"+local_node#parent.block_idx;
    local       phIdx = 0;
    localref    theParent = local_node#parent.ref_placeholder#parent;
    if (local_node#parent.type_target != "target_pointcut" && local_node#parent.type_target != "target_expr")
    {
        error(RED + "[Error] inject<\"__rtx_tpl_sequence_call__\">: Wrong target type ("
              + local_node#parent.type_target + ")" + DEFAULT_COLOR);
        traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
    }

    // Two variables to create the rtype associated to the sequence call
    local       tplRtype;
    local       paramTypes;

    // Tree variables to help manipulate the cache
    local       chunkTree;
    local       callRtype;
    local       callProto;

    // First, build the rtype node.
    rtxNodeRType(tplRtype, local_node.body.seqName, paramTypes);
    foreach param in local_node.body.seqArgs
    {
        if (existVariable(param.rtype))
        {
            pushItem paramTypes;
            setall paramTypes#back = param.rtype;
        }
        else
        {
            traceLine(RED + "[Error] Could not find rtx type associated to param '"+param.val
                      +"' for sequence call '"+local_node#parent.template_expr+"'" + DEFAULT_COLOR);
            traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
            return false;
        }
    }

    // The Call's rtype is almost the same as the template's, so use it as a basis.
    setall callRtype = tplRtype;
    callRtype.name.name = "CALL";
    callRtype.name.scope = "";
    callRtype.name.global = true;
    clearVariable(callRtype.params); // Force 0 params for the CALL
    callProto = rtxRTypeFullQualifiedName<"pointcut">(callRtype, dummy);

    // Now load the call's chunk
    if (rtxLink_LoadTplChunk(tplRtype, callProto, source_tree.config, chunkTree, true, "sequence") == false)
    {
        traceLine(RED + "[Error] Could not load script or tree associated to sequence "
                  + rtxRTypeFullQualifiedName<"sequence">(tplRtype, dummy)
                  + DEFAULT_COLOR);
        traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
        return false;
    }

    // Now, resolve the loaded chunk...
    local resVals;
    rtxResolve_BuildParameterResVals(resolverValues, local_node.body.seqArgs, resVals, chunkTree.tpl_params, source_tree, true, true);
    if (instanceChunk<chunkTree.instanceKey>(resVals, chunkTree.body, source_tree) == false)
    {
        traceLine(RED + "[Error] Could not resolve sequence call to " + rtxRTypeFullQualifiedName<"sequence">(tplRtype,dummy) + DEFAULT_COLOR);
        traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
        return false;
    }

    switch (local_node#parent.type_target)
    {
        case "target_pointcut":
            insertModifier(theParent, local_node#parent);
            startIdx = local_node#parent.block_idx; // retrieve updated startIdx from dummy.
            rtxResolve_InsertCode(theParent, startIdx, phName, phIdx, chunkTree.body);
            break ;
        case "target_expr":
            setall local_node#parent.ref_placeholder = chunkTree.body.block[0].expr;
            break ;
        default:
            error(RED + "[Error] Unmanaged weaving target type: " + local_node#parent.type_target + "." + DEFAULT_COLOR);
    }

    return true;
}


/*
 * The default case of the function inject_pointcut will resolve a "normal"
 * pointcut: insert every chunk in place of the said pointcut.
 *
 * The specializations are meant to be the builtin pointcuts resolution.
 */
function inject_pointcut<T>(resolverValues : node, treeNode : node,
                                    local_node : node, source_tree : reference)
{
    if (local_node#parent.type_target != "target_expr"
        && local_node#parent.type_target != "target_identifier"
        && local_node#parent.type_target != "target_pointcut")
    {
        traceLine(RED + "[Error] inject_pointcut<T(\""+T+"\")>: Injection target type "
                  + local_node#parent.type_target + " not managed for a pointcut" + DEFAULT_COLOR);
        traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
        return false;
    }

    localref theParent = local_node#parent.ref_placeholder#parent;
    localref thePointcut = local_node#parent;
    local pointcutName = rtxRTypeName<local_node.body.name.type>(local_node.body.name);
    local dummy;
    local full_pointcut_name = rtxRTypeFullQualifiedName<"pointcut">(local_node.body.rtype, dummy);
    // Variables for the node replacement
    local phName = thePointcut.block_idx;
    local phIdx = 0;
    local startIdx = 0;
    // cache-related variable
    local   chunks;
    local   errcount = 0;

    // First, search every chunk associated to the pointcut...
    if (rtxLink_findChunks(full_pointcut_name, chunks) == false)
    {
        traceLine(YELLOW + "[Warning] inject_pointcut<\""+T+"\">: No chunk associated with"
                  +" the pointcut " + full_pointcut_name + DEFAULT_COLOR);
    }

    // If we cannot find any chunk, let's use default behaviour (if there's one)
    if (isEmpty(chunks)
        || rtxLink_selectCompatibleChunks(chunks, source_tree.config) == false)
    {
        traceLine(YELLOW + "[Warning] inject_pointcut<T(\""+T+"\")>: No valid chunk,"
                  +" falling back to default behaviour." + DEFAULT_COLOR);
        // If there's a default block inside the poincut, then insert it
        // instead of the resolved chunks : one setall is enough
        // to both remove the pointcut and insert the code.
        if (existVariable(local_node.body.default.body))
        {
            if (theParent#parent.type == "__block__")
            {
                if (getArraySize(theParent) <= thePointcut.block_idx)
                {
                    error(RED+ "[Error] inject_pointcut<T(\""+T+"\")>: Trying to get index "
                          + thePointcut.block_idx + " at " + local_node#parent.location
                          + " into block " + toString(theParent,true) +DEFAULT_COLOR);
                }
                setall theParent#[thePointcut.block_idx] = local_node.body.default.body;
            }
            else
                error(RED + "[Error] inject_pointcut<T(\""+T+"\")>: Node type '" + theParent#parent.type
                      + "' not supported for default resolution. (at " + local_node#parent.location
                      + ")" + DEFAULT_COLOR);
        }
        else
        {
            if (theParent.type == "__block__")
            {
                // removes the current placeHolder and inserts the modifier
                insertModifier(theParent.block, thePointcut);
            }
            else if (theParent#parent.type == "__block__")
            {
                // removes the current placeHolder and inserts the modifier
                insertModifier(theParent, thePointcut);
            }
        }
    }
    // There are some chunks left, so it's up to us to resolve them
    // and then insert them in-place of the pointcut.
    else
    {
        // Here, we should be in the following case:
        //  - A field declaration within a block

        localref pBlock = theParent#parent;
        if (pBlock.type == "")
            ref pBlock = pBlock#parent;
        if (theParent.type != "__field_decl__"
            && pBlock.type != "__block__"
            && pBlock.type != "__block_init__")
        {
            error(RED + "[Error] inject_pointcut<T(\""+T+"\")>: parent of placeholder ("
                  + local_node#parent.type_target + ") is not an expected node type ("
                  + theParent.type + " or " + pBlock.type + ")"
                  + " at " + local_node#parent.location + "." + DEFAULT_COLOR);
        }

        if (local_node#parent.type_target == "target_identifier"
            && getArraySize(chunks) > 1)
            traceLine(YELLOW + "[Warning] More than one chunk are going to be inserted"
                      + " into pointcut with type_target=" + local_node#parent.type_target);

        // First, remove the current placeHolder, in case there was no statement
        local theBlock;
        switch (local_node#parent.type_target)
        {
        case "target_identifier": // The ref_placeholder points on the identifier
            ref theBlock = theParent;
            // Thus, wind-up until we find the block
            while (theBlock#parent.type != "__block__" && theBlock#parent.type != "__block_init__")
            { ref theBlock = theBlock#parent; }
            break;
        case "target_expr": // The ref_placeholder points on the expr node
            ref theBlock = theParent;
            break;
        case "target_pointcut": // The ref_placeholder points on the whole statement/expr/decl
            ref theBlock = theParent;
            break;
        default:
            error(RED + "[Error] Unmanaged placeholder target_type for pointcut: " + local_node#parent.type_target + DEFAULT_COLOR);
        }

        insertModifier(theBlock, thePointcut);
        startIdx = thePointcut.block_idx;
        foreach chunk in chunks
        {
            local c_tree;
            if (rtxLink_LoadItem(chunk, c_tree) == false)
            {
                traceLine(RED + "[Error] inject_pointcut<T(\""+T+"\")>: Could not "
                          +"load script for one chunk for pointcut "+pointcutName+ DEFAULT_COLOR);
                traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                increment(errcount);
            }
            local resVals;
            if (rtxResolve_BuildParameterResVals(resolverValues,
                                                 local_node.body.parameters,
                                                 resVals, c_tree.parameters, source_tree) == false)
            {
                traceLine(RED + "[Error] inject_pointcut<T(\""+T+"\")>: Wrong parameters given to pointcut '"
                          + pointcutName + "'" + DEFAULT_COLOR);
                traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                return false;
            }


            if (instanceChunk<c_tree.instanceKey>(resVals, c_tree.body, source_tree) != false)
            {
                rtxResolve_InsertCode(theBlock, startIdx, phName, phIdx, c_tree.body);
            }
            else
            {
                traceLine(RED + "[Error] inject_pointcut<T(\""+T+"\")>: Could not instanciate chunk '"+c_tree.instanceKey+"'." + DEFAULT_COLOR);
                traceLine(RED + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                increment(errcount);
            }
        }
        local theDecl;
        if (errcount != 0)
            return false;
    }

    return true;
}

function inject_pointcut<"::IMPLEMENTATION">(resolverValues : node, treeNode : node,
                                             local_node : node, source_tree : reference)
{
    localref theBlock = local_node#parent.ref_placeholder#parent;
    // Make sure TheBlock references the parent block (should always be the case for this kind of pointcut).
    while (theBlock.type != "__block__" && theBlock.type != "__block_init__")
    {
        ref theBlock = theBlock#parent;
    }
    ref theBlock = theBlock.block;

    localref thePointcut = local_node#parent;
    // Some variables for the InsertCode function
    local phName = thePointcut.block_idx;
    local phIdx = 0;
    local startIdx = 0;
    local dummy;

    // Find the right impl to include from the front by walking
    // through the front tree and checking the tpl against the chunk's hash.
    foreach item in source_tree.block
    {
        if (item.type == "__rtx_device__")
        {
            foreach decl in item.body.block
            {
                if (decl.type == "__rtx_sequence__"
                    && rtxRTypeFullQualifiedName<"sequence">(decl.rtype, dummy) == local_node#parent.tpl_hash)
                {
                    local resVals;
                    local parameters;
                    local theVar;
                    local curId;
                    rtxNodeVarList(parameters);
                    foreach param in decl.seqParamName
                    {
                        clearVariable(curId);
                        rtxNodeIdentifier(curId, param, "");
                        rtxNodeVar(theVar, curId);
                        //foreach id in ???
                        //{
                        //    rtxNodeVar_AddIdentifier(theVar, curId);
                        //}
                        rtxNodeVarList_AddNode(parameters, theVar);
                    }

                    rtxResolve_BuildParameterResVals(resolverValues, 
                                                     local_node.body.parameters,
                                                     resVals, parameters, source_tree);

                    // Then replace each Tpl CALL by the CALL chunks associated.
                    if (rtxResolve_replaceCalls(decl, resVals, source_tree) == false)
                    {
                        traceLine(YELLOW + "Could not replace Call for ::IMPLEMENTATION pointcut for template '"
                                  + local_node#parent.tpl_hash + "'"+ DEFAULT_COLOR);
                        traceLine(YELLOW + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
                        return false;
                    }

                    //traceLine(BLUE + "[Debug] Resolved implementation call to "
                    //          + rtxRTypeFullQualifiedName<"sequence">(decl.rtype, dummy)
                    //          + ":" + toString(decl.body, true)+DEFAULT_COLOR);
                    //traceLine(PURPLE + "[Debug] Resolved implementation:"+cnorm2c(decl.body)+DEFAULT_COLOR);

                    // Finally, insert the block in-place of the placeHolder.
                    insertModifier(theBlock, thePointcut);
                    startIdx = thePointcut.block_idx; // updated block_idx prevents "index out of bounds"
                    rtxResolve_InsertCode(theBlock, startIdx, phName, phIdx, decl.body);

                    return true;
                }
            }
        }
    }
    traceLine(YELLOW + "Could not resolve ::IMPLEMENTATION pointcut for template " + local_node#parent.tpl_hash + DEFAULT_COLOR);
    traceLine(YELLOW + "        at " + local_node#parent.location + "." + DEFAULT_COLOR);
    return false;
}

/*
 *
 * This function takes a resolver value node, the tree node in which
 * the resolution is needed, and the local_node which is the placeHolder to
 * resolve.
 *
 * This specialization takes care of the resolution of a pointcut, and manages
 * builtin pointcuts (like the ::CALL, ::IMPLEMENTATION pointcut for required/optional templates).
 *
 */
function    inject<"__rtx_pointcut__">(resolverValues   : node,
                                       treeNode         : node,
                                       local_node       : node, 
                                       source_tree : reference)
{
    local ptcutName = rtxRTypeName<local_node.body.name.type>(local_node.body.name);

    if (local_node.body.name.scope == "" && local_node.body.name.global == false)
    {
        error("inject<\"__rtx_pointcut__\">:<ERROR> An unexpected error occurred:"
              + " Unknown scope to poincut " + ptcutName + ".");
    }

    return inject_pointcut<ptcutName>(resolverValues, treeNode, local_node, source_tree);
}

//function    inject<"__rtx_tpl_chunk_call__">(resolverValues : node,
//                                             treeNode : node,
//                                             local_node : node)
//{
//}

/*
 *
 * This function is used to resolve an explicit call to a chunk
 * contained in a type template.
 * This model allows easy builtin implementations.
 *
 */
function    type_call<T>(resolverValues : node,
                         methodProto : value,
                         placeHolder : node, 
                         source_tree : reference)
{
    localref tplRtype = placeHolder.body.rtype;
    local   startIdx;
    local   subtree;

    if (rtxLink_LoadTypeMethod(tplRtype, methodProto, source_tree.config, subtree) == false)
        return false;

    // To actually resolve this, we need :
    //  * Current resolverValues (OK)
    //  * The parameters to the chunk (TBD) FIXME XXX TODO
    //
    local resVals;
    // Add the "self" after we build the resVals
    local self_value;
    rtxNodeArgs(resVals);
    traceLine("type_call<"+T+">:<LOG> Building resVals for chunk " + methodProto + "... ");
    // Then add the call (chunk's) parameters to the resval.
    rtxResolve_BuildParameterResVals(resolverValues, placeHolder.body.parameters,
                                     resVals, subtree.parameters, source_tree);
    // Since it is a local variable, simply build a terminal ID for it.
    cnormNode_TerminalId(self_value, placeHolder.body.vars#back.name);
    rtxNodeArgs_AppendArg(resVals, "self", tplRtype, self_value);

    traceLine("type_call<"+T+">:<LOG> Resolving chunk " + methodProto + "... ");
    if (instanceChunk<subtree.instanceKey>(resVals, subtree.body, source_tree) == false)
    {
        traceLine(RED + "[Error] type_call<\""+T+"\">: Could not instance Chunk '"+subtree.instanceKey+"'.");
        traceLine(RED + "        called from " + placeHolder#parent.location + "." + DEFAULT_COLOR);
        return false;
    }

    // Now, insert the subtree in place of the placeHolder !
    // placeHolder actually is : block.[idx].expr.id, so unwind until theBlock.type != "__block__".
    localref theBlock = placeHolder#parent.ref_placeholder;
    do { ref theBlock = theBlock#parent; } while (theBlock.type != "__block__" && theBlock.type != "__block_init__");
    localref theCall = placeHolder#parent;
    local phIdx = 0;
    // First, remove the current placeHolder, in case there was no statement
    insertModifier(theBlock.block, theCall);
    startIdx = theCall.block_idx;
    rtxResolve_InsertCode(theBlock.block, startIdx,
                          theCall.ref_placeholder, phIdx, subtree.body);

    traceLine("type_call<"+T+">:<LOG> Resolved call to chunk " + methodProto + "...");
    return true;
}


/*
 * The functions that resolve a type mapping.
 */

// Builtin functions for type mapping
declare function instanceMapping<T>(resVals : node, c_tree : node, source_tree : reference);

/*
 * The function to call when encountering a type mapping...
 *
 * resolverValues : hashtable of values for placeHolder resolution
 * theRtype       : a __rtx_rtype__ node  matching the template's type
 * mappedIds      : the identifier used in the mapping call
 * local_node     : the mapping's placeHolder .node
 */
function type_map<T>(resolverValues : node,
                     theRtype : node, mappedIds : node,
                     placeHolder : node, out_node : node, source_tree : reference)
{
    traceLine("rtxResolve:<LOG> type_map<"+T+"> for variable '"+mappedIds#[0]+"' ("+toString(mappedIds)+")");
    local   identifiers;
    local   actual_resVals;
    local   actual_rtype;
    setall actual_rtype = theRtype;
    setall actual_resVals = resolverValues;

    setall identifiers = mappedIds;
    removeFirstElement(identifiers);
    if (getArraySize(identifiers) > 0)
    {
        local self_arg;
        local prev_expr;
        if (rtxNodeArgs_GetArgByName(resolverValues, "self", self_arg) == false)
        {
            traceLine(RED + "[Error] type_map<"+T+">: Could not retrieve self." + DEFAULT_COLOR);
            return false;
        }
        rtxNodeArg_getValue(self_arg, prev_expr);

        while (getArraySize(identifiers) > 0)
        {
            local   theTemplate;
            local   subtree;
            if (rtxLink_FindUniqueTemplate(actual_rtype, source_tree.config, theTemplate) == false)
                return false;
            rtxLink_LoadItem(theTemplate, subtree);
            localref theMapping = subtree.mapping.body.block[identifiers#front];

            // Call the right mapping function (based on hash + identifier mapped).
            traceLine("type_map<"+T+">:<LOG> type_map<" + T + ">: Calling mapping key : "
                      + theMapping.instanceKey);

            if (instanceMapping<theMapping.instanceKey>(actual_resVals, subtree, source_tree) == false)
            {
                traceLine(RED + "[Error] type_map<"+T+">: instanceMapping<\""+theMapping.instanceKey+"\"> failed");
                traceLine(RED + "        for mapping at " + placeHolder#parent.location + "." + DEFAULT_COLOR);
                return false;
            }

            // Update actual rtype.
            local rtypeName = rtxRTypeName<actual_rtype.type>(actual_rtype);
            local field_rtype;
            if (rtxTypingLookup_TypeField<rtypeName>(actual_rtype, identifiers#front, placeHolder#root, source_tree, field_rtype) == false)
            {
                traceLine(RED + "[Error] Could not resolve type field '"
                          + identifiers#front + "' for type " + rtypeName + DEFAULT_COLOR);
                return false;
            }

            setall prev_expr = theMapping.body.expr;
            setall actual_rtype = field_rtype;
            clearVariable(actual_resVals);
            rtxNodeArgs(actual_resVals);
            rtxNodeArgs_AppendArg(actual_resVals, "self", actual_rtype, prev_expr);
            removeFirstElement(identifiers);
        }
    }

    // Now, resolve as a "self"
    {
        local self;
        local val;
        if (rtxNodeArgs_GetArgByName(actual_resVals, "self", self) == false)
        {
            error(RED + "Could not get value..." + DEFAULT_COLOR);
        }
        rtxNodeArg_getValue(self, val);
        setall out_node = val;
    }

    return true;
}

// FIXME TODO XXX
// TO BE REMOVED WHEN PLACEHOLDER TYPECHECKING WILL BE ALRIGHT
function        rtxGetTypeFromVariableID<T>(out_type : node)
{ return false; }
function        rtxGetTypeFromVariableID<"local">(out_type : node)
{
    local id;
    local dummy;
    rtxNodeIdentifier(id, "local", "Builtin");
    rtxNodeRType(out_type, id, dummy);
    return true;
}
function        rtxGetTypeFromVariableID<"config">(out_type : node)
{
    local id;
    local dummy;
    rtxNodeIdentifier(id, "config", "Builtin");
    rtxNodeRType(out_type, id, dummy);
    return true;
}


// The builtin specializations.
function type_map<"Builtin::local">(resolverValues : node,
                                    theRtype : node, mappedIds : node,
                                    placeHolder : node, out_node : node, source_tree : reference)
{
    local data;
    localref theChunk = placeHolder#root;
    local identifiers;
    setall identifiers = mappedIds;

    removeFirstElement(identifiers); // remove the "local."
    if (!findElement(identifiers#[0], theChunk.variables))
    {
        traceLine(RED + "[ERROR] Could not find local variable '" + identifiers#[0] + "' in block" + DEFAULT_COLOR);
        traceLine(RED + "        at " + placeHolder#parent.location + "." + DEFAULT_COLOR);
        return false;
    }

    localref theVar = theChunk.variables[identifiers#[0]];
    if (getArraySize(identifiers) == 0)
    {
        error(RED + "[Error] The Builtin::local variable cannot be used "
              + "alone (not followed by any identifier)." + DEFAULT_COLOR);
    }

    if (theVar.type == "ctype") // the variable is a pure C type
    {
        cnormNode_TerminalId(out_node, identifiers#front);
    }
    else if (theVar.type == "rtxtype")// the variable is a declared rathaxes type-> check for mapping
    {
        // Build the resval properly for the actual variable.
        local self_arg;
        local theValue;
        if (rtxNodeArgs_GetArgByName(resolverValues, "self", self_arg) == false)
            error(RED + "[Error] No self argument to Builtin::Local variable resolution: "
                  + toString(resolverValues,true) + DEFAULT_COLOR);
        rtxNodeArg_getValue(self_arg, theValue);
        local resVal;
        rtxNodeArgs(resVal);
        rtxNodeArgs_AppendArg(resVal, "self", theVar.type_node, theValue);

        local rtype;
        setall rtype = theVar.type_node;
        return type_map<rtxRTypeName<rtype.type>(rtype)>(resVal, rtype, identifiers, placeHolder, out_node, source_tree);
    }
    else
        return false;

    return true;
}

// The builtin specializations.
function type_map<"Builtin::config">(resolverValues : node,
                                     theRtype : node, mappedIds : node,
                                     placeHolder : node, out_node : node, source_tree : reference)
{
    local identifiers;
    setall identifiers = mappedIds;
    removeFirstElement(identifiers); // remove the "config."
    foreach itf in source_tree.config
    {
        if (findElement(identifiers#[0], itf))
        {
            local retval;
            if (existVariable(itf[identifiers#[0]].val.rtype)) // then it's a rtx var...
            {
                // Always returns a terminal literal.
                if (rtxNode2cnormNode<itf[identifiers#[0]].type>(itf[identifiers#[0]].val, out_node) == false)
                    return false;

                return true;
            }
            else if (itf[identifiers#[0]].type == "__rtx_id__")
            {
                out_node = placeHolder.prefix + itf[identifiers#[0]].val.name + placeHolder.suffix;
                return true;
            }
            else
            {
                traceLine(RED + "[Error] Unmanaged type in Builtin::config type_map<> function : '"+itf[identifiers#[0]].type+"'");
            }
            traceLine(RED + "[Error] Cannot translate node of type '" + itf[identifiers#[0]].type
                      + "' into a C value for config item replacement" + DEFAULT_COLOR);
            traceLine(RED + "        for mapping at " + placeHolder#parent.location + "." + DEFAULT_COLOR);
            return false;
        }
    }
    return false;
}

// The builtin specializations.


#end
