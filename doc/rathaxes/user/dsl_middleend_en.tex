\documentclass[american]{rtxreport}

\usepackage{color}
\usepackage{listings}

\author{David Pineau}

\title{Language Documentation: Middle-End}
\usepackage[utf8]{inputenc}
\rtxdoctype{Documentation}
\rtxdocref{middleend\_documentation}
\rtxdocversion{0.1}
\rtxdocstatus{Draft}

\rtxdochistory{
0.1 & 14/04/2012 & David Pineau & First Draft of the Doc \\
}

\newcommand{\note}[1]{\marginpar{\scriptsize{\textdagger\ #1}}}

\definecolor{grey}{rgb}{0.90,0.90,0.90}
\definecolor{rBlue}{rgb}{0.0,0.24,0.96}
\definecolor{rRed}{rgb}{0.6,0.0,0.0}
\definecolor{rGreen}{rgb}{0.0,0.4,0.0}

\lstdefinelanguage{rathaxes}
{
    morekeywords={},
	sensitive=true,
	morecomment=[l][\color{rRed}]{//},
	morecomment=[s][\color{rRed}]{/*}{*/},
	morestring=[b][\color{rGreen}]",
	morestring=[b][\color{rGreen}]',
	keywordstyle={\color{rBlue}},
    commentstyle={\color{rRed}},
    moredirectives={import}
}[comments,strings,directives]

\lstdefinelanguage[front]{rathaxes}
{
}[keywords,comments,strings]

\lstdefinelanguage[middle]{rathaxes}
{
	morekeywords={interface, provided, required, optional, type, sequence,
                  variable},
    otherkeywords={::}
}[keywords,comments,strings]

\lstdefinelanguage[back]{rathaxes}
{
	morekeywords={with, template, type, sequence, decl, stmt, link, to, each},
	morecomment=[s][\color{rBlue}]{\$\{}{\}}
}[keywords,comments,strings]



\definecolor{lstbackground}{rgb}{0.95, 0.95, 0.95}
\definecolor{lstcomment}{rgb}{0, 0.12, 0.76}
\definecolor{lstkeyword}{rgb}{0.66, 0.13, 0.78}
\definecolor{lststring}{rgb}{0.67, 0.7, 0.13}
\definecolor{lstidentifier}{rgb}{0.1, 0.1, 0.1}

\lstset{
        language=rathaxes,
        tabsize=2,
        captionpos=b,
        emptylines=1,
        frame=single,
        breaklines=true,
        extendedchars=true,
        showstringspaces=false,
        showspaces=false,
        showtabs=false,
        basicstyle=\color{black}\small\ttfamily,
        numberstyle=\scriptsize\ttfamily,
        keywordstyle=\color{lstkeyword},
        commentstyle=\color{lstcomment},
        identifierstyle=\color{lstidentifier},
        stringstyle=\color{lststring},
        backgroundcolor=\color{lstbackground}
}

\lstset{alsolanguage={[back]rathaxes}}



\begin{document}

\maketitle

\rtxmaketitleblock

\tableofcontents


\chapter{What is \rtx\ and what are its goals ?}

\rtx\ is a Domain Specific Language (DSL) and a compiler allowing to
describe a device in order to generate its driver's C code for multiple
operating systems.

Developing a driver means writing code specific to the device, as well as
writing code specific to the target operating system. In order to separate
those concerns, the \rtx\ language is split into three parts, each taking care
of one concern at a time.

By allowing the separation of OS-specific code and device-specific code, \rtx\
can transparently generate the final driver's C code for any operating system
supported. This brings us to several major features offered by \rtx\ in the
context of driver development:
\begin{itemize}
    \item Reusability of Code (be it the device description or
            the os-specific code)
    \item Complex target management including OS, version,
            BUS (PCI, USB...) used
    \item Easy security/feature fixes throughout all driver (fix the file
            impaired, and then regenerate all the drivers concerned)
    \item Easy maintenance of drivers throughout API changes (implement the
            new OS-specific code, change the target environnement,
            and generate the concerned drivers again)
    \item Straight-forward coding (there shall not be three ways
                                   to do one thing)
    \item And much more...
\end{itemize}

\section{The three parts of the language}

The three main concerns of \rtx\ are: the semantics of the calls offered by the
operating systems, the OS-specific code, and the device-specific code. Each
of those concern is associated to a part of the \rtx\ DSL. This allows the
language itself to easily evolve and to be adaptive.

\subsection{Middle-End}

What we call the \rtx\ Middle-End is the part of the DSL which describes the
semantics exposed to the user processes by the Operating system's kernels, such
as ``Open device'' and ``Close device''. The Middle-End actually tells the two
other parts of the language what they must implement in order to fulfill their
roles. It does not depend on the OS-specific architecture.

The aim is to describe the interactions allowed between the Front-End
(device-specific code) and the Back-End (Os-specific code), and it does it by
telling who must implement what, who can use what, and whether it's mandatory
or optional.

We can identify some groups of semantics, that we will call a subsystem. For
instance, every semantic associated to the USB Bus put together form the USB
subsystem. The Middle end is constituted of descriptions of subsystems.

\subsection{Back-End}

The \rtx\ Back-End language is the part of the DSL which addresses the concern
of the OS-specific code. It is actually an instrumented version of the target
language, meaning that for a C code generation (Currently the only one
supported), a Back-End file will contain instrumented C code. It contains a
specific syntax for the ``placeHolders'', which are the core of the language
instrumentalization. For more information, please read the documentation of
the Back-End language.

\subsection{Front-End}

The \rtx\ Front-End language, which is the most obvious part, allows to describe
a device in a way that is suited to those who know it the best. That means that
it allows to describe the device from both a hardware and an algorithmic point
of view. An associated configuration tells for which environment (OS, version,
etc...) to generate the source code of the driver.


\section{Final objective}

The language offers different possibilities for its usage, starting by the idea
of code reuse in the driver development. A correct device description may thus
be used for multiple OSes, as well as a correct Back-End template may be used
in the generation of multiple drivers. This means that keeping either file is
a positive point and may reduce the workload for another development task.

\subsection{A complete library}

The idea of code reuse is not new, but in the driver development field,
it is not an easy thing to do, for two reasons:
\begin{itemize}
    \item Portability: The OS APIs are almost never compatible between
            each other
    \item Target Specificity: most of the code is often specific to the
            device
\end{itemize}

With \rtx\'s model, we can reuse the OS-specific implementation or the device
implementation (as well as extend it). This brought us to envision the
distribution of a complete Back-End Library accompanying the compiler.

The idea is that as long as a Back-End template implements a semantic for a
target environment, there is no reason to do it twice, and thus, we should
provide all the implementations available to any user. This way, one could
merely have to implement the device he needs in order to generate the driver.
Of course, it depends on wether the actual developer of the template
distributes it freely or not. Thus, we are encouraging any developer using
rathaxes to make their work free of access and use to anyone, as much as
possible.

In the same mindset, we hope to be able to provide a library of device
description implementations, for the people who build their own OS, be it
for reasearch or learning experience. Then, they will only have to implement
the Back-end part for their OS, before using the library of device
descriptions in order to generate the driver's source code.


\subsection{Helping minor projects}

The fact that this library will be provided with the compiler will prove
to be beneficial for our users. We note that within those, some projects
may get bigger help from this: an operating system project won't have to
develop every driver they need, they will merely have to generate it after
coding the Back-End. Same for the little device constructors which may not
have enough manpower or development/system knowledge to develop their own
drivers.

We hope to be really beneficial for those categories of users, bringing out
the best of both their projects and \rtx.



\chapter{The role of the Middle-End in \rtx}

The Middle-End is the part of the language that describes the semantics offered
to the user processes by the Operating Systems. In order for the language to be
agnostic of the target OS, we need to identify the common possibilities, and to
express them in a way that allows us to implement consistant Back-End templates
and devices descriptions, as well as telling us what's available in \rtx\ for
use.

\section{Elements of the Middle-End}

First and foremost, you need to know what is the Middle-End code composed of.
The aim of the Middle-End is to describe the semantics of the subsystems that
we can identify in every OS.

Each subsystem is described by a named \emph{interface}. Then, each interface
can describe many kinds of elements from the language:
\begin{itemize}
    \item Types (a \rtx\ type represents a data-structured concept from the
                 subsystem)
    \item Configuration variables
    \item Sequences (a \rtx\ sequence represents a concept from the subsystem)
    \item Pointcuts (Specific to the Back-End, see its documentation
                     for more information about this)
    \item Chunks (Specific to the Back-End templates, see its documentation for
                  more information about this)
\end{itemize}

Moreover, there is a list of four qualifiers that describe the requirements of
each of those elements for either the Front-End or the Back-End. Those four
qualifiers are as follows:
\begin{itemize}
    \item required: Must be implemented by both the Front-End and the Back-End
    \item optional: May be implemented by the Front-End. Must be implemented
            by the Back-End if the Front-End implements it.
    \item provided: Callable from the Front-End, Must be implemented by the
            Back-End
    \item internal: Must be implemented by the Back-End, Callable by the
            Back-End.
\end{itemize}

We will describe how to write a proper interface in a later chapter of this
document.


\section{A typing center}

Since the Middle-End describes the semantics that are common to all OSes, it
describes every element of the language in a typing point of view. As such,
when writing a device description (Front-End) or a template implementation
(Back-End), everything is checked against the type description provided by
the associated \emph{interface}.

If the prototype of a template implementation (type-wise) does not match any
template prototype from the middle-end, then the compiler will output an error
message describing the detailed issue. This is the first way to ensure that
a developer is using correctly part or whole of the library provided to him
to create the driver for his target device. Anything that does not follow the
typing requirements and conditions of the middle-end whether it be in the
front-end or in the back-end will be rejected outright by the compiler.


\section{Linking \rtx\ as a whole}

As explained earlier in this document, the middle-end is constituted of
interfaces block containing types, sequences and configuration variables.
The fact that those are described in an interface enforces the fact that
they must be used properly, with the right types (for sequences and variables).

On another hand, both the other parts of the language, the front-end and the
back-end both use the semantics described by the middle-end. This means that
any semantic not described by the middle-end cannot be used or implemented.
This also means that when an element is described in the middle-end, then
this element must be implemented by the backend. If this is not the case,
then the associated configuration is not considered to be supported for
a given interface. In a same fashion, this means that the front-end can use
without restrictions any semantic described by the middle-end. To sum up
the relations between the three, we could say that the middle-end is kind
of a middle-man between the front-end and the backend, which tells each
what the other needs or provides.

As a result of both this typing system and the semantic role of the middle-end,
this part of the language is a real link between the front-end which uses
\emph{provided} templates or implements \emph{required or optional} templates
and the back-end which provides the system-specific implementation for both
types and sequences. This is even more important for required and optional
sequences which are partly implemented by the backend and partly implemented
by the front-end.

The reasons of the middle-end being such a buffer between front-end and
backend are multiple. One of them being that as long as OSes and peripherals
evolve, the language itself must evolve with those. The best way to do that
was to provide a way for \rtx\ developers to add new semantics easily,
meaning that the interfaces had to be writeable easily. This creates a
sort of flexibility in the language, to evolve with more ease.


\chapter{Diving into the Middle-End}




\end{document}
