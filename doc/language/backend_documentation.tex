\documentclass[american]{rtxreport}

\usepackage{color}
\usepackage{listings}

\author{David Pineau}

\title{Language Documentation : Backend}
\usepackage[utf8]{inputenc}
\rtxdoctype{Documentation}
\rtxdocref{backend\_documentation}
\rtxdocversion{0.1}
\rtxdocstatus{Draft}

\rtxdochistory{
0.1 & 07/04/2011 & David Pineau & First Draft of the documentation \\
}

\newcommand{\note}[1]{\marginpar{\scriptsize{\textdagger\ #1}}}



\definecolor{grey}{rgb}{0.90,0.90,0.90}
\definecolor{rBlue}{rgb}{0.0,0.24,0.96}
\definecolor{rRed}{rgb}{0.6,0.0,0.0}
\definecolor{rGreen}{rgb}{0.0,0.4,0.0}

\lstdefinelanguage{rathaxes}
{
    morekeywords={},
	sensitive=true,
	morecomment=[l][\color{rRed}]{//},
	morecomment=[s][\color{rRed}]{/*}{*/},
	morestring=[b][\color{rGreen}]",
	morestring=[b][\color{rGreen}]',
	keywordstyle={\color{rBlue}},
    commentstyle={\color{rRed}},
    moredirectives={import}
}[comments,strings,directives]

\lstdefinelanguage[front]{rathaxes}
{
}[keywords,comments,strings]

\lstdefinelanguage[middle]{rathaxes}
{
	morekeywords={interface, provided, required, optional, type, sequence,
                  variable},
    otherkeywords={::}
}[keywords,comments,strings]

\lstdefinelanguage[back]{rathaxes}
{
	morekeywords={with, template, decl, stmt, link, to, each},
	morecomment=[s][\color{rBlue}]{\$\{}{\}}
}[keywords,comments,strings]



\definecolor{lstbackground}{rgb}{0.95, 0.95, 0.95}
\definecolor{lstcomment}{rgb}{0, 0.12, 0.76}
\definecolor{lstkeyword}{rgb}{0.66, 0.13, 0.78}
\definecolor{lststring}{rgb}{0.67, 0.7, 0.13}
\definecolor{lstidentifier}{rgb}{0.1, 0.1, 0.1}

\lstset{
        language=rathaxes,
        tabsize=2,
        captionpos=b,
        emptylines=1,
        frame=single,
        breaklines=true,
        extendedchars=true,
        showstringspaces=false,
        showspaces=false,
        showtabs=false,
        basicstyle=\color{black}\small\ttfamily,
        numberstyle=\scriptsize\ttfamily,
        keywordstyle=\color{lstkeyword},
        commentstyle=\color{lstcomment},
        identifierstyle=\color{lstidentifier},
        stringstyle=\color{lststring},
        backgroundcolor=\color{lstbackground}
}

\lstset{alsolanguage={[back]rathaxes}}



\begin{document}

\maketitle

\rtxmaketitleblock

\tableofcontents

\abstract{}

\chapter{The template language of \emph{Rathaxes}}


\section{Use-Case}

As explained earlier, developing a driver means writing code specific to the
device, as well as writing code specific to the target operating system. The
template language included in \emph{Rathaxes} aims to facilitate operating
system specific code writing.

By allowing to define and implement templates of code that will be effectively
used depending on whether the template's configuration matches with the calling
code's configuration, \emph{Rathaxes} can transparently generate the driver's C
code for any operating system supported.

This chapter will describe how to write a template in \emph{Rathaxes} language.


\section{The “with” block}

The “with” block is the condition to match in order to use the template's
implementation for the defined template prototype (the prototype will be
described later on in this document). The templates will be written inside the
“with” block, and will be explained later.

\subsection{BNF Syntax}

\lstset{}
\begin{lstlisting}
// This is the root entry point of the BNF

with_block ::= "with" config_value_list '{' [ template_block ]* '}'

config_value_list ::= [ config_value ]*

config_value ::= config_variable config_condition config_value

config_variable ::= identifier

config_condition ::= '<' | "<=" | '=' | "=>" | '>'

config_value ::= identifier | version

version ::= number [ '.' number ]*

identifier ::= [ 'a'..'z' | 'A'..'Z' ] [ 'a'..'z' | 'A'..'Z' ]*

number ::= [ '0'..'9' ]*

\end{lstlisting}

\subsection{The configuration variables}

The middle-end part of the language, constituted of interfaces, declares
different variables which values must be defined in the front-end
implementation of a device driver. This is done inside a \emph{configuration
block}. We will call those variables the \emph{configuration variables}.  Those
variables are the things that define which template code can be used or not. In
fact, since the templates' aim is to implement OS-specific code, they can't be
used anywhere. Thus, the selection process is built around those configuration
variables. The “with” block tells for which values of which configuration
variables the templates are to be activated and possibly used.

While writing a template code for \emph{Rathaxes}, you \emph{have to consider}
the target of your code. Will it be for this OS ? or that one ? Which version ?
Which sub-system ? All those are relevant informations contained by the proper
\emph{configuration variables}, that can impact greatly the code generation
process.

Now, how to write it ? It is actually quite simple :
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    // Put some templates here.
}
\end{lstlisting}

As you can read, the keyword "with" is to be written first of all things. It is
then followed by a coma-separated list of \emph{configuration variables}
matching conditions. Three main rules are to be respected :
\begin{itemize}
    \item The configuration variable's name must match \emph{exactly} the one
          written in the interface the templates implements
          (fully or partially).
    \item The condition can be one of the 5 following : 
        \begin{itemize}
            \item < : The value of the configuration must be lesser than the
                      value written in the “with” statement
                      (only valid for numbers and versions),
            \item <= : The value of the configuration must be lesser or equal
                       to the value written in the “with” statement
                      (only valid for numbers and versions),
            \item = : The value of the configuration must be equal to the
                      value written in the “with” statement
                      (valid for strings, numbers and versions)
            \item >= : The value of the configuration variable must be greater
                       or equal to the value written in the “with” statement
                       (valid only for numbers and versions),
            \item > : The value of the configuration variable must be greater
                      than the value written in the “with” statement
                      (valid only for numbers and versions).
        \end{itemize}
    \item The values can be of on of these three types :
        \begin{itemize}
            \item string : Written as an identifier, without any kind of quote
                           (ex: Linux, Windows),
            \item number : simple number (ex : 243, 7623, 1, 0),
            \item version : a suite of numbers separated by points (ex: 2.6.24).
        \end{itemize}
\end{itemize}

With this, you should be able to write a proper “with” statement, that will
allow the compiler to select your templates for the right C code generation.
Now, you must write the templates, or your “with” block will be useless.


\section{Defining a template}

The content of a template is the very code that will be part (after full
template resolution) of the final generated C code. The template itself
describes either a type or a sequence (\emph{Rathaxes} function), and how it
will really be implemented.  We will not describe the templated C code here
(ie: the content of the template block), since it will be described in the next
section, but know that it is some C code with a bit of \emph{Rathaxes} language
added.

Since the type template is a bit specific, we will describe its content in a
later section.

\subsection{BNF Syntax}

\lstset{}
\begin{lstlisting}
// This is the root entry point of the BNF

template_block ::= "template" type_key template_prototype
                    '{' [ templated_c_code ]* '}'

type_key ::= "type" | "sequence"

template_prototype ::= identifier '(' [tpl_var_list]? ')'

tpl_var_list ::= tpl_var_type tpl_var_id [ ',' tpl_var_type tpl_var_id ]*

tpl_var_type ::= identifier

tpl_var_id ::= identifier

identifier ::= [ 'a'..'z' | 'A'..'Z' | '_' ]
               [ '0'..'9' | 'a'..'z' | 'A'..'Z' | '_' ]*

\end{lstlisting}

\subsection{The template's prototype}

In order to write a template, one must first write the "template" keyword.
Then, this keyword is followed by a “type” keyword, describing the kind of
template that is being written. Next comes what we'll call the \emph{template
prototype}. This prototype includes the name of the “sequence” or “type” and its
parameters' types and names.

The template's prototype is the part that identifies a specific templates.

The name of the template respects the rules of any C identifier. The parameters
of the template are actually \emph{Rathaxes} types and variables to be used in
the template's code in order to generate valid and coherent C code.

Here is how you can write a sequence template :
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    // here we can identify the bnf structure : 
//  pkeyword skeyword name(ParamType1 param1, ParamType2 param2)
    template sequence foo(Context ctx, register reg)
    {
        // put the template's code here'
    }
}
\end{lstlisting}

\subsection{Template overloading}

\emph{Rathaxes} supports template overloading, meaning that one sequence or
type (identified through the template's name, an identifier) can be parametered
with different types of variables. You could then write two templates named
"foo", that receive different types of parameters:

\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    // this one here manipulates a register
    template    foo(Context ctx, register reg)
    {
        // put the template's code here'
    }

    // This one only uses context's informations
    template    foo(Context ctx)
    {
        // put the template's code here'
    }
}
\end{lstlisting}


\section{Using template variables}

Well, we can write templates. Cool. But there's no meaning to it if the
template code is totally static. What would the meaning of a template that can't
be modified through some parameters be, since it would be the same as a snippet
of C code. That is the very reason of the existence of the template's
parameters. They can be manipulated in the blocks delimited by "\$\{" and "\}",
and there are three uses of this syntax. Let's see what are those uses.

\subsection{BNF Syntax}

\lstset{}
\begin{lstlisting}
// This is the root entry point of the BNF

root ::= [ prefix ]? [ template_braced_code ]+ [ postfix ]?

template_braced_code ::= "${" tpl_each | tpl_link | tpl_var '}'

tpl_each ::= "each" tpl_var "as" alias "in" tpl_proto

tpl_link ::= "link" tpl_var_list "to" tpl_proto

tpl_var ::= identifier [ '.' tpl_var_field ]*

tpl_var_field ::= identifier

tpl_proto ::= identifier '(' [tpl_proto_var_list]? ')'

tpl_proto_var_list ::= tpl_var_type [ ',' tpl_var_type ]*

tpl_var_type ::= identifier

identifier ::= [ 'a'..'z' | 'A'..'Z' | '_' ]
               [ '0'..'9' | 'a'..'z' | 'A'..'Z' | '_' ]*

\end{lstlisting}

\subsection{Template variable structure}

First of all, each template variable is structured in a specific way. For
example, the register type contains a name, an address, and possibly a
collection of named fields. The mapping of each template type is described in
the specific type template. Please refer to the associated template to obtain
more information about any template variable mapping.

\subsection{Identifier concatenation}

The first and simplest way to use a template variable is to use it in order to
create C identifiers containing the name associated with the template variable.
Take the example of the buffer type. We could be using different buffers with
different names in the front-end of Rathaxes, but that should not hamper the
process of generation of the C code. Actually, if we did use the same generated
name of manipulation function for both buffers, we could in the end have an
improper (and even undefined), unwanted behaviour. We may then want to use the
variable's contained name to generate identifiers.

That is why the syntax accepts prefixes and postfixes to the "\$\{"\ldots"\}"
syntax. Thus, writing the following template with a register named "eeprm":
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    // this one here manipulates a register
    template    foo(Context ctx, register reg)
    {
        int     the_${reg.name}_flag;
    }
}
\end{lstlisting}

could then generate (for the right \emph{configuration variables}):
\lstset{language=C}
\begin{lstlisting}
int the_eeprm_flag;
\end{lstlisting}
\lstset{language={[back]rathaxes}}

This technique can of course be used for any identifier, be it a function
identifier, a macro name, a typedef, etc.

\subsection{Using a template from another}

Sometimes, there is a need to separate some functionnalities or templates into
many much tinier ones (maybe for reusability ?). There is also sometimes a need
to use a template that we know exists, and we do not want to rewrite it
completely inside our own one. Thus, we need a way to call or use a template
from another.

In order to do that, here is the general syntax :
\begin{lstlisting}
${link template_variable_list to template_prototype};
\end{lstlisting}

The template variable list is a coma-separated list of template variables that
are currently accessible within the template. The template prototype is as
described earlier, what identifies the template to be linked to the current
one.

The effect is that the linked template's code will be included after resolution
through the template variables given as parameters. The variables in the
variable list must match the number and types of parameters in the linked
template prototype.

Thus, we could write : 
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    template    foo(Context ctx, register reg)
    {
        ${link reg to bar(register)};
    }

    template    bar(register reg)
    {
        int     the_${reg.name}_flag;
    }
}
\end{lstlisting}

The “each” syntax is based on the same model as the “link” syntax, but allows to
link each element of a collection to the same template. This prevents writing
loops that would be error-prone. It would be written like this :

\begin{lstlisting}
${each template_variable as alias to template_prototype};
\end{lstlisting}

%% TODO FIXME
%% The rest of the "EACH" syntax is to be defined and then
%% the documentation written....

\subsubsection{Inheritance of the configuration variables}

Now we can both create identifiers with our template variables, and link
templates one to another. But there is an obvious limitation : the configuration
variables. Indeed, since a template is selected by the \emph{configuration
variables}, it would be inconsistent to allow using different ones for the
linked template.  Thus, linking to another template means that this template
must be compatible with the current \emph{configuration variables}.


\section{Accessible template variables from a template block}

We know that we can use the template parameters inside the template's block.
Good. But there are times when we would want to use either C-declared variables
or \emph{configuration variables}' values. So the variables may not be enough.
That is why the language offers contextual template variables.

\subsection{Contextual template variables}

The contextual template variables can be separated into two categories :
\begin{enumerate}
    \item Global variables,
    \item Local variables.
\end{enumerate}

The global variable contains every configuration variable. Each one is to be
accessed as fields of the template variable named "global", with their own
names.

The local variable contains every C variable declared in the block of the
template. This allows using algorithms on those variables, and you may find it
quite useful. It is accessible through the template variable named "local", and
have to be accessed through the variable's name.

Those features imply that one can not name his template's parameters "global"
or "local". The compiler would greet one with a nice error in those cases.


\end{document}
