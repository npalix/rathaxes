\documentclass[american]{rtxreport}

\usepackage{color}
\usepackage{listings}

\author{David Pineau}

\title{Language Documentation: Backend}
\usepackage[utf8]{inputenc}
\rtxdoctype{Documentation}
\rtxdocref{backend\_documentation}
\rtxdocversion{0.2}
\rtxdocstatus{Draft}

\rtxdochistory{
0.1 & 07/04/2011 & David Pineau & First Draft of the documentation \\
0.2 & 09/04/2011 & David Pineau & Update to simplify some parts of the doc \\
}

\newcommand{\note}[1]{\marginpar{\scriptsize{\textdagger\ #1}}}



\definecolor{grey}{rgb}{0.90,0.90,0.90}
\definecolor{rBlue}{rgb}{0.0,0.24,0.96}
\definecolor{rRed}{rgb}{0.6,0.0,0.0}
\definecolor{rGreen}{rgb}{0.0,0.4,0.0}

\lstdefinelanguage{rathaxes}
{
    morekeywords={},
	sensitive=true,
	morecomment=[l][\color{rRed}]{//},
	morecomment=[s][\color{rRed}]{/*}{*/},
	morestring=[b][\color{rGreen}]",
	morestring=[b][\color{rGreen}]',
	keywordstyle={\color{rBlue}},
    commentstyle={\color{rRed}},
    moredirectives={import}
}[comments,strings,directives]

\lstdefinelanguage[front]{rathaxes}
{
}[keywords,comments,strings]

\lstdefinelanguage[middle]{rathaxes}
{
	morekeywords={interface, provided, required, optional, type, sequence,
                  variable},
    otherkeywords={::}
}[keywords,comments,strings]

\lstdefinelanguage[back]{rathaxes}
{
	morekeywords={with, template, type, sequence, decl, stmt, link, to, each},
	morecomment=[s][\color{rBlue}]{\$\{}{\}}
}[keywords,comments,strings]



\definecolor{lstbackground}{rgb}{0.95, 0.95, 0.95}
\definecolor{lstcomment}{rgb}{0, 0.12, 0.76}
\definecolor{lstkeyword}{rgb}{0.66, 0.13, 0.78}
\definecolor{lststring}{rgb}{0.67, 0.7, 0.13}
\definecolor{lstidentifier}{rgb}{0.1, 0.1, 0.1}

\lstset{
        language=rathaxes,
        tabsize=2,
        captionpos=b,
        emptylines=1,
        frame=single,
        breaklines=true,
        extendedchars=true,
        showstringspaces=false,
        showspaces=false,
        showtabs=false,
        basicstyle=\color{black}\small\ttfamily,
        numberstyle=\scriptsize\ttfamily,
        keywordstyle=\color{lstkeyword},
        commentstyle=\color{lstcomment},
        identifierstyle=\color{lstidentifier},
        stringstyle=\color{lststring},
        backgroundcolor=\color{lstbackground}
}

\lstset{alsolanguage={[back]rathaxes}}



\begin{document}

\maketitle

\rtxmaketitleblock

\tableofcontents

\abstract{
Rathaxes is a Domain Specific Language (DSL) and a compiler allowing to
describe a device in order to generate its driver's C code for multiple
operating systems.

Developing a driver means writing code specific to the device, as well as
writing code specific to the target operating system. The backend part of the
\rtx language aims to facilitate operating system specific code writing.

By allowing the separation of OS-specific code and device-specific code, \rtx
can transparently generate the final driver's C code for any operating system
supported.
}

\chapter{The “with” block}

The “with” statement describes the conditions to be matched in order to select
the specific implementation written inside its block.

These conditions will for example allow one to tell the compiler that the code
that the “with” block contains is to be used only for a specific operating
system (e.g. Linux), with conditions over the version (e.g. version > 2.6.24).

The code contained in the block of this statement will be described in a later
chapter.

\section{The configuration variables}

The middle-end part of the language, constituted of interfaces, declares
different variables. We will call those variables the \emph{configuration
variables}. Those variables are the elements that define which system-specific
implementation can be used or not. Indeed, since the “with” block content's aim
is to implement OS-specific code, they can't be used for every operating system.
Thus, the selection process is built around those configuration variables.

The “with” block tells for which values of which configuration variables the
templates are to be activated and possibly used.  

While writing a system-specific code for \rtx, you \emph{have to consider}
the target of your code. Will it be for this OS? or that one? Which version?
Which sub-system? All those are relevant informations contained by the proper
\emph{configuration variables}, and can impact greatly the code generation
process.

Now, how can I write it? It is actually quite simple:
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    // Put some templates here.
}
\end{lstlisting}

As you can read, the keyword "with" is to be written first of all things. It is
then followed by a coma-separated list of \emph{configuration variables} and
their matching conditions. Three main rules are to be respected:
\begin{itemize}
    \item The configuration variable's name must match \emph{exactly} the one
          written in the interface the “with” block wishes to implement
          (fully or partially).
    \item The condition (or comparison) can be one of the 5 following: 
        \begin{itemize}
            \item <: only valid for numbers and versions,
            \item <=: only valid for numbers and versions,
            \item =: valid for strings, numbers and versions,
            \item >=: valid only for numbers and versions,
            \item >: valid only for numbers and versions.
        \end{itemize}
    \item The values can be of on of these three types:
        \begin{itemize}
            \item string: Written as an identifier, without any kind of quote
                           (e.g. Linux, Windows),
            \item number: simple number (e.g. 243, 7623, 1, 0),
            \item version: a suite of numbers separated by points (e.g. 2.6.24).
        \end{itemize}
\end{itemize}

With this, you should be able to write a proper “with” statement that will
allow the compiler to select your system-specific for the right C code
generation. Now, you must write the the content of this “with” block:
the templates.


\chapter{Defining a template}

The content of a template is the very code that will be part (after full
template resolution) of the final generated C code. The template itself
describes either a type or a sequence (\rtx function), and how it
will really be implemented. We will not describe the templated C code here
(ie: the content of the template block), since it will be described in the next
section, but know that it is some instrumentalized C code

Since the type template is a bit specific, we will describe its content in a
later section.

\section{The template's prototype}

In order to write a template, one must first write the "template" keyword.
Then, this keyword is followed by a type keyword, describing the kind of
template that is being written. Next comes what we'll call the \emph{template
prototype}. This prototype includes the name of the “sequence” or “type” and its
parameters' types and names.

The template's prototype is the part that identifies a specific templates.
Be careful, though, not to confuse a template and its implementation: a
template may not necessarily transcribe itself into a C function.

The name of the template is a simple alphanumeric identifier (this can include
underscores too). The parameters of the template are actually \rtx types and
variables to be used in the template's code in order to generate valid and
coherent C code.

Here is how you can write a sequence template:
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    // here we can identify the bnf structure: 
//  pkeyword skeyword name(ParamType1 param1, ParamType2 param2)
    template sequence foo(Context ctx, register reg)
    {
        // put the template's code here'
    }
}
\end{lstlisting}

\section{Template overloading}

\rtx supports template overloading, meaning that one sequence or type
(identified through the template's name, an identifier) can be parametered with
different types of variables. You could then write two templates named "foo",
that receive different types of parameters:

\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    // this one here manipulates a register
    template sequence foo(Context ctx, register reg)
    {
        // put the template's code here'
    }

    // This one only uses context's informations
    template sequence foo(Context ctx)
    {
        // put the template's code here'
    }
}
\end{lstlisting}


\chapter{Using template variables}

Well, we can write templates. Cool. Now, we need to use those as real templates
of code, that will result in different generated codes. That is the very reason
of the existence of the template's parameters. They can be manipulated in the
blocks of code delimited by "\$\{" and "\}", and there are three uses of this
syntax. Let's see what are those uses.

\section{Template variable structure}

First of all, each template variable is structured in a specific way. For
example, the register type contains a name, an address, and possibly a
collection of named fields. The mapping of each template type is described in
the specific type template. Please refer to the associated template to obtain
more information about any template variable mapping.

\section{Identifier concatenation}

The first and simplest way to use a template variable is to use it in order to
create C identifiers containing the name associated with the template variable.
Take the example of the buffer type. We could be using different buffers with
different names in the front-end of Rathaxes, but that should not hamper the
process of generation of the C code. Actually, if we did use the same generated
name of manipulation function for both buffers, we could in the end have an
improper (and even undefined), unwanted behaviour. We may then want to use the
variable's contained name to generate identifiers.

That is why the syntax accepts prefixes and postfixes to the "\$\{"\ldots"\}"
syntax. Thus, writing the following template with a register named "eeprm":
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    // this one here manipulates a register
    template sequence foo(Context ctx, register reg)
    {
        int     the_${reg.name}_flag;
    }
}
\end{lstlisting}

could then generate (for the right \emph{configuration variables}):
\lstset{language=C}
\begin{lstlisting}
int the_eeprm_flag;
\end{lstlisting}
\lstset{language={[back]rathaxes}}

This technique can of course be used for any identifier, be it a function
identifier, a macro name, a typedef, etc.

\section{Using a template from another}

Sometimes, there is a need to separate some functionnalities or templates into
many much tinier ones (maybe for reusability ?). There is also sometimes a need
to use a template that we know exists, and we do not want to rewrite it
completely inside our own one. Thus, we need a way to call or use a template
from another.

In order to do that, here is the general syntax:
\begin{lstlisting}
${link template_variable_list to template_prototype};
\end{lstlisting}

The template variable list is a coma-separated list of template variables that
are currently accessible within the template. The template prototype is as
described earlier, what identifies the template to be linked to the current
one.

The effect is that the linked template's code will be included after resolution
through the template variables given as parameters. The variables in the
variable list must match the number and types of parameters in the linked
template prototype.

Thus, we could write: 
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    template sequence foo(Context ctx, register reg)
    {
        ${link reg to bar(register)};
    }

    template sequence bar(register reg)
    {
        int     the_${reg.name}_flag;
    }
}
\end{lstlisting}


%% TODO FIXME
%% The rest of the "EACH" syntax is to be defined and then
%% the documentation written....
EACH SYNTAX TBD
%%The “each” syntax is based on the same model as the “link” syntax, but allows to
%%link each element of a collection to the same template. This prevents writing
%%loops that would be error-prone. It would be written like this:

%%\begin{lstlisting}
%%${each template_variable as alias to template_prototype};
%%\end{lstlisting}


\subsection{Inheritance of the configuration variables}

Now we can both create identifiers with our template variables, and link
templates one to another. But there is an obvious limitation: the configuration
variables. Indeed, since a template is selected by the \emph{configuration
variables}, it would be inconsistent to allow using different ones for the
linked template. Thus, linking to another template means that this template
must be compatible with the current \emph{configuration variables}.


\chapter{Accessible template variables from a template block}

We know that we can use the template parameters inside the template's block.
Good. But there are times when we would want to use either C-declared variables
or \emph{configuration variables}' values. So the variables may not be enough.
That is why the language offers contextual template variables.

\section{Contextual template variables}

The contextual template variables can be separated into two categories:
\begin{enumerate}
    \item Global variables,
    \item Local variables.
\end{enumerate}

The global variable contains every configuration variable. Each one is to be
accessed as fields of the template variable named "global", with their own
names.

The local variable contains every C variable declared in the block of the
template. This allows using algorithms on those variables, and you may find it
quite useful. It is accessible through the template variable named "local", and
have to be accessed through the variable's name.

For example, in order to give a C variable to a linked template, one would
write:
\begin{lstlisting}
with os=Linux, version >= 2.6.24
{
    template sequence multiset(register reg)
    {
        {
            // declare a tmp variable of the same type as "reg"
            ${register}     tmp;
            // Here we use "local.tmp" meaning we use the C variable tmp
            tmp = ${link reg to get(register)};
            tmp |= (val & mask);
            ${link reg, local.tmp to set(register, register)};
        }
    }

    template sequence get(register reg)
    {
        // read a byte
        inb(${reg.addr})
    }

    template sequence set(register rreg, register lreg)
    {
        // Set the real register to the temporary one's value.
        outb(${rreg.addr}, ${lreg.name})
    }
}
\end{lstlisting}

Those features imply that one can not name his template's parameters "global"
or "local". The compiler would greet one with a nice error in those cases.


\section{Annex : BNF}

To sum up the syntax of the backend of \rtx, here is a BNF that describes it
in a relatively complete fashion:

\lstset{}
\begin{lstlisting}
// This is the root entry point of the BNF

with_block ::= "with" config_value_list '{' [ template_block ]* '}'

config_value_list ::= [ config_value ]*

config_value ::= config_variable config_condition config_value

config_variable ::= identifier

config_condition ::= '<' | "<=" | '=' | "=>" | '>'

config_value ::= identifier | version

template_block ::= "template" type_key template_prototype
                    '{' [ C | template_placeholder ]* '}'

C ::= // this is the whole C syntax that we wont define here...

type_key ::= "type" | "sequence"

template_prototype ::= identifier '(' [tpl_var_list]? ')'

tpl_var_list ::= tpl_var_type tpl_var_id [ ',' tpl_var_type tpl_var_id ]*

template_placeholder ::= [ prefix ]? [ template_braced_code ]+ [ postfix ]?

template_braced_code ::= "${" tpl_each | tpl_link | tpl_var '}'

tpl_each ::= "each" tpl_var "as" alias "in" tpl_proto

tpl_link ::= "link" tpl_var_list "to" tpl_proto

tpl_var ::= identifier [ '.' tpl_var_field ]*

tpl_var_field ::= identifier

tpl_proto ::= identifier '(' [tpl_proto_var_list]? ')'

tpl_proto_var_list ::= tpl_var_type [ ',' tpl_var_type ]*

tpl_var_type ::= identifier

tpl_var_id ::= identifier

version ::= number [ '.' number ]*

number ::= [ '0'..'9' ]*

identifier ::= [ 'a'..'z' | 'A'..'Z' | '_' ]
               [ '0'..'9' | 'a'..'z' | 'A'..'Z' | '_' ]*

\end{lstlisting}





\end{document}
