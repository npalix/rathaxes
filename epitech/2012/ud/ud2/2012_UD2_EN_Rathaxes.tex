\documentclass[american]{rtxreport}

\usepackage{color}
\usepackage{listings}

\usepackage[utf8]{inputenc}

\title{User documentation}
\author{Thomas Luquet}

\rtxdoctype{UD2}
\rtxdocstatus{Draft}
\rtxdocversion{0.1}

\rtxdochistory
{
0.1 & 11/03/2011 & Thomas Luquet & Initial Import \\
\hline
0.2 & 11/03/2010 & Louis Opter & Some corrections and make it compile \\
}

\definecolor{lstbackground}{rgb}{0.95, 0.95, 0.95}
\definecolor{lstcomment}{rgb}{0, 0.12, 0.76}
\definecolor{lstkeyword}{rgb}{0.66, 0.13, 0.78}
\definecolor{lststring}{rgb}{0.67, 0.7, 0.13}
\definecolor{lstidentifier}{rgb}{0.1, 0.1, 0.1}

\lstset{
        tabsize=2,
        captionpos=b,
        emptylines=1,
        frame=single,
        breaklines=true,
        extendedchars=true,
        showstringspaces=false,
        showspaces=false,
        showtabs=false,
        basicstyle=\color{black}\small\ttfamily,
        numberstyle=\scriptsize\ttfamily,
        keywordstyle=\color{lstkeyword},
        commentstyle=\color{lstcomment},
        identifierstyle=\color{lstidentifier},
        stringstyle=\color{lststring},
        backgroundcolor=\color{lstbackground}
}

\definecolor{grey}{rgb}{0.90,0.90,0.90}
\definecolor{rBlue}{rgb}{0.0,0.24,0.96}
\definecolor{rRed}{rgb}{0.6,0.0,0.0}
\definecolor{rGreen}{rgb}{0.0,0.4,0.0}

\lstdefinelanguage{rathaxes}%
{
	morekeywords={DECLARE, SEQUENCE, INTERFACE, IMPLEMENTATION, FROM, READ,
        OPTIONAL, CONFIGURATION_VARIABLE, USE, AS, WITH, SEQUENCES, ON, ELSE,
        LET, PROVIDES, REQUIRE, THROWS, FINALLY, FOREACH, IN, AND, OR, THROW,
        HANDLE_ERROR, NOT, REGISTER, LIKE, BIT, INTEGER, DOUBLE, BOOLEAN,
        STRING, MAPPED_AT, PCI},%
	sensitive=true,%
	morecomment=[l][\color{rRed}]{//},%
	morecomment=[l][\color{rRed}]{\#},%
	morecomment=[s][\color{rRed}]{/*}{*/},%
	morestring=[b][\color{rGreen}]",%
	morestring=[b][\color{rGreen}]',%
	keywordstyle={\color{rBlue}}%
}[keywords,comments,strings]
\begin{document}

\maketitle

\begin{abstract}

This document is the user documentation for the \emph{\rtx\ 2012} project.

It includes a guide and an example to install and use \rtx. It contains also a
description of the language.

\rtx\ is a multi-platform peripheral driver generator.

It is realized by the \rtx\ EIP team of year 2012 and comes in the continuity
with the work done by the year 2009 team.

This document is designed for \rtx\ driver coders and for the EIP laboratory
team.

\end{abstract}

\rtxmaketitleblock

\tableofcontents

\chapter{Prerequisites}

\section{Hardware}

Rathaxes works on all modern computer.

\section{Software}

Code Worker is needed. You can download it from the official website:
\url{http://codeworker.free.fr/}.

To install the latest version of \rtx\ you need to use Mercurial, the version
control software.

You can download it and find its installation instructions on the following
website: \url{http://mercurial.selenic.com/}.

\chapter{Install \rtx}

\section{Download \rtx}

To download the last build of \rtx. Open a terminal and type:

\begin{verbatim}
hg clone https://rathaxes.googlecode.com/hg/ rathaxes
\end{verbatim}

%----\section{Compiling \rtx}

\chapter{Driver development}

\section{Intro}

The chapter will learnt you how to develop driver in \rtx.
The first section describe the language, next you'll find an \emph{Hello Word} written in RTX.


\section{RTX Language}
%---Conditions-------------------------------

\subsection{Condition}


\subsubsection{Conditional Operator}

Simple condition :

\begin{lstlisting}
ON expression LET sequence(param);
\end{lstlisting}


\subsubsection{Logical Operator}


Three logical opartor are build for \rtx\ : \emph{OR, AND, AND NOT}


Definition :
\begin{lstlisting}
ON expression1 OR expression2 LET sequence1(param) // OR
ON expression3 AND expression4 LET sequence2(param) // AND
ON expression5 AND NOT expression6 LET sequence3(param) // AND NOT
ELSE sequence4(param);
\end{lstlisting}

\subsubsection{Loop}

All language need loop to repeat action.
\emph{FOREACH} is choosen for \rtx.

Definition :

\begin{lstlisting}
FOREACH TYPE e IN collection {
	// do something
};
\end{lstlisting}


%---Types---------------------------------
\subsection{Types}

\subsubsection{Register}

Syntax :
\begin{lstlisting}
DECLARE REGISTER(RW) BIT[8] Register_Type LIKE(........);
\end{lstlisting}

Instance :
\begin{lstlisting}
DECLARE REGISTER Register_type Register_name Register_type MAPPED_AT address ;
\end{lstlisting}

Example :
\begin{lstlisting}
DECLARE REGISTER SomeE1000Register eerd PCI MAPPED_AT PCI_BAR_1 + some_offset ;
\end{lstlisting}


\subsubsection{Primary types}

\begin{lstlisting}
DECLARE INTEGER i_name = 123;
DECLARE DOUBLE d_name = 123.123;
DECLARE BOOLEAN b = TRUE OR FALSE ;
DECLARE STRING str = `` hello , world ! `` ;

\end{lstlisting}

\subsubsection{Adress}
\begin{lstlisting}
DECLARE ADDRESS addr1 ALIGNED_ON nbrbits OFFSET off ;
\end{lstlisting}

\subsubsection{Buffer}

Example :
\begin{lstlisting}
DECLARE BUFFER MyBufferType SIZE 2048 ADDRESS_ALIGNED_ON 16;
DECLARE MyBufferType mybuffer ;
SET ( my_buffer [3] , unoctet ) ;
\end{lstlisting}


\begin{lstlisting}
DECLARE BUFFER MyBufferType SIZE 2048 ADDRESS_ALIGNED_ON 16 {
  [0..4] AS low_address ;
  [5] AS status {
    (0) -> OK ;
    (1) -> ERROR ;
  };
};
DECLARE MyBufferType mybuffer ;
SET ( my_buffer . status , MyBufferType . status . OK ) ;
\end{lstlisting}

\subsubsection{Collections}

\begin{lstlisting}
DECLARE VECTOR VectorType ELEMENT_TYPE MyBufferType SIZE 10;
DECLARE VectorType my_vector ;
PUSH ( my_vector , element ) ;
POP ( my_vector ) ;
REALLOC_VECTOR ( my_vector , new_size ) ;
\end{lstlisting}

%---Algorithm----------------------
\subsubsection{Algorithm}

\subsubsection{Affectation}

\begin{lstlisting}
DECLARE INTEGER i = 2; // Premiere initialisation
i = 3; // ERROR
SET (i , 3) ; 
DECLARE VECTOR vtype .....;
DECLARE vtype v ;
SET (v , ...) ;
\end{lstlisting}

\subsubsection{Waiting}

\emph{Not setting yet.}

\subsubsection{POST and PRE condition}
\emph{Not setting yet.}

\subsection{Hello World}

This \emph{hello world} explain how to build a simple serial dirver in RTX.

\begin{lstlisting}
DEVICE rs232
{
        REGISTER(R) BIT[8] rcv_buff LIKE(........) @(ioport + 0);

        REGISTER(W) BIT[8] snd_buff LIKE(........) @(ioport + 0);

        REGISTER(RW) BIT[8] ier LIKE (**......)
                @(resources::ioport + 1)
                {
                        [0] AS data_available;
                        [1] AS transmitter_empty;
                        [2] AS line_status_change;
                        [3] AS modem_status_change;
                        [4] AS sleep_mode;
                        [5] AS low_power_mode;
                };

        REGISTER(RW) BIT[8] lcr LIKE (........) @(ioport + 3)
                {
                        [0..1] AS word_lengh
                        {
                                (00) -> _5bits;
                                (01) -> _6bits;
                                (10) -> _7bits;
                                (11) -> _8bits;
                        };

                        [2] AS stop_bits
                        {
                                (0) -> _1stop_bits;
                                (1) -> _2stop_bits;
                        };

                        [3..5] AS parity_type
                        {
                                (000) -> none;
                                (001) -> odd;
                                (011) -> even;
                                (101) -> high;
                                (111) -> low;
                        };

                        [6] AS break_signal
                        {
                                (0) -> disable;
                                (1) -> enable;
                        };

                        [7] AS dlab
                        {
                                (0) -> buffers;
                                (1) -> clock;
                        };
                };

        //Modem Control
        REGISTER(RW) BIT[8] mcr LIKE (****.*..) @(ioport + 4)
                {
                        [0] AS dtr; // Data Terminal Ready
                        [1] AS rts; // Request To Send
                        [3] AS ao2; // Auxiliary Output 2
                };

        REGISTER(RW) BIT[8] dll LIKE(........) @(ioport + 0);

        REGISTER(RW) BIT[8] dlm LIKE(........) @(ioport + 1);

        REGISTER(R) BIT[8] lsr LIKE(........) @(ioport + 5)
                {
                        [0] AS data_available
                        {
                                (0) -> FALSE;
                                (1) -> TRUE;
                        };

                        // customised name for the bits state
                        [1] AS overrun
                        {
                                (0) -> good;
                                (1) -> error;
                        };

                        [2] AS parity
                        {
                                (0) -> good;
                                (1) -> error;
                        };

                        [3] AS framing
                        {
                                (0) -> good;
                                (1) -> error;
                        };

                        [4] AS break_signal
                        {
                                (0) -> TRUE;
                                (1) -> FALSE;
                        };

                        [5] AS thr_state
                        {
                                (0) -> transmitting;
                                (1) -> empty;
                        };

                        [6] AS thr_and_line
                        {
                                (0) -> transmitting;
                                (1) -> empty_idle;
                        };

                        [7] AS data_fifo
                        {
                                (0) -> good;
                                (1) -> error;
                        };
                };

        PUBLIC PROPERTY WORD divisor
        {
                SET
                {
                        SET(lcr.dlab, 1);
                        SET(dll, value[0..7]);
                        SET(dlm, value[8..15]);
                                 SET(lcr.dlab, 0);
                }

                GET
                {
                        SET(lcr.dlab, 1);
                        SET(value[0..7], dlm);
                        SET(value[8..15], dll);
                        SET(lcr.dlab, 0);
                }
        };
};

KERNEL_INTERFACES interface_rs232
{
        read(CONTEXT context, BUFFER output)
        {
                LOG(``my_rs232 [read]\\n'');
                CONCAT(output, rcv_buff)
                        PRE
                        {
                                WAIT(lsr.data_available, lsr.data_available->TRUE);
                        };
        };

        write(CONTEXT context, BUFFER input)
        {
                LOG(``my_rs232 [write]\\n'');
                WAIT(lsr.thr_and_line, lsr.thr_and_line->empty_idle);
                COPY(snd_buff, input)
                        PRE
                        {
                                WAIT(lsr.thr_state, lsr.thr_state->empty);
                        };
        };

        on_plug(CONTEXT context)
        {
                LOG(``my_rs232 [on_plug]\\n'');
                SET(divisor, 0x0c);

                // Set mode 8 data bits, 1 stop bit, no parity
                SET(lcr.word_lengh, lcr.word_lengh->_8bits);
                SET(lcr.stop_bits, lcr.stop_bits->_1stop_bits);
                SET(lcr.parity_type, lcr.parity_type->none);

                SET(mcr.rts, 1);
                SET(mcr.dtr, 1);
        };

        open(CONTEXT context)
        {
                LOG(``my_rs232 [open]\\n'');
        };

        close(CONTEXT context)
        {
                LOG(``my_rs232 [close]\\n'');
        };
};

SEQUENCES seq_rs232
{
        my_sequence(CONTEXT context, DWORD in, BUFFER out, BIT fail)
        {
                LOG(``my_rs232 [my_sequence]\\n'');
        };
};

DRIVER my_rs232
{
        DEVICES = rs232;
};

CONFIGURATION
{
        ARCH = x86;
        ioport = 0x03f8;

        OS linux
        {
                MAJOR = -1;
                TYPE = chardev;
                ioctl_magicnumber = 0xf5;
                VERSION = ``2.6.18'';
        };

        OS windows
        {
                VERSION = ``Windows'';
        DEVICE_NAME = GUID_DEVINTERFACE_RATHAXES_SERIAL;
        DEVICE_GUID = ``1ADB9D41-6FE5-432e-A5FF-9B6911A150A4'';
        CLASS_NAME = GUID_DEVCLASS_RATHAXES;
        CLASS_GUID = ``E20808D9-5E08-4a2a-80A1-84DA0B2180AB'';
                DISPATCH_MODE = WdfIoQueueDispatchParallel;
        };

        OS openBSD
        {
                MAJOR = -1;
                TYPE = chardev;
                ioctl_magicnumber = 0xf5;
                VERSION = ``4.3'';
        };
};

\end{lstlisting}

%\chapter{Kernel developer}
%The first chapter help %\section {BLT}
%BLT are interface between RTX languate and OS developer.



\rtxbibliography

\end{document}
